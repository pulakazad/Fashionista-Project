{"version":3,"file":"compiler.js","sources":["../../../../../../packages/compiler/src/ml_parser/tags.ts","../../../../../../packages/compiler/src/ml_parser/html_tags.ts","../../../../../../packages/compiler/src/selector.ts","../../../../../../packages/compiler/src/core.ts","../../../../../../packages/compiler/src/output/output_ast.ts","../../../../../../packages/compiler/src/util.ts","../../../../../../packages/compiler/src/constant_pool.ts","../../../../../../packages/compiler/src/identifiers.ts","../../../../../../packages/compiler/src/aot/static_symbol.ts","../../../../../../packages/compiler/src/compile_metadata.ts","../../../../../../packages/compiler/src/render3/r3_identifiers.ts","../../../../../../packages/compiler/src/render3/util.ts","../../../../../../packages/compiler/src/chars.ts","../../../../../../packages/compiler/src/parse_util.ts","../../../../../../packages/compiler/src/render3/r3_ast.ts","../../../../../../packages/compiler/src/i18n/i18n_ast.ts","../../../../../../packages/compiler/src/i18n/digest.ts","../../../../../../packages/compiler/src/i18n/serializers/serializer.ts","../../../../../../packages/compiler/src/i18n/serializers/xml_helper.ts","../../../../../../packages/compiler/src/i18n/serializers/xmb.ts","../../../../../../packages/compiler/src/render3/view/i18n/util.ts","../../../../../../packages/compiler/src/render3/view/util.ts","../../../../../../packages/compiler/src/render3/r3_factory.ts","../../../../../../packages/compiler/src/injectable_compiler_2.ts","../../../../../../packages/compiler/src/assertions.ts","../../../../../../packages/compiler/src/ml_parser/interpolation_config.ts","../../../../../../packages/compiler/src/output/source_map.ts","../../../../../../packages/compiler/src/output/abstract_emitter.ts","../../../../../../packages/compiler/src/output/abstract_js_emitter.ts","../../../../../../packages/compiler/src/output/output_jit.ts","../../../../../../packages/compiler/src/render3/r3_jit.ts","../../../../../../packages/compiler/src/output/map_util.ts","../../../../../../packages/compiler/src/render3/r3_module_compiler.ts","../../../../../../packages/compiler/src/render3/r3_pipe_compiler.ts","../../../../../../packages/compiler/src/expression_parser/ast.ts","../../../../../../packages/compiler/src/compiler_util/expression_converter.ts","../../../../../../packages/compiler/src/shadow_css.ts","../../../../../../packages/compiler/src/style_compiler.ts","../../../../../../packages/compiler/src/ast_path.ts","../../../../../../packages/compiler/src/ml_parser/ast.ts","../../../../../../packages/compiler/src/ml_parser/lexer.ts","../../../../../../packages/compiler/src/ml_parser/parser.ts","../../../../../../packages/compiler/src/ml_parser/html_parser.ts","../../../../../../packages/compiler/src/ml_parser/html_whitespaces.ts","../../../../../../packages/compiler/src/ml_parser/icu_ast_expander.ts","../../../../../../packages/compiler/src/template_parser/template_ast.ts","../../../../../../packages/compiler/src/provider_analyzer.ts","../../../../../../packages/compiler/src/style_url_resolver.ts","../../../../../../packages/compiler/src/template_parser/binding_parser.ts","../../../../../../packages/compiler/src/template_parser/template_preparser.ts","../../../../../../packages/compiler/src/template_parser/template_parser.ts","../../../../../../packages/compiler/src/render3/view/style_parser.ts","../../../../../../packages/compiler/src/render3/view/styling_builder.ts","../../../../../../packages/compiler/src/expression_parser/lexer.ts","../../../../../../packages/compiler/src/expression_parser/parser.ts","../../../../../../packages/compiler/src/schema/dom_security_schema.ts","../../../../../../packages/compiler/src/schema/element_schema_registry.ts","../../../../../../packages/compiler/src/schema/dom_element_schema_registry.ts","../../../../../../packages/compiler/src/render3/r3_template_transform.ts","../../../../../../packages/compiler/src/render3/view/i18n/context.ts","../../../../../../packages/compiler/src/render3/view/i18n/icu_serializer.ts","../../../../../../packages/compiler/src/i18n/serializers/placeholder.ts","../../../../../../packages/compiler/src/i18n/i18n_parser.ts","../../../../../../packages/compiler/src/render3/view/i18n/meta.ts","../../../../../../packages/compiler/src/render3/view/i18n/get_msg_utils.ts","../../../../../../packages/compiler/src/render3/view/i18n/localize_utils.ts","../../../../../../packages/compiler/src/render3/view/template.ts","../../../../../../packages/compiler/src/render3/view/compiler.ts","../../../../../../packages/compiler/src/resource_loader.ts","../../../../../../packages/compiler/src/jit_compiler_facade.ts","../../../../../../packages/compiler/src/version.ts","../../../../../../packages/compiler/src/config.ts","../../../../../../packages/compiler/src/directive_normalizer.ts","../../../../../../packages/compiler/src/directive_resolver.ts","../../../../../../packages/compiler/src/i18n/parse_util.ts","../../../../../../packages/compiler/src/i18n/extractor_merger.ts","../../../../../../packages/compiler/src/ml_parser/xml_tags.ts","../../../../../../packages/compiler/src/ml_parser/xml_parser.ts","../../../../../../packages/compiler/src/i18n/serializers/xliff.ts","../../../../../../packages/compiler/src/i18n/serializers/xliff2.ts","../../../../../../packages/compiler/src/i18n/serializers/xtb.ts","../../../../../../packages/compiler/src/i18n/translation_bundle.ts","../../../../../../packages/compiler/src/i18n/i18n_html_parser.ts","../../../../../../packages/compiler/src/output/value_util.ts","../../../../../../packages/compiler/src/injectable_compiler.ts","../../../../../../packages/compiler/src/aot/util.ts","../../../../../../packages/compiler/src/lifecycle_reflector.ts","../../../../../../packages/compiler/src/metadata_resolver.ts","../../../../../../packages/compiler/src/view_compiler/provider_compiler.ts","../../../../../../packages/compiler/src/ng_module_compiler.ts","../../../../../../packages/compiler/src/ng_module_resolver.ts","../../../../../../packages/compiler/src/output/ts_emitter.ts","../../../../../../packages/compiler/src/pipe_resolver.ts","../../../../../../packages/compiler/src/view_compiler/type_check_compiler.ts","../../../../../../packages/compiler/src/view_compiler/view_compiler.ts","../../../../../../packages/compiler/src/i18n/message_bundle.ts","../../../../../../packages/compiler/src/aot/generated_file.ts","../../../../../../packages/compiler/src/aot/lazy_routes.ts","../../../../../../packages/compiler/src/aot/static_symbol_resolver.ts","../../../../../../packages/compiler/src/aot/summary_serializer.ts","../../../../../../packages/compiler/src/aot/compiler.ts","../../../../../../packages/compiler/src/aot/formatted_error.ts","../../../../../../packages/compiler/src/aot/static_reflector.ts","../../../../../../packages/compiler/src/aot/summary_resolver.ts","../../../../../../packages/compiler/src/aot/compiler_factory.ts","../../../../../../packages/compiler/src/summary_resolver.ts","../../../../../../packages/compiler/src/output/output_interpreter.ts","../../../../../../packages/compiler/src/jit/compiler.ts","../../../../../../packages/compiler/src/compile_reflector.ts","../../../../../../packages/compiler/src/url_resolver.ts","../../../../../../packages/compiler/src/i18n/extractor.ts","../../../../../../packages/compiler/src/i18n/index.ts","../../../../../../packages/compiler/src/render3/view/t2_binder.ts","../../../../../../packages/compiler/src/compiler.ts","../../../../../../packages/compiler/public_api.ts","../../../../../../packages/compiler/compiler.ts","../../../../../../packages/compiler/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport enum TagContentType {\n  RAW_TEXT,\n  ESCAPABLE_RAW_TEXT,\n  PARSABLE_DATA\n}\n\nexport interface TagDefinition {\n  closedByParent: boolean;\n  implicitNamespacePrefix: string|null;\n  contentType: TagContentType;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean;\n\n  isClosedByChild(name: string): boolean;\n}\n\nexport function splitNsName(elementName: string): [string | null, string] {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n\n  const colonIndex = elementName.indexOf(':', 1);\n\n  if (colonIndex == -1) {\n    throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n}\n\n// `<ng-container>` tags work the same regardless the namespace\nexport function isNgContainer(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-container';\n}\n\n// `<ng-content>` tags work the same regardless the namespace\nexport function isNgContent(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-content';\n}\n\n// `<ng-template>` tags work the same regardless the namespace\nexport function isNgTemplate(tagName: string): boolean {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\n\nexport function getNsPrefix(fullName: string): string;\nexport function getNsPrefix(fullName: null): null;\nexport function getNsPrefix(fullName: string | null): string|null {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nexport function mergeNsAndName(prefix: string, localName: string): string {\n  return prefix ? `:${prefix}:${localName}` : localName;\n}\n\n// see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\nexport const NAMED_ENTITIES: {[k: string]: string} = {\n  'Aacute': '\\u00C1',\n  'aacute': '\\u00E1',\n  'Acirc': '\\u00C2',\n  'acirc': '\\u00E2',\n  'acute': '\\u00B4',\n  'AElig': '\\u00C6',\n  'aelig': '\\u00E6',\n  'Agrave': '\\u00C0',\n  'agrave': '\\u00E0',\n  'alefsym': '\\u2135',\n  'Alpha': '\\u0391',\n  'alpha': '\\u03B1',\n  'amp': '&',\n  'and': '\\u2227',\n  'ang': '\\u2220',\n  'apos': '\\u0027',\n  'Aring': '\\u00C5',\n  'aring': '\\u00E5',\n  'asymp': '\\u2248',\n  'Atilde': '\\u00C3',\n  'atilde': '\\u00E3',\n  'Auml': '\\u00C4',\n  'auml': '\\u00E4',\n  'bdquo': '\\u201E',\n  'Beta': '\\u0392',\n  'beta': '\\u03B2',\n  'brvbar': '\\u00A6',\n  'bull': '\\u2022',\n  'cap': '\\u2229',\n  'Ccedil': '\\u00C7',\n  'ccedil': '\\u00E7',\n  'cedil': '\\u00B8',\n  'cent': '\\u00A2',\n  'Chi': '\\u03A7',\n  'chi': '\\u03C7',\n  'circ': '\\u02C6',\n  'clubs': '\\u2663',\n  'cong': '\\u2245',\n  'copy': '\\u00A9',\n  'crarr': '\\u21B5',\n  'cup': '\\u222A',\n  'curren': '\\u00A4',\n  'dagger': '\\u2020',\n  'Dagger': '\\u2021',\n  'darr': '\\u2193',\n  'dArr': '\\u21D3',\n  'deg': '\\u00B0',\n  'Delta': '\\u0394',\n  'delta': '\\u03B4',\n  'diams': '\\u2666',\n  'divide': '\\u00F7',\n  'Eacute': '\\u00C9',\n  'eacute': '\\u00E9',\n  'Ecirc': '\\u00CA',\n  'ecirc': '\\u00EA',\n  'Egrave': '\\u00C8',\n  'egrave': '\\u00E8',\n  'empty': '\\u2205',\n  'emsp': '\\u2003',\n  'ensp': '\\u2002',\n  'Epsilon': '\\u0395',\n  'epsilon': '\\u03B5',\n  'equiv': '\\u2261',\n  'Eta': '\\u0397',\n  'eta': '\\u03B7',\n  'ETH': '\\u00D0',\n  'eth': '\\u00F0',\n  'Euml': '\\u00CB',\n  'euml': '\\u00EB',\n  'euro': '\\u20AC',\n  'exist': '\\u2203',\n  'fnof': '\\u0192',\n  'forall': '\\u2200',\n  'frac12': '\\u00BD',\n  'frac14': '\\u00BC',\n  'frac34': '\\u00BE',\n  'frasl': '\\u2044',\n  'Gamma': '\\u0393',\n  'gamma': '\\u03B3',\n  'ge': '\\u2265',\n  'gt': '>',\n  'harr': '\\u2194',\n  'hArr': '\\u21D4',\n  'hearts': '\\u2665',\n  'hellip': '\\u2026',\n  'Iacute': '\\u00CD',\n  'iacute': '\\u00ED',\n  'Icirc': '\\u00CE',\n  'icirc': '\\u00EE',\n  'iexcl': '\\u00A1',\n  'Igrave': '\\u00CC',\n  'igrave': '\\u00EC',\n  'image': '\\u2111',\n  'infin': '\\u221E',\n  'int': '\\u222B',\n  'Iota': '\\u0399',\n  'iota': '\\u03B9',\n  'iquest': '\\u00BF',\n  'isin': '\\u2208',\n  'Iuml': '\\u00CF',\n  'iuml': '\\u00EF',\n  'Kappa': '\\u039A',\n  'kappa': '\\u03BA',\n  'Lambda': '\\u039B',\n  'lambda': '\\u03BB',\n  'lang': '\\u27E8',\n  'laquo': '\\u00AB',\n  'larr': '\\u2190',\n  'lArr': '\\u21D0',\n  'lceil': '\\u2308',\n  'ldquo': '\\u201C',\n  'le': '\\u2264',\n  'lfloor': '\\u230A',\n  'lowast': '\\u2217',\n  'loz': '\\u25CA',\n  'lrm': '\\u200E',\n  'lsaquo': '\\u2039',\n  'lsquo': '\\u2018',\n  'lt': '<',\n  'macr': '\\u00AF',\n  'mdash': '\\u2014',\n  'micro': '\\u00B5',\n  'middot': '\\u00B7',\n  'minus': '\\u2212',\n  'Mu': '\\u039C',\n  'mu': '\\u03BC',\n  'nabla': '\\u2207',\n  'nbsp': '\\u00A0',\n  'ndash': '\\u2013',\n  'ne': '\\u2260',\n  'ni': '\\u220B',\n  'not': '\\u00AC',\n  'notin': '\\u2209',\n  'nsub': '\\u2284',\n  'Ntilde': '\\u00D1',\n  'ntilde': '\\u00F1',\n  'Nu': '\\u039D',\n  'nu': '\\u03BD',\n  'Oacute': '\\u00D3',\n  'oacute': '\\u00F3',\n  'Ocirc': '\\u00D4',\n  'ocirc': '\\u00F4',\n  'OElig': '\\u0152',\n  'oelig': '\\u0153',\n  'Ograve': '\\u00D2',\n  'ograve': '\\u00F2',\n  'oline': '\\u203E',\n  'Omega': '\\u03A9',\n  'omega': '\\u03C9',\n  'Omicron': '\\u039F',\n  'omicron': '\\u03BF',\n  'oplus': '\\u2295',\n  'or': '\\u2228',\n  'ordf': '\\u00AA',\n  'ordm': '\\u00BA',\n  'Oslash': '\\u00D8',\n  'oslash': '\\u00F8',\n  'Otilde': '\\u00D5',\n  'otilde': '\\u00F5',\n  'otimes': '\\u2297',\n  'Ouml': '\\u00D6',\n  'ouml': '\\u00F6',\n  'para': '\\u00B6',\n  'permil': '\\u2030',\n  'perp': '\\u22A5',\n  'Phi': '\\u03A6',\n  'phi': '\\u03C6',\n  'Pi': '\\u03A0',\n  'pi': '\\u03C0',\n  'piv': '\\u03D6',\n  'plusmn': '\\u00B1',\n  'pound': '\\u00A3',\n  'prime': '\\u2032',\n  'Prime': '\\u2033',\n  'prod': '\\u220F',\n  'prop': '\\u221D',\n  'Psi': '\\u03A8',\n  'psi': '\\u03C8',\n  'quot': '\\u0022',\n  'radic': '\\u221A',\n  'rang': '\\u27E9',\n  'raquo': '\\u00BB',\n  'rarr': '\\u2192',\n  'rArr': '\\u21D2',\n  'rceil': '\\u2309',\n  'rdquo': '\\u201D',\n  'real': '\\u211C',\n  'reg': '\\u00AE',\n  'rfloor': '\\u230B',\n  'Rho': '\\u03A1',\n  'rho': '\\u03C1',\n  'rlm': '\\u200F',\n  'rsaquo': '\\u203A',\n  'rsquo': '\\u2019',\n  'sbquo': '\\u201A',\n  'Scaron': '\\u0160',\n  'scaron': '\\u0161',\n  'sdot': '\\u22C5',\n  'sect': '\\u00A7',\n  'shy': '\\u00AD',\n  'Sigma': '\\u03A3',\n  'sigma': '\\u03C3',\n  'sigmaf': '\\u03C2',\n  'sim': '\\u223C',\n  'spades': '\\u2660',\n  'sub': '\\u2282',\n  'sube': '\\u2286',\n  'sum': '\\u2211',\n  'sup': '\\u2283',\n  'sup1': '\\u00B9',\n  'sup2': '\\u00B2',\n  'sup3': '\\u00B3',\n  'supe': '\\u2287',\n  'szlig': '\\u00DF',\n  'Tau': '\\u03A4',\n  'tau': '\\u03C4',\n  'there4': '\\u2234',\n  'Theta': '\\u0398',\n  'theta': '\\u03B8',\n  'thetasym': '\\u03D1',\n  'thinsp': '\\u2009',\n  'THORN': '\\u00DE',\n  'thorn': '\\u00FE',\n  'tilde': '\\u02DC',\n  'times': '\\u00D7',\n  'trade': '\\u2122',\n  'Uacute': '\\u00DA',\n  'uacute': '\\u00FA',\n  'uarr': '\\u2191',\n  'uArr': '\\u21D1',\n  'Ucirc': '\\u00DB',\n  'ucirc': '\\u00FB',\n  'Ugrave': '\\u00D9',\n  'ugrave': '\\u00F9',\n  'uml': '\\u00A8',\n  'upsih': '\\u03D2',\n  'Upsilon': '\\u03A5',\n  'upsilon': '\\u03C5',\n  'Uuml': '\\u00DC',\n  'uuml': '\\u00FC',\n  'weierp': '\\u2118',\n  'Xi': '\\u039E',\n  'xi': '\\u03BE',\n  'Yacute': '\\u00DD',\n  'yacute': '\\u00FD',\n  'yen': '\\u00A5',\n  'yuml': '\\u00FF',\n  'Yuml': '\\u0178',\n  'Zeta': '\\u0396',\n  'zeta': '\\u03B6',\n  'zwj': '\\u200D',\n  'zwnj': '\\u200C',\n};\n\n// The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\nexport const NGSP_UNICODE = '\\uE500';\n\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {TagContentType, TagDefinition} from './tags';\n\nexport class HtmlTagDefinition implements TagDefinition {\n  private closedByChildren: {[key: string]: boolean} = {};\n\n  closedByParent: boolean = false;\n  implicitNamespacePrefix: string|null;\n  contentType: TagContentType;\n  isVoid: boolean;\n  ignoreFirstLf: boolean;\n  canSelfClose: boolean = false;\n\n  constructor(\n      {closedByChildren, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA,\n       closedByParent = false, isVoid = false, ignoreFirstLf = false}: {\n        closedByChildren?: string[],\n        closedByParent?: boolean,\n        implicitNamespacePrefix?: string,\n        contentType?: TagContentType,\n        isVoid?: boolean,\n        ignoreFirstLf?: boolean\n      } = {}) {\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\n    }\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n  }\n\n  isClosedByChild(name: string): boolean {\n    return this.isVoid || name.toLowerCase() in this.closedByChildren;\n  }\n}\n\nlet _DEFAULT_TAG_DEFINITION !: HtmlTagDefinition;\n\n// see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\nlet TAG_DEFINITIONS !: {[key: string]: HtmlTagDefinition};\n\nexport function getHtmlTagDefinition(tagName: string): HtmlTagDefinition {\n  if (!TAG_DEFINITIONS) {\n    _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n    TAG_DEFINITIONS = {\n      'base': new HtmlTagDefinition({isVoid: true}),\n      'meta': new HtmlTagDefinition({isVoid: true}),\n      'area': new HtmlTagDefinition({isVoid: true}),\n      'embed': new HtmlTagDefinition({isVoid: true}),\n      'link': new HtmlTagDefinition({isVoid: true}),\n      'img': new HtmlTagDefinition({isVoid: true}),\n      'input': new HtmlTagDefinition({isVoid: true}),\n      'param': new HtmlTagDefinition({isVoid: true}),\n      'hr': new HtmlTagDefinition({isVoid: true}),\n      'br': new HtmlTagDefinition({isVoid: true}),\n      'source': new HtmlTagDefinition({isVoid: true}),\n      'track': new HtmlTagDefinition({isVoid: true}),\n      'wbr': new HtmlTagDefinition({isVoid: true}),\n      'p': new HtmlTagDefinition({\n        closedByChildren: [\n          'address', 'article', 'aside',   'blockquote', 'div',  'dl',  'fieldset',\n          'footer',  'form',    'h1',      'h2',         'h3',   'h4',  'h5',\n          'h6',      'header',  'hgroup',  'hr',         'main', 'nav', 'ol',\n          'p',       'pre',     'section', 'table',      'ul'\n        ],\n        closedByParent: true\n      }),\n      'thead': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot']}),\n      'tbody': new HtmlTagDefinition({closedByChildren: ['tbody', 'tfoot'], closedByParent: true}),\n      'tfoot': new HtmlTagDefinition({closedByChildren: ['tbody'], closedByParent: true}),\n      'tr': new HtmlTagDefinition({closedByChildren: ['tr'], closedByParent: true}),\n      'td': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n      'th': new HtmlTagDefinition({closedByChildren: ['td', 'th'], closedByParent: true}),\n      'col': new HtmlTagDefinition({isVoid: true}),\n      'svg': new HtmlTagDefinition({implicitNamespacePrefix: 'svg'}),\n      'math': new HtmlTagDefinition({implicitNamespacePrefix: 'math'}),\n      'li': new HtmlTagDefinition({closedByChildren: ['li'], closedByParent: true}),\n      'dt': new HtmlTagDefinition({closedByChildren: ['dt', 'dd']}),\n      'dd': new HtmlTagDefinition({closedByChildren: ['dt', 'dd'], closedByParent: true}),\n      'rb': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'rt': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'rtc': new HtmlTagDefinition({closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true}),\n      'rp': new HtmlTagDefinition(\n          {closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true}),\n      'optgroup': new HtmlTagDefinition({closedByChildren: ['optgroup'], closedByParent: true}),\n      'option':\n          new HtmlTagDefinition({closedByChildren: ['option', 'optgroup'], closedByParent: true}),\n      'pre': new HtmlTagDefinition({ignoreFirstLf: true}),\n      'listing': new HtmlTagDefinition({ignoreFirstLf: true}),\n      'style': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n      'script': new HtmlTagDefinition({contentType: TagContentType.RAW_TEXT}),\n      'title': new HtmlTagDefinition({contentType: TagContentType.ESCAPABLE_RAW_TEXT}),\n      'textarea': new HtmlTagDefinition(\n          {contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true}),\n    };\n  }\n  return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getHtmlTagDefinition} from './ml_parser/html_tags';\n\nconst _SELECTOR_REGEXP = new RegExp(\n    '(\\\\:not\\\\()|' +               // 1: \":not(\"\n        '(([\\\\.\\\\#]?)[-\\\\w]+)|' +  // 2: \"tag\"; 3: \".\"/\"#\";\n        // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n        // 4: attribute; 5: attribute_string; 6: attribute_value\n        '(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' +  // \"[name]\", \"[name=value]\",\n                                                                   // \"[name=\"value\"]\",\n                                                                   // \"[name='value']\"\n        '(\\\\))|' +                                                 // 7: \")\"\n        '(\\\\s*,\\\\s*)',                                             // 8: \",\"\n    'g');\n\n/**\n * These offsets should match the match-groups in `_SELECTOR_REGEXP` offsets.\n */\nconst enum SelectorRegexp {\n  ALL = 0,  // The whole match\n  NOT = 1,\n  TAG = 2,\n  PREFIX = 3,\n  ATTRIBUTE = 4,\n  ATTRIBUTE_STRING = 5,\n  ATTRIBUTE_VALUE = 6,\n  NOT_END = 7,\n  SEPARATOR = 8,\n}\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\nexport class CssSelector {\n  element: string|null = null;\n  classNames: string[] = [];\n  /**\n   * The selectors are encoded in pairs where:\n   * - even locations are attribute names\n   * - odd locations are attribute values.\n   *\n   * Example:\n   * Selector: `[key1=value1][key2]` would parse to:\n   * ```\n   * ['key1', 'value1', 'key2', '']\n   * ```\n   */\n  attrs: string[] = [];\n  notSelectors: CssSelector[] = [];\n\n  static parse(selector: string): CssSelector[] {\n    const results: CssSelector[] = [];\n    const _addResult = (res: CssSelector[], cssSel: CssSelector) => {\n      if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\n          cssSel.attrs.length == 0) {\n        cssSel.element = '*';\n      }\n      res.push(cssSel);\n    };\n    let cssSelector = new CssSelector();\n    let match: string[]|null;\n    let current = cssSelector;\n    let inNot = false;\n    _SELECTOR_REGEXP.lastIndex = 0;\n    while (match = _SELECTOR_REGEXP.exec(selector)) {\n      if (match[SelectorRegexp.NOT]) {\n        if (inNot) {\n          throw new Error('Nesting :not in a selector is not allowed');\n        }\n        inNot = true;\n        current = new CssSelector();\n        cssSelector.notSelectors.push(current);\n      }\n      const tag = match[SelectorRegexp.TAG];\n      if (tag) {\n        const prefix = match[SelectorRegexp.PREFIX];\n        if (prefix === '#') {\n          // #hash\n          current.addAttribute('id', tag.substr(1));\n        } else if (prefix === '.') {\n          // Class\n          current.addClassName(tag.substr(1));\n        } else {\n          // Element\n          current.setElement(tag);\n        }\n      }\n      const attribute = match[SelectorRegexp.ATTRIBUTE];\n      if (attribute) {\n        current.addAttribute(attribute, match[SelectorRegexp.ATTRIBUTE_VALUE]);\n      }\n      if (match[SelectorRegexp.NOT_END]) {\n        inNot = false;\n        current = cssSelector;\n      }\n      if (match[SelectorRegexp.SEPARATOR]) {\n        if (inNot) {\n          throw new Error('Multiple selectors in :not are not supported');\n        }\n        _addResult(results, cssSelector);\n        cssSelector = current = new CssSelector();\n      }\n    }\n    _addResult(results, cssSelector);\n    return results;\n  }\n\n  isElementSelector(): boolean {\n    return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\n        this.notSelectors.length === 0;\n  }\n\n  hasElementSelector(): boolean { return !!this.element; }\n\n  setElement(element: string|null = null) { this.element = element; }\n\n  /** Gets a template string for an element that matches the selector. */\n  getMatchingElementTemplate(): string {\n    const tagName = this.element || 'div';\n    const classAttr = this.classNames.length > 0 ? ` class=\"${this.classNames.join(' ')}\"` : '';\n\n    let attrs = '';\n    for (let i = 0; i < this.attrs.length; i += 2) {\n      const attrName = this.attrs[i];\n      const attrValue = this.attrs[i + 1] !== '' ? `=\"${this.attrs[i + 1]}\"` : '';\n      attrs += ` ${attrName}${attrValue}`;\n    }\n\n    return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :\n                                                  `<${tagName}${classAttr}${attrs}></${tagName}>`;\n  }\n\n  getAttrs(): string[] {\n    const result: string[] = [];\n    if (this.classNames.length > 0) {\n      result.push('class', this.classNames.join(' '));\n    }\n    return result.concat(this.attrs);\n  }\n\n  addAttribute(name: string, value: string = '') {\n    this.attrs.push(name, value && value.toLowerCase() || '');\n  }\n\n  addClassName(name: string) { this.classNames.push(name.toLowerCase()); }\n\n  toString(): string {\n    let res: string = this.element || '';\n    if (this.classNames) {\n      this.classNames.forEach(klass => res += `.${klass}`);\n    }\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length; i += 2) {\n        const name = this.attrs[i];\n        const value = this.attrs[i + 1];\n        res += `[${name}${value ? '=' + value : ''}]`;\n      }\n    }\n    this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\n    return res;\n  }\n}\n\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\nexport class SelectorMatcher<T = any> {\n  static createNotMatcher(notSelectors: CssSelector[]): SelectorMatcher<null> {\n    const notMatcher = new SelectorMatcher<null>();\n    notMatcher.addSelectables(notSelectors, null);\n    return notMatcher;\n  }\n\n  private _elementMap = new Map<string, SelectorContext<T>[]>();\n  private _elementPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _classMap = new Map<string, SelectorContext<T>[]>();\n  private _classPartialMap = new Map<string, SelectorMatcher<T>>();\n  private _attrValueMap = new Map<string, Map<string, SelectorContext<T>[]>>();\n  private _attrValuePartialMap = new Map<string, Map<string, SelectorMatcher<T>>>();\n  private _listContexts: SelectorListContext[] = [];\n\n  addSelectables(cssSelectors: CssSelector[], callbackCtxt?: T) {\n    let listContext: SelectorListContext = null !;\n    if (cssSelectors.length > 1) {\n      listContext = new SelectorListContext(cssSelectors);\n      this._listContexts.push(listContext);\n    }\n    for (let i = 0; i < cssSelectors.length; i++) {\n      this._addSelectable(cssSelectors[i], callbackCtxt as T, listContext);\n    }\n  }\n\n  /**\n   * Add an object that can be found later on by calling `match`.\n   * @param cssSelector A css selector\n   * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n   */\n  private _addSelectable(\n      cssSelector: CssSelector, callbackCtxt: T, listContext: SelectorListContext) {\n    let matcher: SelectorMatcher<T> = this;\n    const element = cssSelector.element;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n    const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n    if (element) {\n      const isTerminal = attrs.length === 0 && classNames.length === 0;\n      if (isTerminal) {\n        this._addTerminal(matcher._elementMap, element, selectable);\n      } else {\n        matcher = this._addPartial(matcher._elementPartialMap, element);\n      }\n    }\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const isTerminal = attrs.length === 0 && i === classNames.length - 1;\n        const className = classNames[i];\n        if (isTerminal) {\n          this._addTerminal(matcher._classMap, className, selectable);\n        } else {\n          matcher = this._addPartial(matcher._classPartialMap, className);\n        }\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const isTerminal = i === attrs.length - 2;\n        const name = attrs[i];\n        const value = attrs[i + 1];\n        if (isTerminal) {\n          const terminalMap = matcher._attrValueMap;\n          let terminalValuesMap = terminalMap.get(name);\n          if (!terminalValuesMap) {\n            terminalValuesMap = new Map<string, SelectorContext<T>[]>();\n            terminalMap.set(name, terminalValuesMap);\n          }\n          this._addTerminal(terminalValuesMap, value, selectable);\n        } else {\n          const partialMap = matcher._attrValuePartialMap;\n          let partialValuesMap = partialMap.get(name);\n          if (!partialValuesMap) {\n            partialValuesMap = new Map<string, SelectorMatcher<T>>();\n            partialMap.set(name, partialValuesMap);\n          }\n          matcher = this._addPartial(partialValuesMap, value);\n        }\n      }\n    }\n  }\n\n  private _addTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, selectable: SelectorContext<T>) {\n    let terminalList = map.get(name);\n    if (!terminalList) {\n      terminalList = [];\n      map.set(name, terminalList);\n    }\n    terminalList.push(selectable);\n  }\n\n  private _addPartial(map: Map<string, SelectorMatcher<T>>, name: string): SelectorMatcher<T> {\n    let matcher = map.get(name);\n    if (!matcher) {\n      matcher = new SelectorMatcher<T>();\n      map.set(name, matcher);\n    }\n    return matcher;\n  }\n\n  /**\n   * Find the objects that have been added via `addSelectable`\n   * whose css selector is contained in the given css selector.\n   * @param cssSelector A css selector\n   * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n   * @return boolean true if a match was found\n  */\n  match(cssSelector: CssSelector, matchedCallback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = false;\n    const element = cssSelector.element !;\n    const classNames = cssSelector.classNames;\n    const attrs = cssSelector.attrs;\n\n    for (let i = 0; i < this._listContexts.length; i++) {\n      this._listContexts[i].alreadyMatched = false;\n    }\n\n    result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n    result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\n        result;\n\n    if (classNames) {\n      for (let i = 0; i < classNames.length; i++) {\n        const className = classNames[i];\n        result =\n            this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n        result =\n            this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\n            result;\n      }\n    }\n\n    if (attrs) {\n      for (let i = 0; i < attrs.length; i += 2) {\n        const name = attrs[i];\n        const value = attrs[i + 1];\n\n        const terminalValuesMap = this._attrValueMap.get(name) !;\n        if (value) {\n          result =\n              this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n        const partialValuesMap = this._attrValuePartialMap.get(name) !;\n        if (value) {\n          result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n        }\n        result =\n            this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n      }\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchTerminal(\n      map: Map<string, SelectorContext<T>[]>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    let selectables: SelectorContext<T>[] = map.get(name) || [];\n    const starSelectables: SelectorContext<T>[] = map.get('*') !;\n    if (starSelectables) {\n      selectables = selectables.concat(starSelectables);\n    }\n    if (selectables.length === 0) {\n      return false;\n    }\n    let selectable: SelectorContext<T>;\n    let result = false;\n    for (let i = 0; i < selectables.length; i++) {\n      selectable = selectables[i];\n      result = selectable.finalize(cssSelector, matchedCallback) || result;\n    }\n    return result;\n  }\n\n  /** @internal */\n  _matchPartial(\n      map: Map<string, SelectorMatcher<T>>, name: string, cssSelector: CssSelector,\n      matchedCallback: ((c: CssSelector, a: any) => void)|null): boolean {\n    if (!map || typeof name !== 'string') {\n      return false;\n    }\n\n    const nestedSelector = map.get(name);\n    if (!nestedSelector) {\n      return false;\n    }\n    // TODO(perf): get rid of recursion and measure again\n    // TODO(perf): don't pass the whole selector into the recursion,\n    // but only the not processed parts\n    return nestedSelector.match(cssSelector, matchedCallback);\n  }\n}\n\n\nexport class SelectorListContext {\n  alreadyMatched: boolean = false;\n\n  constructor(public selectors: CssSelector[]) {}\n}\n\n// Store context to pass back selector and context when a selector is matched\nexport class SelectorContext<T = any> {\n  notSelectors: CssSelector[];\n\n  constructor(\n      public selector: CssSelector, public cbContext: T, public listContext: SelectorListContext) {\n    this.notSelectors = selector.notSelectors;\n  }\n\n  finalize(cssSelector: CssSelector, callback: ((c: CssSelector, a: T) => void)|null): boolean {\n    let result = true;\n    if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n      const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n      result = !notMatcher.match(cssSelector, null);\n    }\n    if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n      if (this.listContext) {\n        this.listContext.alreadyMatched = true;\n      }\n      callback(this.selector, this.cbContext);\n    }\n    return result;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Attention:\n// This file duplicates types and values from @angular/core\n// so that we are able to make @angular/compiler independent of @angular/core.\n// This is important to prevent a build cycle, as @angular/core needs to\n// be compiled with the compiler.\n\nimport {CssSelector} from './selector';\n\nexport interface Inject { token: any; }\nexport const createInject = makeMetadataFactory<Inject>('Inject', (token: any) => ({token}));\nexport const createInjectionToken = makeMetadataFactory<object>(\n    'InjectionToken', (desc: string) => ({_desc: desc, Éµprov: undefined}));\n\nexport interface Attribute { attributeName?: string; }\nexport const createAttribute =\n    makeMetadataFactory<Attribute>('Attribute', (attributeName?: string) => ({attributeName}));\n\nexport interface Query {\n  descendants: boolean;\n  first: boolean;\n  read: any;\n  isViewQuery: boolean;\n  selector: any;\n  static?: boolean;\n}\n\nexport const createContentChildren = makeMetadataFactory<Query>(\n    'ContentChildren',\n    (selector?: any, data: any = {}) =>\n        ({selector, first: false, isViewQuery: false, descendants: false, ...data}));\nexport const createContentChild = makeMetadataFactory<Query>(\n    'ContentChild', (selector?: any, data: any = {}) =>\n                        ({selector, first: true, isViewQuery: false, descendants: true, ...data}));\nexport const createViewChildren = makeMetadataFactory<Query>(\n    'ViewChildren', (selector?: any, data: any = {}) =>\n                        ({selector, first: false, isViewQuery: true, descendants: true, ...data}));\nexport const createViewChild = makeMetadataFactory<Query>(\n    'ViewChild', (selector: any, data: any) =>\n                     ({selector, first: true, isViewQuery: true, descendants: true, ...data}));\n\nexport interface Directive {\n  selector?: string;\n  inputs?: string[];\n  outputs?: string[];\n  host?: {[key: string]: string};\n  providers?: Provider[];\n  exportAs?: string;\n  queries?: {[key: string]: any};\n  guards?: {[key: string]: any};\n}\nexport const createDirective =\n    makeMetadataFactory<Directive>('Directive', (dir: Directive = {}) => dir);\n\nexport interface Component extends Directive {\n  changeDetection?: ChangeDetectionStrategy;\n  viewProviders?: Provider[];\n  moduleId?: string;\n  templateUrl?: string;\n  template?: string;\n  styleUrls?: string[];\n  styles?: string[];\n  animations?: any[];\n  encapsulation?: ViewEncapsulation;\n  interpolation?: [string, string];\n  entryComponents?: Array<Type|any[]>;\n  preserveWhitespaces?: boolean;\n}\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  Native = 1,\n  None = 2,\n  ShadowDom = 3\n}\n\nexport enum ChangeDetectionStrategy {\n  OnPush = 0,\n  Default = 1\n}\n\nexport const createComponent = makeMetadataFactory<Component>(\n    'Component', (c: Component = {}) => ({changeDetection: ChangeDetectionStrategy.Default, ...c}));\n\nexport interface Pipe {\n  name: string;\n  pure?: boolean;\n}\nexport const createPipe = makeMetadataFactory<Pipe>('Pipe', (p: Pipe) => ({pure: true, ...p}));\n\nexport interface Input { bindingPropertyName?: string; }\nexport const createInput =\n    makeMetadataFactory<Input>('Input', (bindingPropertyName?: string) => ({bindingPropertyName}));\n\nexport interface Output { bindingPropertyName?: string; }\nexport const createOutput = makeMetadataFactory<Output>(\n    'Output', (bindingPropertyName?: string) => ({bindingPropertyName}));\n\nexport interface HostBinding { hostPropertyName?: string; }\nexport const createHostBinding = makeMetadataFactory<HostBinding>(\n    'HostBinding', (hostPropertyName?: string) => ({hostPropertyName}));\n\nexport interface HostListener {\n  eventName?: string;\n  args?: string[];\n}\nexport const createHostListener = makeMetadataFactory<HostListener>(\n    'HostListener', (eventName?: string, args?: string[]) => ({eventName, args}));\n\nexport interface NgModule {\n  providers?: Provider[];\n  declarations?: Array<Type|any[]>;\n  imports?: Array<Type|ModuleWithProviders|any[]>;\n  exports?: Array<Type|any[]>;\n  entryComponents?: Array<Type|any[]>;\n  bootstrap?: Array<Type|any[]>;\n  schemas?: Array<SchemaMetadata|any[]>;\n  id?: string;\n}\nexport const createNgModule =\n    makeMetadataFactory<NgModule>('NgModule', (ngModule: NgModule) => ngModule);\n\nexport interface ModuleWithProviders {\n  ngModule: Type;\n  providers?: Provider[];\n}\nexport interface Injectable {\n  providedIn?: Type|'root'|any;\n  useClass?: Type|any;\n  useExisting?: Type|any;\n  useValue?: any;\n  useFactory?: Type|any;\n  deps?: Array<Type|any[]>;\n}\nexport const createInjectable =\n    makeMetadataFactory('Injectable', (injectable: Injectable = {}) => injectable);\nexport interface SchemaMetadata { name: string; }\n\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements'\n};\n\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema'\n};\n\nexport const createOptional = makeMetadataFactory('Optional');\nexport const createSelf = makeMetadataFactory('Self');\nexport const createSkipSelf = makeMetadataFactory('SkipSelf');\nexport const createHost = makeMetadataFactory('Host');\n\nexport interface Type extends Function { new (...args: any[]): any; }\nexport const Type = Function;\n\nexport enum SecurityContext {\n  NONE = 0,\n  HTML = 1,\n  STYLE = 2,\n  SCRIPT = 3,\n  URL = 4,\n  RESOURCE_URL = 5,\n}\n\nexport type Provider = any;\n\nexport const enum NodeFlags {\n  None = 0,\n  TypeElement = 1 << 0,\n  TypeText = 1 << 1,\n  ProjectedTemplate = 1 << 2,\n  CatRenderNode = TypeElement | TypeText,\n  TypeNgContent = 1 << 3,\n  TypePipe = 1 << 4,\n  TypePureArray = 1 << 5,\n  TypePureObject = 1 << 6,\n  TypePurePipe = 1 << 7,\n  CatPureExpression = TypePureArray | TypePureObject | TypePurePipe,\n  TypeValueProvider = 1 << 8,\n  TypeClassProvider = 1 << 9,\n  TypeFactoryProvider = 1 << 10,\n  TypeUseExistingProvider = 1 << 11,\n  LazyProvider = 1 << 12,\n  PrivateProvider = 1 << 13,\n  TypeDirective = 1 << 14,\n  Component = 1 << 15,\n  CatProviderNoDirective =\n      TypeValueProvider | TypeClassProvider | TypeFactoryProvider | TypeUseExistingProvider,\n  CatProvider = CatProviderNoDirective | TypeDirective,\n  OnInit = 1 << 16,\n  OnDestroy = 1 << 17,\n  DoCheck = 1 << 18,\n  OnChanges = 1 << 19,\n  AfterContentInit = 1 << 20,\n  AfterContentChecked = 1 << 21,\n  AfterViewInit = 1 << 22,\n  AfterViewChecked = 1 << 23,\n  EmbeddedViews = 1 << 24,\n  ComponentView = 1 << 25,\n  TypeContentQuery = 1 << 26,\n  TypeViewQuery = 1 << 27,\n  StaticQuery = 1 << 28,\n  DynamicQuery = 1 << 29,\n  TypeModuleProvider = 1 << 30,\n  CatQuery = TypeContentQuery | TypeViewQuery,\n\n  // mutually exclusive values...\n  Types = CatRenderNode | TypeNgContent | TypePipe | CatPureExpression | CatProvider | CatQuery\n}\n\nexport const enum DepFlags {\n  None = 0,\n  SkipSelf = 1 << 0,\n  Optional = 1 << 1,\n  Self = 1 << 2,\n  Value = 1 << 3,\n}\n\n/**\n * Injection flags for DI.\n */\nexport const enum InjectFlags {\n  Default = 0,\n\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 1 << 0,\n  /** Don't descend into ancestors of the node requesting injection. */\n  Self = 1 << 1,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 1 << 2,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 1 << 3,\n}\n\nexport const enum ArgumentType {Inline = 0, Dynamic = 1}\n\nexport const enum BindingFlags {\n  TypeElementAttribute = 1 << 0,\n  TypeElementClass = 1 << 1,\n  TypeElementStyle = 1 << 2,\n  TypeProperty = 1 << 3,\n  SyntheticProperty = 1 << 4,\n  SyntheticHostProperty = 1 << 5,\n  CatSyntheticProperty = SyntheticProperty | SyntheticHostProperty,\n\n  // mutually exclusive values...\n  Types = TypeElementAttribute | TypeElementClass | TypeElementStyle | TypeProperty\n}\n\nexport const enum QueryBindingType {First = 0, All = 1}\n\nexport const enum QueryValueType {\n  ElementRef = 0,\n  RenderElement = 1,\n  TemplateRef = 2,\n  ViewContainerRef = 3,\n  Provider = 4\n}\n\nexport const enum ViewFlags {\n  None = 0,\n  OnPush = 1 << 1,\n}\n\nexport enum MissingTranslationStrategy {\n  Error = 0,\n  Warning = 1,\n  Ignore = 2,\n}\n\nexport interface MetadataFactory<T> {\n  (...args: any[]): T;\n  isTypeOf(obj: any): obj is T;\n  ngMetadataName: string;\n}\n\nfunction makeMetadataFactory<T>(name: string, props?: (...args: any[]) => T): MetadataFactory<T> {\n  // This must be declared as a function, not a fat arrow, so that ES2015 devmode produces code\n  // that works with the static_reflector.ts in the ViewEngine compiler.\n  // In particular, `_registerDecoratorOrConstructor` assumes that the value returned here can be\n  // new'ed.\n  function factory(...args: any[]) {\n    const values = props ? props(...args) : {};\n    return {\n      ngMetadataName: name,\n      ...values,\n    };\n  }\n  (factory as any).isTypeOf = (obj: any) => obj && obj.ngMetadataName === name;\n  (factory as any).ngMetadataName = name;\n  return factory as any;\n}\n\nexport interface Route {\n  children?: Route[];\n  loadChildren?: string|Type|any;\n}\n\n/**\n * Flags used to generate R3-style CSS Selectors. They are pasted from\n * core/src/render3/projection.ts because they cannot be referenced directly.\n */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\n// These are a copy the CSS types from core/src/render3/interfaces/projection.ts\n// They are duplicated here as they cannot be directly referenced from core.\nexport type R3CssSelector = (string | SelectorFlags)[];\nexport type R3CssSelectorList = R3CssSelector[];\n\nfunction parserSelectorToSimpleSelector(selector: CssSelector): R3CssSelector {\n  const classes = selector.classNames && selector.classNames.length ?\n      [SelectorFlags.CLASS, ...selector.classNames] :\n      [];\n  const elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName, ...selector.attrs, ...classes];\n}\n\nfunction parserSelectorToNegativeSelector(selector: CssSelector): R3CssSelector {\n  const classes = selector.classNames && selector.classNames.length ?\n      [SelectorFlags.CLASS, ...selector.classNames] :\n      [];\n\n  if (selector.element) {\n    return [\n      SelectorFlags.NOT | SelectorFlags.ELEMENT, selector.element, ...selector.attrs, ...classes\n    ];\n  } else if (selector.attrs.length) {\n    return [SelectorFlags.NOT | SelectorFlags.ATTRIBUTE, ...selector.attrs, ...classes];\n  } else {\n    return selector.classNames && selector.classNames.length ?\n        [SelectorFlags.NOT | SelectorFlags.CLASS, ...selector.classNames] :\n        [];\n  }\n}\n\nfunction parserSelectorToR3Selector(selector: CssSelector): R3CssSelector {\n  const positive = parserSelectorToSimpleSelector(selector);\n\n  const negative: R3CssSelectorList = selector.notSelectors && selector.notSelectors.length ?\n      selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :\n      [];\n\n  return positive.concat(...negative);\n}\n\nexport function parseSelectorToR3Selector(selector: string | null): R3CssSelectorList {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\n// Pasted from render3/interfaces/definition since it cannot be referenced directly\n/**\n * Flags passed into template functions to determine which blocks (i.e. creation, update)\n * should be executed.\n *\n * Typically, a template runs both the creation block and the update block on initialization and\n * subsequent runs only execute the update block. However, dynamically created views require that\n * the creation block be executed separately from the update block (for backwards compat).\n */\nexport const enum RenderFlags {\n  /* Whether to run the creation block (e.g. create elements and directives) */\n  Create = 0b01,\n\n  /* Whether to run the update block (e.g. refresh bindings) */\n  Update = 0b10\n}\n\n// Pasted from render3/interfaces/node.ts\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n   * Signals class declaration.\n   *\n   * Each value following `Classes` designates a class name to include on the element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div class=\"foo bar baz\">...<d/vi>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n   * ```\n   */\n  Classes = 1,\n\n  /**\n   * Signals style declaration.\n   *\n   * Each pair of values following `Styles` designates a style name and value to include on the\n   * element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div style=\"width:100px; height:200px; color:red\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n   * ```\n   */\n  Styles = 2,\n\n  /**\n   * Signals that the following attribute names were extracted from input or output bindings.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n   * ```\n   */\n  Bindings = 3,\n\n  /**\n   * Signals that the following attribute names were hoisted from an inline-template declaration.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n   * ```\n   *\n   * the generated code for the `template()` instruction would include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n   * 'ngForTrackBy', 'let-value']\n   * ```\n   *\n   * while the generated code for the `element()` instruction inside the template function would\n   * include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n   * ```\n   */\n  Template = 4,\n\n  /**\n   * Signals that the following attribute is `ngProjectAs` and its value is a parsed `CssSelector`.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n   * ```\n   *\n   * the generated code for the `element()` instruction would include:\n   *\n   * ```\n   * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n   * ```\n   */\n  ProjectAs = 5,\n\n  /**\n   * Signals that the following attribute will be translated by runtime i18n\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n   */\n  I18n = 6,\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {ParseSourceSpan} from '../parse_util';\nimport {I18nMeta} from '../render3/view/i18n/meta';\nimport {error} from '../util';\n\n//// Types\nexport enum TypeModifier {\n  Const\n}\n\nexport abstract class Type {\n  constructor(public modifiers: TypeModifier[]|null = null) {\n    if (!modifiers) {\n      this.modifiers = [];\n    }\n  }\n  abstract visitType(visitor: TypeVisitor, context: any): any;\n\n  hasModifier(modifier: TypeModifier): boolean { return this.modifiers !.indexOf(modifier) !== -1; }\n}\n\nexport enum BuiltinTypeName {\n  Dynamic,\n  Bool,\n  String,\n  Int,\n  Number,\n  Function,\n  Inferred,\n  None,\n}\n\nexport class BuiltinType extends Type {\n  constructor(public name: BuiltinTypeName, modifiers: TypeModifier[]|null = null) {\n    super(modifiers);\n  }\n  visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitBuiltinType(this, context);\n  }\n}\n\nexport class ExpressionType extends Type {\n  constructor(\n      public value: Expression, modifiers: TypeModifier[]|null = null,\n      public typeParams: Type[]|null = null) {\n    super(modifiers);\n  }\n  visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitExpressionType(this, context);\n  }\n}\n\n\nexport class ArrayType extends Type {\n  constructor(public of : Type, modifiers: TypeModifier[]|null = null) { super(modifiers); }\n  visitType(visitor: TypeVisitor, context: any): any {\n    return visitor.visitArrayType(this, context);\n  }\n}\n\n\nexport class MapType extends Type {\n  public valueType: Type|null;\n  constructor(valueType: Type|null|undefined, modifiers: TypeModifier[]|null = null) {\n    super(modifiers);\n    this.valueType = valueType || null;\n  }\n  visitType(visitor: TypeVisitor, context: any): any { return visitor.visitMapType(this, context); }\n}\n\nexport const DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nexport const INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nexport const BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nexport const INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nexport const NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nexport const STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nexport const FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nexport const NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\n\nexport interface TypeVisitor {\n  visitBuiltinType(type: BuiltinType, context: any): any;\n  visitExpressionType(type: ExpressionType, context: any): any;\n  visitArrayType(type: ArrayType, context: any): any;\n  visitMapType(type: MapType, context: any): any;\n}\n\n///// Expressions\n\nexport enum BinaryOperator {\n  Equals,\n  NotEquals,\n  Identical,\n  NotIdentical,\n  Minus,\n  Plus,\n  Divide,\n  Multiply,\n  Modulo,\n  And,\n  Or,\n  BitwiseAnd,\n  Lower,\n  LowerEquals,\n  Bigger,\n  BiggerEquals\n}\n\nexport function nullSafeIsEquivalent<T extends{isEquivalent(other: T): boolean}>(\n    base: T | null, other: T | null) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n  return base.isEquivalent(other);\n}\n\nexport function areAllEquivalent<T extends{isEquivalent(other: T): boolean}>(\n    base: T[], other: T[]) {\n  const len = base.length;\n  if (len !== other.length) {\n    return false;\n  }\n  for (let i = 0; i < len; i++) {\n    if (!base[i].isEquivalent(other[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport abstract class Expression {\n  public type: Type|null;\n  public sourceSpan: ParseSourceSpan|null;\n\n  constructor(type: Type|null|undefined, sourceSpan?: ParseSourceSpan|null) {\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  abstract visitExpression(visitor: ExpressionVisitor, context: any): any;\n\n  /**\n   * Calculates whether this expression produces the same value as the given expression.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(e: Expression): boolean;\n\n  /**\n   * Return true if the expression is constant.\n   */\n  abstract isConstant(): boolean;\n\n  prop(name: string, sourceSpan?: ParseSourceSpan|null): ReadPropExpr {\n    return new ReadPropExpr(this, name, null, sourceSpan);\n  }\n\n  key(index: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null): ReadKeyExpr {\n    return new ReadKeyExpr(this, index, type, sourceSpan);\n  }\n\n  callMethod(name: string|BuiltinMethod, params: Expression[], sourceSpan?: ParseSourceSpan|null):\n      InvokeMethodExpr {\n    return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n  }\n\n  callFn(params: Expression[], sourceSpan?: ParseSourceSpan|null): InvokeFunctionExpr {\n    return new InvokeFunctionExpr(this, params, null, sourceSpan);\n  }\n\n  instantiate(params: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null):\n      InstantiateExpr {\n    return new InstantiateExpr(this, params, type, sourceSpan);\n  }\n\n  conditional(\n      trueCase: Expression, falseCase: Expression|null = null,\n      sourceSpan?: ParseSourceSpan|null): ConditionalExpr {\n    return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n  }\n\n  equals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n  }\n  notEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n  }\n  identical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n  }\n  notIdentical(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n  }\n  minus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n  }\n  plus(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n  }\n  divide(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n  }\n  multiply(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n  }\n  modulo(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n  }\n  and(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n  }\n  bitwiseAnd(rhs: Expression, sourceSpan?: ParseSourceSpan|null, parens: boolean = true):\n      BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n  }\n  or(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n  }\n  lower(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n  }\n  lowerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n  }\n  bigger(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n  }\n  biggerEquals(rhs: Expression, sourceSpan?: ParseSourceSpan|null): BinaryOperatorExpr {\n    return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n  }\n  isBlank(sourceSpan?: ParseSourceSpan|null): Expression {\n    // Note: We use equals by purpose here to compare to null and undefined in JS.\n    // We use the typed null to allow strictNullChecks to narrow types.\n    return this.equals(TYPED_NULL_EXPR, sourceSpan);\n  }\n  cast(type: Type, sourceSpan?: ParseSourceSpan|null): Expression {\n    return new CastExpr(this, type, sourceSpan);\n  }\n\n  toStmt(): Statement { return new ExpressionStatement(this, null); }\n}\n\nexport enum BuiltinVar {\n  This,\n  Super,\n  CatchError,\n  CatchStack\n}\n\nexport class ReadVarExpr extends Expression {\n  public name: string|null;\n  public builtin: BuiltinVar|null;\n\n  constructor(name: string|BuiltinVar, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    if (typeof name === 'string') {\n      this.name = name;\n      this.builtin = null;\n    } else {\n      this.name = null;\n      this.builtin = name;\n    }\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadVarExpr(this, context);\n  }\n\n  set(value: Expression): WriteVarExpr {\n    if (!this.name) {\n      throw new Error(`Built in variable ${this.builtin} can not be assigned to.`);\n    }\n    return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n  }\n}\n\nexport class TypeofExpr extends Expression {\n  constructor(public expr: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  visitExpression(visitor: ExpressionVisitor, context: any) {\n    return visitor.visitTypeofExpr(this, context);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n  }\n\n  isConstant(): boolean { return this.expr.isConstant(); }\n}\n\nexport class WrappedNodeExpr<T> extends Expression {\n  constructor(public node: T, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof WrappedNodeExpr && this.node === e.node;\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWrappedNodeExpr(this, context);\n  }\n}\n\nexport class WriteVarExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public name: string, value: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteVarExpr(this, context);\n  }\n\n  toDeclStmt(type?: Type|null, modifiers?: StmtModifier[]|null): DeclareVarStmt {\n    return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n  }\n\n  toConstDecl(): DeclareVarStmt { return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]); }\n}\n\n\nexport class WriteKeyExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public index: Expression, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWriteKeyExpr(this, context);\n  }\n}\n\n\nexport class WritePropExpr extends Expression {\n  public value: Expression;\n  constructor(\n      public receiver: Expression, public name: string, value: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type || value.type, sourceSpan);\n    this.value = value;\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name && this.value.isEquivalent(e.value);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitWritePropExpr(this, context);\n  }\n}\n\nexport enum BuiltinMethod {\n  ConcatArray,\n  SubscribeObservable,\n  Bind\n}\n\nexport class InvokeMethodExpr extends Expression {\n  public name: string|null;\n  public builtin: BuiltinMethod|null;\n  constructor(\n      public receiver: Expression, method: string|BuiltinMethod, public args: Expression[],\n      type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    if (typeof method === 'string') {\n      this.name = method;\n      this.builtin = null;\n    } else {\n      this.name = null;\n      this.builtin = <BuiltinMethod>method;\n    }\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeMethodExpr(this, context);\n  }\n}\n\n\nexport class InvokeFunctionExpr extends Expression {\n  constructor(\n      public fn: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public pure = false) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\n        areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInvokeFunctionExpr(this, context);\n  }\n}\n\n\nexport class InstantiateExpr extends Expression {\n  constructor(\n      public classExpr: Expression, public args: Expression[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\n        areAllEquivalent(this.args, e.args);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitInstantiateExpr(this, context);\n  }\n}\n\n\nexport class LiteralExpr extends Expression {\n  constructor(\n      public value: number|string|boolean|null|undefined, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralExpr && this.value === e.value;\n  }\n\n  isConstant() { return true; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralExpr(this, context);\n  }\n}\n\n\nexport class LocalizedString extends Expression {\n  constructor(\n      readonly metaBlock: I18nMeta, readonly messageParts: string[],\n      readonly placeHolderNames: string[], readonly expressions: Expression[],\n      sourceSpan?: ParseSourceSpan|null) {\n    super(STRING_TYPE, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    // return e instanceof LocalizedString && this.message === e.message;\n    return false;\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLocalizedString(this, context);\n  }\n\n  /**\n   * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n   * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n   * `parseI18nMeta()`.\n   *\n   * @param meta The metadata to serialize\n   * @param messagePart The first part of the tagged string\n   */\n  serializeI18nHead(): {cooked: string, raw: string} {\n    const MEANING_SEPARATOR = '|';\n    const ID_SEPARATOR = '@@';\n    const LEGACY_ID_INDICATOR = 'â';\n\n    let metaBlock = this.metaBlock.description || '';\n    if (this.metaBlock.meaning) {\n      metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;\n    }\n    if (this.metaBlock.customId) {\n      metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;\n    }\n    if (this.metaBlock.legacyIds) {\n      this.metaBlock.legacyIds.forEach(\n          legacyId => { metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`; });\n    }\n    return createCookedRawString(metaBlock, this.messageParts[0]);\n  }\n\n  /**\n   * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n   * can be used in a `$localize` tagged string.\n   *\n   * @param placeholderName The placeholder name to serialize\n   * @param messagePart The following message string after this placeholder\n   */\n  serializeI18nTemplatePart(partIndex: number): {cooked: string, raw: string} {\n    const placeholderName = this.placeHolderNames[partIndex - 1];\n    const messagePart = this.messageParts[partIndex];\n    return createCookedRawString(placeholderName, messagePart);\n  }\n}\n\nconst escapeSlashes = (str: string): string => str.replace(/\\\\/g, '\\\\\\\\');\nconst escapeStartingColon = (str: string): string => str.replace(/^:/, '\\\\:');\nconst escapeColons = (str: string): string => str.replace(/:/g, '\\\\:');\nconst escapeForMessagePart = (str: string): string =>\n    str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\nfunction createCookedRawString(metaBlock: string, messagePart: string) {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForMessagePart(escapeStartingColon(escapeSlashes(messagePart)))\n    };\n  } else {\n    return {\n      cooked: `:${metaBlock}:${messagePart}`,\n      raw: escapeForMessagePart(\n          `:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`)\n    };\n  }\n}\n\nexport class ExternalExpr extends Expression {\n  constructor(\n      public value: ExternalReference, type?: Type|null, public typeParams: Type[]|null = null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof ExternalExpr && this.value.name === e.value.name &&\n        this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitExternalExpr(this, context);\n  }\n}\n\nexport class ExternalReference {\n  constructor(public moduleName: string|null, public name: string|null, public runtime?: any|null) {\n  }\n  // Note: no isEquivalent method here as we use this as an interface too.\n}\n\nexport class ConditionalExpr extends Expression {\n  public trueCase: Expression;\n\n  constructor(\n      public condition: Expression, trueCase: Expression, public falseCase: Expression|null = null,\n      type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type || trueCase.type, sourceSpan);\n    this.trueCase = trueCase;\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\n        this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitConditionalExpr(this, context);\n  }\n}\n\n\nexport class NotExpr extends Expression {\n  constructor(public condition: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(BOOL_TYPE, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitNotExpr(this, context);\n  }\n}\n\nexport class AssertNotNull extends Expression {\n  constructor(public condition: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(condition.type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitAssertNotNullExpr(this, context);\n  }\n}\n\nexport class CastExpr extends Expression {\n  constructor(public value: Expression, type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof CastExpr && this.value.isEquivalent(e.value);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitCastExpr(this, context);\n  }\n}\n\n\nexport class FnParam {\n  constructor(public name: string, public type: Type|null = null) {}\n\n  isEquivalent(param: FnParam): boolean { return this.name === param.name; }\n}\n\n\nexport class FunctionExpr extends Expression {\n  constructor(\n      public params: FnParam[], public statements: Statement[], type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public name?: string|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\n        areAllEquivalent(this.statements, e.statements);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitFunctionExpr(this, context);\n  }\n\n  toDeclStmt(name: string, modifiers: StmtModifier[]|null = null): DeclareFunctionStmt {\n    return new DeclareFunctionStmt(\n        name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n  }\n}\n\n\nexport class BinaryOperatorExpr extends Expression {\n  public lhs: Expression;\n  constructor(\n      public operator: BinaryOperator, lhs: Expression, public rhs: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null, public parens: boolean = true) {\n    super(type || lhs.type, sourceSpan);\n    this.lhs = lhs;\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\n        this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitBinaryOperatorExpr(this, context);\n  }\n}\n\n\nexport class ReadPropExpr extends Expression {\n  constructor(\n      public receiver: Expression, public name: string, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.name === e.name;\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadPropExpr(this, context);\n  }\n\n  set(value: Expression): WritePropExpr {\n    return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n  }\n}\n\n\nexport class ReadKeyExpr extends Expression {\n  constructor(\n      public receiver: Expression, public index: Expression, type?: Type|null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\n        this.index.isEquivalent(e.index);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitReadKeyExpr(this, context);\n  }\n\n  set(value: Expression): WriteKeyExpr {\n    return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n  }\n}\n\n\nexport class LiteralArrayExpr extends Expression {\n  public entries: Expression[];\n  constructor(entries: Expression[], type?: Type|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    this.entries = entries;\n  }\n\n  isConstant() { return this.entries.every(e => e.isConstant()); }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n  }\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralArrayExpr(this, context);\n  }\n}\n\nexport class LiteralMapEntry {\n  constructor(public key: string, public value: Expression, public quoted: boolean) {}\n  isEquivalent(e: LiteralMapEntry): boolean {\n    return this.key === e.key && this.value.isEquivalent(e.value);\n  }\n}\n\nexport class LiteralMapExpr extends Expression {\n  public valueType: Type|null = null;\n  constructor(\n      public entries: LiteralMapEntry[], type?: MapType|null, sourceSpan?: ParseSourceSpan|null) {\n    super(type, sourceSpan);\n    if (type) {\n      this.valueType = type.valueType;\n    }\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n  }\n\n  isConstant() { return this.entries.every(e => e.value.isConstant()); }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitLiteralMapExpr(this, context);\n  }\n}\n\nexport class CommaExpr extends Expression {\n  constructor(public parts: Expression[], sourceSpan?: ParseSourceSpan|null) {\n    super(parts[parts.length - 1].type, sourceSpan);\n  }\n\n  isEquivalent(e: Expression): boolean {\n    return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n  }\n\n  isConstant() { return false; }\n\n  visitExpression(visitor: ExpressionVisitor, context: any): any {\n    return visitor.visitCommaExpr(this, context);\n  }\n}\n\nexport interface ExpressionVisitor {\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any;\n  visitWriteVarExpr(expr: WriteVarExpr, context: any): any;\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any;\n  visitWritePropExpr(expr: WritePropExpr, context: any): any;\n  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any;\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any;\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any;\n  visitLiteralExpr(ast: LiteralExpr, context: any): any;\n  visitLocalizedString(ast: LocalizedString, context: any): any;\n  visitExternalExpr(ast: ExternalExpr, context: any): any;\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any;\n  visitNotExpr(ast: NotExpr, context: any): any;\n  visitAssertNotNullExpr(ast: AssertNotNull, context: any): any;\n  visitCastExpr(ast: CastExpr, context: any): any;\n  visitFunctionExpr(ast: FunctionExpr, context: any): any;\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any;\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any;\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any;\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any;\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any;\n  visitCommaExpr(ast: CommaExpr, context: any): any;\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any;\n  visitTypeofExpr(ast: TypeofExpr, context: any): any;\n}\n\nexport const THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\nexport const SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\nexport const CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\nexport const CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\nexport const NULL_EXPR = new LiteralExpr(null, null, null);\nexport const TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\n\n//// Statements\nexport enum StmtModifier {\n  Final,\n  Private,\n  Exported,\n  Static,\n}\n\nexport abstract class Statement {\n  public modifiers: StmtModifier[];\n  public sourceSpan: ParseSourceSpan|null;\n  constructor(modifiers?: StmtModifier[]|null, sourceSpan?: ParseSourceSpan|null) {\n    this.modifiers = modifiers || [];\n    this.sourceSpan = sourceSpan || null;\n  }\n  /**\n   * Calculates whether this statement produces the same value as the given statement.\n   * Note: We don't check Types nor ParseSourceSpans nor function arguments.\n   */\n  abstract isEquivalent(stmt: Statement): boolean;\n\n  abstract visitStatement(visitor: StatementVisitor, context: any): any;\n\n  hasModifier(modifier: StmtModifier): boolean { return this.modifiers !.indexOf(modifier) !== -1; }\n}\n\n\nexport class DeclareVarStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public value?: Expression, type?: Type|null,\n      modifiers: StmtModifier[]|null = null, sourceSpan?: ParseSourceSpan|null) {\n    super(modifiers, sourceSpan);\n    this.type = type || (value && value.type) || null;\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\n        (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareVarStmt(this, context);\n  }\n}\n\nexport class DeclareFunctionStmt extends Statement {\n  public type: Type|null;\n  constructor(\n      public name: string, public params: FnParam[], public statements: Statement[],\n      type?: Type|null, modifiers: StmtModifier[]|null = null, sourceSpan?: ParseSourceSpan|null) {\n    super(modifiers, sourceSpan);\n    this.type = type || null;\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\n        areAllEquivalent(this.statements, stmt.statements);\n  }\n\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareFunctionStmt(this, context);\n  }\n}\n\nexport class ExpressionStatement extends Statement {\n  constructor(public expr: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(null, sourceSpan);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n  }\n\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitExpressionStmt(this, context);\n  }\n}\n\n\nexport class ReturnStatement extends Statement {\n  constructor(public value: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(null, sourceSpan);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitReturnStmt(this, context);\n  }\n}\n\nexport class AbstractClassPart {\n  public type: Type|null;\n  constructor(type: Type|null|undefined, public modifiers: StmtModifier[]|null) {\n    if (!modifiers) {\n      this.modifiers = [];\n    }\n    this.type = type || null;\n  }\n  hasModifier(modifier: StmtModifier): boolean { return this.modifiers !.indexOf(modifier) !== -1; }\n}\n\nexport class ClassField extends AbstractClassPart {\n  constructor(\n      public name: string, type?: Type|null, modifiers: StmtModifier[]|null = null,\n      public initializer?: Expression) {\n    super(type, modifiers);\n  }\n  isEquivalent(f: ClassField) { return this.name === f.name; }\n}\n\n\nexport class ClassMethod extends AbstractClassPart {\n  constructor(\n      public name: string|null, public params: FnParam[], public body: Statement[],\n      type?: Type|null, modifiers: StmtModifier[]|null = null) {\n    super(type, modifiers);\n  }\n  isEquivalent(m: ClassMethod) {\n    return this.name === m.name && areAllEquivalent(this.body, m.body);\n  }\n}\n\n\nexport class ClassGetter extends AbstractClassPart {\n  constructor(\n      public name: string, public body: Statement[], type?: Type|null,\n      modifiers: StmtModifier[]|null = null) {\n    super(type, modifiers);\n  }\n  isEquivalent(m: ClassGetter) {\n    return this.name === m.name && areAllEquivalent(this.body, m.body);\n  }\n}\n\n\nexport class ClassStmt extends Statement {\n  constructor(\n      public name: string, public parent: Expression|null, public fields: ClassField[],\n      public getters: ClassGetter[], public constructorMethod: ClassMethod,\n      public methods: ClassMethod[], modifiers: StmtModifier[]|null = null,\n      sourceSpan?: ParseSourceSpan|null) {\n    super(modifiers, sourceSpan);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof ClassStmt && this.name === stmt.name &&\n        nullSafeIsEquivalent(this.parent, stmt.parent) &&\n        areAllEquivalent(this.fields, stmt.fields) &&\n        areAllEquivalent(this.getters, stmt.getters) &&\n        this.constructorMethod.isEquivalent(stmt.constructorMethod) &&\n        areAllEquivalent(this.methods, stmt.methods);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitDeclareClassStmt(this, context);\n  }\n}\n\n\nexport class IfStmt extends Statement {\n  constructor(\n      public condition: Expression, public trueCase: Statement[],\n      public falseCase: Statement[] = [], sourceSpan?: ParseSourceSpan|null) {\n    super(null, sourceSpan);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\n        areAllEquivalent(this.trueCase, stmt.trueCase) &&\n        areAllEquivalent(this.falseCase, stmt.falseCase);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitIfStmt(this, context);\n  }\n}\n\nexport class CommentStmt extends Statement {\n  constructor(public comment: string, public multiline = false, sourceSpan?: ParseSourceSpan|null) {\n    super(null, sourceSpan);\n  }\n  isEquivalent(stmt: Statement): boolean { return stmt instanceof CommentStmt; }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitCommentStmt(this, context);\n  }\n}\n\nexport class JSDocCommentStmt extends Statement {\n  constructor(public tags: JSDocTag[] = [], sourceSpan?: ParseSourceSpan|null) {\n    super(null, sourceSpan);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof JSDocCommentStmt && this.toString() === stmt.toString();\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitJSDocCommentStmt(this, context);\n  }\n  toString(): string { return serializeTags(this.tags); }\n}\n\nexport class TryCatchStmt extends Statement {\n  constructor(\n      public bodyStmts: Statement[], public catchStmts: Statement[],\n      sourceSpan?: ParseSourceSpan|null) {\n    super(null, sourceSpan);\n  }\n  isEquivalent(stmt: Statement): boolean {\n    return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) &&\n        areAllEquivalent(this.catchStmts, stmt.catchStmts);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitTryCatchStmt(this, context);\n  }\n}\n\n\nexport class ThrowStmt extends Statement {\n  constructor(public error: Expression, sourceSpan?: ParseSourceSpan|null) {\n    super(null, sourceSpan);\n  }\n  isEquivalent(stmt: ThrowStmt): boolean {\n    return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);\n  }\n  visitStatement(visitor: StatementVisitor, context: any): any {\n    return visitor.visitThrowStmt(this, context);\n  }\n}\n\nexport interface StatementVisitor {\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any;\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any;\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any;\n  visitReturnStmt(stmt: ReturnStatement, context: any): any;\n  visitDeclareClassStmt(stmt: ClassStmt, context: any): any;\n  visitIfStmt(stmt: IfStmt, context: any): any;\n  visitTryCatchStmt(stmt: TryCatchStmt, context: any): any;\n  visitThrowStmt(stmt: ThrowStmt, context: any): any;\n  visitCommentStmt(stmt: CommentStmt, context: any): any;\n  visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: any): any;\n}\n\nexport class AstTransformer implements StatementVisitor, ExpressionVisitor {\n  transformExpr(expr: Expression, context: any): Expression { return expr; }\n\n  transformStmt(stmt: Statement, context: any): Statement { return stmt; }\n\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any { return this.transformExpr(ast, context); }\n\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any {\n    return this.transformExpr(ast, context);\n  }\n\n  visitTypeofExpr(expr: TypeofExpr, context: any): any {\n    return this.transformExpr(\n        new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan),\n        context);\n  }\n\n  visitWriteVarExpr(expr: WriteVarExpr, context: any): any {\n    return this.transformExpr(\n        new WriteVarExpr(\n            expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan),\n        context);\n  }\n\n  visitWriteKeyExpr(expr: WriteKeyExpr, context: any): any {\n    return this.transformExpr(\n        new WriteKeyExpr(\n            expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context),\n            expr.value.visitExpression(this, context), expr.type, expr.sourceSpan),\n        context);\n  }\n\n  visitWritePropExpr(expr: WritePropExpr, context: any): any {\n    return this.transformExpr(\n        new WritePropExpr(\n            expr.receiver.visitExpression(this, context), expr.name,\n            expr.value.visitExpression(this, context), expr.type, expr.sourceSpan),\n        context);\n  }\n\n  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any {\n    const method = ast.builtin || ast.name;\n    return this.transformExpr(\n        new InvokeMethodExpr(\n            ast.receiver.visitExpression(this, context), method !,\n            this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n    return this.transformExpr(\n        new InvokeFunctionExpr(\n            ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context),\n            ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n    return this.transformExpr(\n        new InstantiateExpr(\n            ast.classExpr.visitExpression(this, context),\n            this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitLiteralExpr(ast: LiteralExpr, context: any): any { return this.transformExpr(ast, context); }\n\n  visitLocalizedString(ast: LocalizedString, context: any): any {\n    return this.transformExpr(\n        new LocalizedString(\n            ast.metaBlock, ast.messageParts, ast.placeHolderNames,\n            this.visitAllExpressions(ast.expressions, context), ast.sourceSpan),\n        context);\n  }\n\n  visitExternalExpr(ast: ExternalExpr, context: any): any {\n    return this.transformExpr(ast, context);\n  }\n\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n    return this.transformExpr(\n        new ConditionalExpr(\n            ast.condition.visitExpression(this, context),\n            ast.trueCase.visitExpression(this, context),\n            ast.falseCase !.visitExpression(this, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitNotExpr(ast: NotExpr, context: any): any {\n    return this.transformExpr(\n        new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n  }\n\n  visitAssertNotNullExpr(ast: AssertNotNull, context: any): any {\n    return this.transformExpr(\n        new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n  }\n\n  visitCastExpr(ast: CastExpr, context: any): any {\n    return this.transformExpr(\n        new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n  }\n\n  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n    return this.transformExpr(\n        new FunctionExpr(\n            ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n    return this.transformExpr(\n        new BinaryOperatorExpr(\n            ast.operator, ast.lhs.visitExpression(this, context),\n            ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n    return this.transformExpr(\n        new ReadPropExpr(\n            ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n    return this.transformExpr(\n        new ReadKeyExpr(\n            ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context),\n            ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n    return this.transformExpr(\n        new LiteralArrayExpr(\n            this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan),\n        context);\n  }\n\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n    const entries = ast.entries.map(\n        (entry): LiteralMapEntry => new LiteralMapEntry(\n            entry.key, entry.value.visitExpression(this, context), entry.quoted));\n    const mapType = new MapType(ast.valueType, null);\n    return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n  }\n  visitCommaExpr(ast: CommaExpr, context: any): any {\n    return this.transformExpr(\n        new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n  }\n  visitAllExpressions(exprs: Expression[], context: any): Expression[] {\n    return exprs.map(expr => expr.visitExpression(this, context));\n  }\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n    const value = stmt.value && stmt.value.visitExpression(this, context);\n    return this.transformStmt(\n        new DeclareVarStmt(stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n  }\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    return this.transformStmt(\n        new DeclareFunctionStmt(\n            stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type,\n            stmt.modifiers, stmt.sourceSpan),\n        context);\n  }\n\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n    return this.transformStmt(\n        new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan),\n        context);\n  }\n\n  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n    return this.transformStmt(\n        new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);\n  }\n\n  visitDeclareClassStmt(stmt: ClassStmt, context: any): any {\n    const parent = stmt.parent !.visitExpression(this, context);\n    const getters = stmt.getters.map(\n        getter => new ClassGetter(\n            getter.name, this.visitAllStatements(getter.body, context), getter.type,\n            getter.modifiers));\n    const ctorMethod = stmt.constructorMethod &&\n        new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params,\n                        this.visitAllStatements(stmt.constructorMethod.body, context),\n                        stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n    const methods = stmt.methods.map(\n        method => new ClassMethod(\n            method.name, method.params, this.visitAllStatements(method.body, context), method.type,\n            method.modifiers));\n    return this.transformStmt(\n        new ClassStmt(\n            stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers,\n            stmt.sourceSpan),\n        context);\n  }\n\n  visitIfStmt(stmt: IfStmt, context: any): any {\n    return this.transformStmt(\n        new IfStmt(\n            stmt.condition.visitExpression(this, context),\n            this.visitAllStatements(stmt.trueCase, context),\n            this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan),\n        context);\n  }\n\n  visitTryCatchStmt(stmt: TryCatchStmt, context: any): any {\n    return this.transformStmt(\n        new TryCatchStmt(\n            this.visitAllStatements(stmt.bodyStmts, context),\n            this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan),\n        context);\n  }\n\n  visitThrowStmt(stmt: ThrowStmt, context: any): any {\n    return this.transformStmt(\n        new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);\n  }\n\n  visitCommentStmt(stmt: CommentStmt, context: any): any {\n    return this.transformStmt(stmt, context);\n  }\n\n  visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: any): any {\n    return this.transformStmt(stmt, context);\n  }\n\n  visitAllStatements(stmts: Statement[], context: any): Statement[] {\n    return stmts.map(stmt => stmt.visitStatement(this, context));\n  }\n}\n\n\nexport class RecursiveAstVisitor implements StatementVisitor, ExpressionVisitor {\n  visitType(ast: Type, context: any): any { return ast; }\n  visitExpression(ast: Expression, context: any): any {\n    if (ast.type) {\n      ast.type.visitType(this, context);\n    }\n    return ast;\n  }\n  visitBuiltinType(type: BuiltinType, context: any): any { return this.visitType(type, context); }\n  visitExpressionType(type: ExpressionType, context: any): any {\n    type.value.visitExpression(this, context);\n    if (type.typeParams !== null) {\n      type.typeParams.forEach(param => this.visitType(param, context));\n    }\n    return this.visitType(type, context);\n  }\n  visitArrayType(type: ArrayType, context: any): any { return this.visitType(type, context); }\n  visitMapType(type: MapType, context: any): any { return this.visitType(type, context); }\n  visitWrappedNodeExpr(ast: WrappedNodeExpr<any>, context: any): any { return ast; }\n  visitTypeofExpr(ast: TypeofExpr, context: any): any { return this.visitExpression(ast, context); }\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitWriteVarExpr(ast: WriteVarExpr, context: any): any {\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWriteKeyExpr(ast: WriteKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitWritePropExpr(ast: WritePropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeMethodExpr(ast: InvokeMethodExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInvokeFunctionExpr(ast: InvokeFunctionExpr, context: any): any {\n    ast.fn.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitInstantiateExpr(ast: InstantiateExpr, context: any): any {\n    ast.classExpr.visitExpression(this, context);\n    this.visitAllExpressions(ast.args, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralExpr(ast: LiteralExpr, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitLocalizedString(ast: LocalizedString, context: any): any {\n    return this.visitExpression(ast, context);\n  }\n  visitExternalExpr(ast: ExternalExpr, context: any): any {\n    if (ast.typeParams) {\n      ast.typeParams.forEach(type => type.visitType(this, context));\n    }\n    return this.visitExpression(ast, context);\n  }\n  visitConditionalExpr(ast: ConditionalExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    ast.trueCase.visitExpression(this, context);\n    ast.falseCase !.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitNotExpr(ast: NotExpr, context: any): any {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAssertNotNullExpr(ast: AssertNotNull, context: any): any {\n    ast.condition.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitCastExpr(ast: CastExpr, context: any): any {\n    ast.value.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitFunctionExpr(ast: FunctionExpr, context: any): any {\n    this.visitAllStatements(ast.statements, context);\n    return this.visitExpression(ast, context);\n  }\n  visitBinaryOperatorExpr(ast: BinaryOperatorExpr, context: any): any {\n    ast.lhs.visitExpression(this, context);\n    ast.rhs.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadPropExpr(ast: ReadPropExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitReadKeyExpr(ast: ReadKeyExpr, context: any): any {\n    ast.receiver.visitExpression(this, context);\n    ast.index.visitExpression(this, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralArrayExpr(ast: LiteralArrayExpr, context: any): any {\n    this.visitAllExpressions(ast.entries, context);\n    return this.visitExpression(ast, context);\n  }\n  visitLiteralMapExpr(ast: LiteralMapExpr, context: any): any {\n    ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\n    return this.visitExpression(ast, context);\n  }\n  visitCommaExpr(ast: CommaExpr, context: any): any {\n    this.visitAllExpressions(ast.parts, context);\n    return this.visitExpression(ast, context);\n  }\n  visitAllExpressions(exprs: Expression[], context: any): void {\n    exprs.forEach(expr => expr.visitExpression(this, context));\n  }\n\n  visitDeclareVarStmt(stmt: DeclareVarStmt, context: any): any {\n    if (stmt.value) {\n      stmt.value.visitExpression(this, context);\n    }\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    this.visitAllStatements(stmt.statements, context);\n    if (stmt.type) {\n      stmt.type.visitType(this, context);\n    }\n    return stmt;\n  }\n  visitExpressionStmt(stmt: ExpressionStatement, context: any): any {\n    stmt.expr.visitExpression(this, context);\n    return stmt;\n  }\n  visitReturnStmt(stmt: ReturnStatement, context: any): any {\n    stmt.value.visitExpression(this, context);\n    return stmt;\n  }\n  visitDeclareClassStmt(stmt: ClassStmt, context: any): any {\n    stmt.parent !.visitExpression(this, context);\n    stmt.getters.forEach(getter => this.visitAllStatements(getter.body, context));\n    if (stmt.constructorMethod) {\n      this.visitAllStatements(stmt.constructorMethod.body, context);\n    }\n    stmt.methods.forEach(method => this.visitAllStatements(method.body, context));\n    return stmt;\n  }\n  visitIfStmt(stmt: IfStmt, context: any): any {\n    stmt.condition.visitExpression(this, context);\n    this.visitAllStatements(stmt.trueCase, context);\n    this.visitAllStatements(stmt.falseCase, context);\n    return stmt;\n  }\n  visitTryCatchStmt(stmt: TryCatchStmt, context: any): any {\n    this.visitAllStatements(stmt.bodyStmts, context);\n    this.visitAllStatements(stmt.catchStmts, context);\n    return stmt;\n  }\n  visitThrowStmt(stmt: ThrowStmt, context: any): any {\n    stmt.error.visitExpression(this, context);\n    return stmt;\n  }\n  visitCommentStmt(stmt: CommentStmt, context: any): any { return stmt; }\n  visitJSDocCommentStmt(stmt: JSDocCommentStmt, context: any): any { return stmt; }\n  visitAllStatements(stmts: Statement[], context: any): void {\n    stmts.forEach(stmt => stmt.visitStatement(this, context));\n  }\n}\n\nexport function findReadVarNames(stmts: Statement[]): Set<string> {\n  const visitor = new _ReadVarVisitor();\n  visitor.visitAllStatements(stmts, null);\n  return visitor.varNames;\n}\n\nclass _ReadVarVisitor extends RecursiveAstVisitor {\n  varNames = new Set<string>();\n  visitDeclareFunctionStmt(stmt: DeclareFunctionStmt, context: any): any {\n    // Don't descend into nested functions\n    return stmt;\n  }\n  visitDeclareClassStmt(stmt: ClassStmt, context: any): any {\n    // Don't descend into nested classes\n    return stmt;\n  }\n  visitReadVarExpr(ast: ReadVarExpr, context: any): any {\n    if (ast.name) {\n      this.varNames.add(ast.name);\n    }\n    return null;\n  }\n}\n\nexport function collectExternalReferences(stmts: Statement[]): ExternalReference[] {\n  const visitor = new _FindExternalReferencesVisitor();\n  visitor.visitAllStatements(stmts, null);\n  return visitor.externalReferences;\n}\n\nclass _FindExternalReferencesVisitor extends RecursiveAstVisitor {\n  externalReferences: ExternalReference[] = [];\n  visitExternalExpr(e: ExternalExpr, context: any) {\n    this.externalReferences.push(e.value);\n    return super.visitExternalExpr(e, context);\n  }\n}\n\nexport function applySourceSpanToStatementIfNeeded(\n    stmt: Statement, sourceSpan: ParseSourceSpan | null): Statement {\n  if (!sourceSpan) {\n    return stmt;\n  }\n  const transformer = new _ApplySourceSpanTransformer(sourceSpan);\n  return stmt.visitStatement(transformer, null);\n}\n\nexport function applySourceSpanToExpressionIfNeeded(\n    expr: Expression, sourceSpan: ParseSourceSpan | null): Expression {\n  if (!sourceSpan) {\n    return expr;\n  }\n  const transformer = new _ApplySourceSpanTransformer(sourceSpan);\n  return expr.visitExpression(transformer, null);\n}\n\nclass _ApplySourceSpanTransformer extends AstTransformer {\n  constructor(private sourceSpan: ParseSourceSpan) { super(); }\n  private _clone(obj: any): any {\n    const clone = Object.create(obj.constructor.prototype);\n    for (let prop of Object.keys(obj)) {\n      clone[prop] = obj[prop];\n    }\n    return clone;\n  }\n\n  transformExpr(expr: Expression, context: any): Expression {\n    if (!expr.sourceSpan) {\n      expr = this._clone(expr);\n      expr.sourceSpan = this.sourceSpan;\n    }\n    return expr;\n  }\n\n  transformStmt(stmt: Statement, context: any): Statement {\n    if (!stmt.sourceSpan) {\n      stmt = this._clone(stmt);\n      stmt.sourceSpan = this.sourceSpan;\n    }\n    return stmt;\n  }\n}\n\nexport function variable(\n    name: string, type?: Type | null, sourceSpan?: ParseSourceSpan | null): ReadVarExpr {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\n\nexport function importExpr(\n    id: ExternalReference, typeParams: Type[] | null = null,\n    sourceSpan?: ParseSourceSpan | null): ExternalExpr {\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n\nexport function importType(\n    id: ExternalReference, typeParams: Type[] | null = null,\n    typeModifiers: TypeModifier[] | null = null): ExpressionType|null {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n\nexport function expressionType(\n    expr: Expression, typeModifiers: TypeModifier[] | null = null,\n    typeParams: Type[] | null = null): ExpressionType {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\n\nexport function typeofExpr(expr: Expression) {\n  return new TypeofExpr(expr);\n}\n\nexport function literalArr(\n    values: Expression[], type?: Type | null,\n    sourceSpan?: ParseSourceSpan | null): LiteralArrayExpr {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\n\nexport function literalMap(\n    values: {key: string, quoted: boolean, value: Expression}[],\n    type: MapType | null = null): LiteralMapExpr {\n  return new LiteralMapExpr(\n      values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\n}\n\nexport function not(expr: Expression, sourceSpan?: ParseSourceSpan | null): NotExpr {\n  return new NotExpr(expr, sourceSpan);\n}\n\nexport function assertNotNull(\n    expr: Expression, sourceSpan?: ParseSourceSpan | null): AssertNotNull {\n  return new AssertNotNull(expr, sourceSpan);\n}\n\nexport function fn(\n    params: FnParam[], body: Statement[], type?: Type | null, sourceSpan?: ParseSourceSpan | null,\n    name?: string | null): FunctionExpr {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\n\nexport function ifStmt(condition: Expression, thenClause: Statement[], elseClause?: Statement[]) {\n  return new IfStmt(condition, thenClause, elseClause);\n}\n\nexport function literal(\n    value: any, type?: Type | null, sourceSpan?: ParseSourceSpan | null): LiteralExpr {\n  return new LiteralExpr(value, type, sourceSpan);\n}\n\nexport function localizedString(\n    metaBlock: I18nMeta, messageParts: string[], placeholderNames: string[],\n    expressions: Expression[], sourceSpan?: ParseSourceSpan | null): LocalizedString {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\n\nexport function isNull(exp: Expression): boolean {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\n\n// The list of JSDoc tags that we currently support. Extend it if needed.\nexport const enum JSDocTagName {\n  Desc = 'desc',\n  Id = 'id',\n  Meaning = 'meaning',\n}\n\n/*\n * TypeScript has an API for JSDoc already, but it's not exposed.\n * https://github.com/Microsoft/TypeScript/issues/7393\n * For now we create types that are similar to theirs so that migrating\n * to their API will be easier. See e.g. `ts.JSDocTag` and `ts.JSDocComment`.\n */\nexport type JSDocTag = {\n  // `tagName` is e.g. \"param\" in an `@param` declaration\n  tagName: JSDocTagName | string,\n  // Any remaining text on the tag, e.g. the description\n  text?: string,\n} | {\n  // no `tagName` for plain text documentation that occurs before any `@param` lines\n  tagName?: undefined,\n  text: string,\n};\n\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\nfunction tagToString(tag: JSDocTag): string {\n  let out = '';\n  if (tag.tagName) {\n    out += ` @${tag.tagName}`;\n  }\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n  return out;\n}\n\nfunction serializeTags(tags: JSDocTag[]): string {\n  if (tags.length === 0) return '';\n\n  let out = '*\\n';\n  for (const tag of tags) {\n    out += ' *';\n    // If the tagToString is multi-line, insert \" * \" prefixes on subsequent lines.\n    out += tagToString(tag).replace(/\\n/g, '\\n * ');\n    out += '\\n';\n  }\n  out += ' ';\n  return out;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from './constant_pool';\n\nimport * as o from './output/output_ast';\nimport {ParseError} from './parse_util';\n\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n\nexport function splitAtColon(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, ':', defaultValues);\n}\n\nexport function splitAtPeriod(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, '.', defaultValues);\n}\n\nfunction _splitAt(input: string, character: string, defaultValues: string[]): string[] {\n  const characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n\nexport function visitValue(value: any, visitor: ValueVisitor, context: any): any {\n  if (Array.isArray(value)) {\n    return visitor.visitArray(<any[]>value, context);\n  }\n\n  if (isStrictStringMap(value)) {\n    return visitor.visitStringMap(<{[key: string]: any}>value, context);\n  }\n\n  if (value == null || typeof value == 'string' || typeof value == 'number' ||\n      typeof value == 'boolean') {\n    return visitor.visitPrimitive(value, context);\n  }\n\n  return visitor.visitOther(value, context);\n}\n\nexport function isDefined(val: any): boolean {\n  return val !== null && val !== undefined;\n}\n\nexport function noUndefined<T>(val: T | undefined): T {\n  return val === undefined ? null ! : val;\n}\n\nexport interface ValueVisitor {\n  visitArray(arr: any[], context: any): any;\n  visitStringMap(map: {[key: string]: any}, context: any): any;\n  visitPrimitive(value: any, context: any): any;\n  visitOther(value: any, context: any): any;\n}\n\nexport class ValueTransformer implements ValueVisitor {\n  visitArray(arr: any[], context: any): any {\n    return arr.map(value => visitValue(value, this, context));\n  }\n  visitStringMap(map: {[key: string]: any}, context: any): any {\n    const result: {[key: string]: any} = {};\n    Object.keys(map).forEach(key => { result[key] = visitValue(map[key], this, context); });\n    return result;\n  }\n  visitPrimitive(value: any, context: any): any { return value; }\n  visitOther(value: any, context: any): any { return value; }\n}\n\nexport type SyncAsync<T> = T | Promise<T>;\n\nexport const SyncAsync = {\n  assertSync: <T>(value: SyncAsync<T>): T => {\n    if (isPromise(value)) {\n      throw new Error(`Illegal state: value cannot be a promise`);\n    }\n    return value;\n  },\n  then: <T, R>(value: SyncAsync<T>, cb: (value: T) => R | Promise<R>| SyncAsync<R>):\n            SyncAsync<R> => { return isPromise(value) ? value.then(cb) : cb(value);},\n  all: <T>(syncAsyncValues: SyncAsync<T>[]): SyncAsync<T[]> => {\n    return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues as T[];\n  }\n};\n\nexport function error(msg: string): never {\n  throw new Error(`Internal Error: ${msg}`);\n}\n\nexport function syntaxError(msg: string, parseErrors?: ParseError[]): Error {\n  const error = Error(msg);\n  (error as any)[ERROR_SYNTAX_ERROR] = true;\n  if (parseErrors) (error as any)[ERROR_PARSE_ERRORS] = parseErrors;\n  return error;\n}\n\nconst ERROR_SYNTAX_ERROR = 'ngSyntaxError';\nconst ERROR_PARSE_ERRORS = 'ngParseErrors';\n\nexport function isSyntaxError(error: Error): boolean {\n  return (error as any)[ERROR_SYNTAX_ERROR];\n}\n\nexport function getParseErrors(error: Error): ParseError[] {\n  return (error as any)[ERROR_PARSE_ERRORS] || [];\n}\n\n// Escape characters that have a special meaning in Regular Expressions\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nconst STRING_MAP_PROTO = Object.getPrototypeOf({});\nfunction isStrictStringMap(obj: any): boolean {\n  return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n\nexport function utf8Encode(str: string): string {\n  let encoded = '';\n  for (let index = 0; index < str.length; index++) {\n    let codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n      const low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded += String.fromCharCode(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded += String.fromCharCode(\n          (codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded += String.fromCharCode(\n          ((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80,\n          ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    }\n  }\n\n  return encoded;\n}\n\nexport interface OutputContext {\n  genFilePath: string;\n  statements: o.Statement[];\n  constantPool: ConstantPool;\n  importExpr(reference: any, typeParams?: o.Type[]|null, useSummaries?: boolean): o.Expression;\n}\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  if (!token.toString) {\n    return 'object';\n  }\n\n  // WARNING: do not try to `JSON.stringify(token)` here\n  // see https://github.com/angular/angular/issues/23440\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\n/**\n * Lazily retrieves the reference value from a forwardRef.\n */\nexport function resolveForwardRef(type: any): any {\n  if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {\n    return type();\n  } else {\n    return type;\n  }\n}\n\n/**\n * Determine if the argument is shaped like a Promise\n */\nexport function isPromise(obj: any): obj is Promise<any> {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n\nexport class Version {\n  public readonly major: string;\n  public readonly minor: string;\n  public readonly patch: string;\n\n  constructor(public full: string) {\n    const splits = full.split('.');\n    this.major = splits[0];\n    this.minor = splits[1];\n    this.patch = splits.slice(2).join('.');\n  }\n}\n\nexport interface Console {\n  log(message: string): void;\n  warn(message: string): void;\n}\n\n\ndeclare var WorkerGlobalScope: any;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n\n// Check __global first, because in Node tests both __global and __window may be defined and _global\n// should be __global in that case.\nconst _global: {[name: string]: any} = __global || __window || __self;\nexport {_global as global};\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value !);\n  }\n  return list;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output/output_ast';\nimport {OutputContext, error} from './util';\n\nconst CONSTANT_PREFIX = '_c';\n\nexport const enum DefinitionKind {Injector, Directive, Component, Pipe}\n\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\nconst KEY_CONTEXT = {};\n\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\nclass FixupExpression extends o.Expression {\n  private original: o.Expression;\n\n  // TODO(issue/24571): remove '!'.\n  shared !: boolean;\n\n  constructor(public resolved: o.Expression) {\n    super(resolved.type);\n    this.original = resolved;\n  }\n\n  visitExpression(visitor: o.ExpressionVisitor, context: any): any {\n    if (context === KEY_CONTEXT) {\n      // When producing a key we want to traverse the constant not the\n      // variable used to refer to it.\n      return this.original.visitExpression(visitor, context);\n    } else {\n      return this.resolved.visitExpression(visitor, context);\n    }\n  }\n\n  isEquivalent(e: o.Expression): boolean {\n    return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n  }\n\n  isConstant() { return true; }\n\n  fixup(expression: o.Expression) {\n    this.resolved = expression;\n    this.shared = true;\n  }\n}\n\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\nexport class ConstantPool {\n  statements: o.Statement[] = [];\n  private literals = new Map<string, FixupExpression>();\n  private literalFactories = new Map<string, o.Expression>();\n  private injectorDefinitions = new Map<any, FixupExpression>();\n  private directiveDefinitions = new Map<any, FixupExpression>();\n  private componentDefinitions = new Map<any, FixupExpression>();\n  private pipeDefinitions = new Map<any, FixupExpression>();\n\n  private nextNameIndex = 0;\n\n  getConstLiteral(literal: o.Expression, forceShared?: boolean): o.Expression {\n    if (literal instanceof o.LiteralExpr || literal instanceof FixupExpression) {\n      // Do no put simple literals into the constant pool or try to produce a constant for a\n      // reference to a constant.\n      return literal;\n    }\n    const key = this.keyOf(literal);\n    let fixup = this.literals.get(key);\n    let newValue = false;\n    if (!fixup) {\n      fixup = new FixupExpression(literal);\n      this.literals.set(key, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      // Replace the expression with a variable\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(literal).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n\n    return fixup;\n  }\n\n  getDefinition(type: any, kind: DefinitionKind, ctx: OutputContext, forceShared: boolean = false):\n      o.Expression {\n    const definitions = this.definitionsOf(kind);\n    let fixup = definitions.get(type);\n    let newValue = false;\n    if (!fixup) {\n      const property = this.propertyNameOf(kind);\n      fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n      definitions.set(type, fixup);\n      newValue = true;\n    }\n\n    if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(fixup.resolved).toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Final]));\n      fixup.fixup(o.variable(name));\n    }\n    return fixup;\n  }\n\n  getLiteralFactory(literal: o.LiteralArrayExpr|o.LiteralMapExpr):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    // Create a pure function that builds an array of a mix of constant  and variable expressions\n    if (literal instanceof o.LiteralArrayExpr) {\n      const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : o.literal(null));\n      const key = this.keyOf(o.literalArr(argumentsForKey));\n      return this._getLiteralFactory(key, literal.entries, entries => o.literalArr(entries));\n    } else {\n      const expressionForKey = o.literalMap(\n          literal.entries.map(e => ({\n                                key: e.key,\n                                value: e.value.isConstant() ? e.value : o.literal(null),\n                                quoted: e.quoted\n                              })));\n      const key = this.keyOf(expressionForKey);\n      return this._getLiteralFactory(\n          key, literal.entries.map(e => e.value),\n          entries => o.literalMap(entries.map((value, index) => ({\n                                                key: literal.entries[index].key,\n                                                value,\n                                                quoted: literal.entries[index].quoted\n                                              }))));\n    }\n  }\n\n  private _getLiteralFactory(\n      key: string, values: o.Expression[], resultMap: (parameters: o.Expression[]) => o.Expression):\n      {literalFactory: o.Expression, literalFactoryArguments: o.Expression[]} {\n    let literalFactory = this.literalFactories.get(key);\n    const literalFactoryArguments = values.filter((e => !e.isConstant()));\n    if (!literalFactory) {\n      const resultExpressions = values.map(\n          (e, index) => e.isConstant() ? this.getConstLiteral(e, true) : o.variable(`a${index}`));\n      const parameters =\n          resultExpressions.filter(isVariable).map(e => new o.FnParam(e.name !, o.DYNAMIC_TYPE));\n      const pureFunctionDeclaration =\n          o.fn(parameters, [new o.ReturnStatement(resultMap(resultExpressions))], o.INFERRED_TYPE);\n      const name = this.freshName();\n      this.statements.push(\n          o.variable(name).set(pureFunctionDeclaration).toDeclStmt(o.INFERRED_TYPE, [\n            o.StmtModifier.Final\n          ]));\n      literalFactory = o.variable(name);\n      this.literalFactories.set(key, literalFactory);\n    }\n    return {literalFactory, literalFactoryArguments};\n  }\n\n  /**\n   * Produce a unique name.\n   *\n   * The name might be unique among different prefixes if any of the prefixes end in\n   * a digit so the prefix should be a constant string (not based on user input) and\n   * must not end in a digit.\n   */\n  uniqueName(prefix: string): string { return `${prefix}${this.nextNameIndex++}`; }\n\n  private definitionsOf(kind: DefinitionKind): Map<any, FixupExpression> {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return this.componentDefinitions;\n      case DefinitionKind.Directive:\n        return this.directiveDefinitions;\n      case DefinitionKind.Injector:\n        return this.injectorDefinitions;\n      case DefinitionKind.Pipe:\n        return this.pipeDefinitions;\n    }\n    error(`Unknown definition kind ${kind}`);\n    return this.componentDefinitions;\n  }\n\n  public propertyNameOf(kind: DefinitionKind): string {\n    switch (kind) {\n      case DefinitionKind.Component:\n        return 'Éµcmp';\n      case DefinitionKind.Directive:\n        return 'Éµdir';\n      case DefinitionKind.Injector:\n        return 'Éµinj';\n      case DefinitionKind.Pipe:\n        return 'Éµpipe';\n    }\n    error(`Unknown definition kind ${kind}`);\n    return '<unknown>';\n  }\n\n  private freshName(): string { return this.uniqueName(CONSTANT_PREFIX); }\n\n  private keyOf(expression: o.Expression) {\n    return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n  }\n}\n\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\nclass KeyVisitor implements o.ExpressionVisitor {\n  visitLiteralExpr(ast: o.LiteralExpr): string {\n    return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\n  }\n\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, context: object): string {\n    return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\n  }\n\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, context: object): string {\n    const mapKey = (entry: o.LiteralMapEntry) => {\n      const quote = entry.quoted ? '\"' : '';\n      return `${quote}${entry.key}${quote}`;\n    };\n    const mapEntry = (entry: o.LiteralMapEntry) =>\n        `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\n    return `{${ast.entries.map(mapEntry).join(',')}`;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr): string {\n    return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\n                                  `EX:${ast.value.runtime.name}`;\n  }\n\n  visitReadVarExpr(node: o.ReadVarExpr) { return `VAR:${node.name}`; }\n\n  visitTypeofExpr(node: o.TypeofExpr, context: any): string {\n    return `TYPEOF:${node.expr.visitExpression(this, context)}`;\n  }\n\n  visitWrappedNodeExpr = invalid;\n  visitWriteVarExpr = invalid;\n  visitWriteKeyExpr = invalid;\n  visitWritePropExpr = invalid;\n  visitInvokeMethodExpr = invalid;\n  visitInvokeFunctionExpr = invalid;\n  visitInstantiateExpr = invalid;\n  visitConditionalExpr = invalid;\n  visitNotExpr = invalid;\n  visitAssertNotNullExpr = invalid;\n  visitCastExpr = invalid;\n  visitFunctionExpr = invalid;\n  visitBinaryOperatorExpr = invalid;\n  visitReadPropExpr = invalid;\n  visitReadKeyExpr = invalid;\n  visitCommaExpr = invalid;\n  visitLocalizedString = invalid;\n}\n\nfunction invalid<T>(this: o.ExpressionVisitor, arg: o.Expression | o.Statement): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nfunction isVariable(e: o.Expression): e is o.ReadVarExpr {\n  return e instanceof o.ReadVarExpr;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileTokenMetadata} from './compile_metadata';\nimport {CompileReflector} from './compile_reflector';\nimport * as o from './output/output_ast';\n\nconst CORE = '@angular/core';\n\nexport class Identifiers {\n  static ANALYZE_FOR_ENTRY_COMPONENTS: o.ExternalReference = {\n    name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n    moduleName: CORE,\n\n  };\n  static ElementRef: o.ExternalReference = {name: 'ElementRef', moduleName: CORE};\n  static NgModuleRef: o.ExternalReference = {name: 'NgModuleRef', moduleName: CORE};\n  static ViewContainerRef: o.ExternalReference = {name: 'ViewContainerRef', moduleName: CORE};\n  static ChangeDetectorRef: o.ExternalReference = {\n    name: 'ChangeDetectorRef',\n    moduleName: CORE,\n\n  };\n  static QueryList: o.ExternalReference = {name: 'QueryList', moduleName: CORE};\n  static TemplateRef: o.ExternalReference = {name: 'TemplateRef', moduleName: CORE};\n  static Renderer2: o.ExternalReference = {name: 'Renderer2', moduleName: CORE};\n  static CodegenComponentFactoryResolver: o.ExternalReference = {\n    name: 'ÉµCodegenComponentFactoryResolver',\n    moduleName: CORE,\n\n  };\n  static ComponentFactoryResolver: o.ExternalReference = {\n    name: 'ComponentFactoryResolver',\n    moduleName: CORE,\n\n  };\n  static ComponentFactory: o.ExternalReference = {name: 'ComponentFactory', moduleName: CORE};\n  static ComponentRef: o.ExternalReference = {name: 'ComponentRef', moduleName: CORE};\n  static NgModuleFactory: o.ExternalReference = {name: 'NgModuleFactory', moduleName: CORE};\n  static createModuleFactory: o.ExternalReference = {\n    name: 'Éµcmf',\n    moduleName: CORE,\n\n  };\n  static moduleDef: o.ExternalReference = {\n    name: 'Éµmod',\n    moduleName: CORE,\n\n  };\n  static moduleProviderDef: o.ExternalReference = {\n    name: 'Éµmpd',\n    moduleName: CORE,\n\n  };\n  static RegisterModuleFactoryFn: o.ExternalReference = {\n    name: 'ÉµregisterModuleFactory',\n    moduleName: CORE,\n\n  };\n  static inject: o.ExternalReference = {name: 'ÉµÉµinject', moduleName: CORE};\n  static directiveInject: o.ExternalReference = {name: 'ÉµÉµdirectiveInject', moduleName: CORE};\n  static INJECTOR: o.ExternalReference = {name: 'INJECTOR', moduleName: CORE};\n  static Injector: o.ExternalReference = {name: 'Injector', moduleName: CORE};\n  static ÉµÉµdefineInjectable: o.ExternalReference = {name: 'ÉµÉµdefineInjectable', moduleName: CORE};\n  static InjectableDef: o.ExternalReference = {name: 'ÉµÉµInjectableDef', moduleName: CORE};\n  static ViewEncapsulation: o.ExternalReference = {\n    name: 'ViewEncapsulation',\n    moduleName: CORE,\n\n  };\n  static ChangeDetectionStrategy: o.ExternalReference = {\n    name: 'ChangeDetectionStrategy',\n    moduleName: CORE,\n\n  };\n  static SecurityContext: o.ExternalReference = {\n    name: 'SecurityContext',\n    moduleName: CORE,\n\n  };\n  static LOCALE_ID: o.ExternalReference = {name: 'LOCALE_ID', moduleName: CORE};\n  static TRANSLATIONS_FORMAT: o.ExternalReference = {\n    name: 'TRANSLATIONS_FORMAT',\n    moduleName: CORE,\n\n  };\n  static inlineInterpolate: o.ExternalReference = {\n    name: 'ÉµinlineInterpolate',\n    moduleName: CORE,\n  };\n  static interpolate: o.ExternalReference = {name: 'Éµinterpolate', moduleName: CORE};\n  static EMPTY_ARRAY: o.ExternalReference = {name: 'ÉµEMPTY_ARRAY', moduleName: CORE};\n  static EMPTY_MAP: o.ExternalReference = {name: 'ÉµEMPTY_MAP', moduleName: CORE};\n  static Renderer: o.ExternalReference = {name: 'Renderer', moduleName: CORE};\n  static viewDef: o.ExternalReference = {name: 'Éµvid', moduleName: CORE};\n  static elementDef: o.ExternalReference = {name: 'Éµeld', moduleName: CORE};\n  static anchorDef: o.ExternalReference = {name: 'Éµand', moduleName: CORE};\n  static textDef: o.ExternalReference = {name: 'Éµted', moduleName: CORE};\n  static directiveDef: o.ExternalReference = {name: 'Éµdid', moduleName: CORE};\n  static providerDef: o.ExternalReference = {name: 'Éµprd', moduleName: CORE};\n  static queryDef: o.ExternalReference = {name: 'Éµqud', moduleName: CORE};\n  static pureArrayDef: o.ExternalReference = {name: 'Éµpad', moduleName: CORE};\n  static pureObjectDef: o.ExternalReference = {name: 'Éµpod', moduleName: CORE};\n  static purePipeDef: o.ExternalReference = {name: 'Éµppd', moduleName: CORE};\n  static pipeDef: o.ExternalReference = {name: 'Éµpid', moduleName: CORE};\n  static nodeValue: o.ExternalReference = {name: 'Éµnov', moduleName: CORE};\n  static ngContentDef: o.ExternalReference = {name: 'Éµncd', moduleName: CORE};\n  static unwrapValue: o.ExternalReference = {name: 'Éµunv', moduleName: CORE};\n  static createRendererType2: o.ExternalReference = {name: 'Éµcrt', moduleName: CORE};\n  // type only\n  static RendererType2: o.ExternalReference = {\n    name: 'RendererType2',\n    moduleName: CORE,\n\n  };\n  // type only\n  static ViewDefinition: o.ExternalReference = {\n    name: 'ÉµViewDefinition',\n    moduleName: CORE,\n  };\n  static createComponentFactory: o.ExternalReference = {name: 'Éµccf', moduleName: CORE};\n  static setClassMetadata: o.ExternalReference = {name: 'ÉµsetClassMetadata', moduleName: CORE};\n}\n\nexport function createTokenForReference(reference: any): CompileTokenMetadata {\n  return {identifier: {reference: reference}};\n}\n\nexport function createTokenForExternalReference(\n    reflector: CompileReflector, reference: o.ExternalReference): CompileTokenMetadata {\n  return createTokenForReference(reflector.resolveExternalReference(reference));\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A token representing the a reference to a static type.\n *\n * This token is unique for a filePath and name and can be used as a hash table key.\n */\nexport class StaticSymbol {\n  constructor(public filePath: string, public name: string, public members: string[]) {}\n\n  assertNoMembers() {\n    if (this.members.length) {\n      throw new Error(\n          `Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);\n    }\n  }\n}\n\n/**\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\n * same symbol values.\n */\nexport class StaticSymbolCache {\n  private cache = new Map<string, StaticSymbol>();\n\n  get(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    members = members || [];\n    const memberSuffix = members.length ? `.${ members.join('.')}` : '';\n    const key = `\"${declarationFile}\".${name}${memberSuffix}`;\n    let result = this.cache.get(key);\n    if (!result) {\n      result = new StaticSymbol(declarationFile, name, members);\n      this.cache.set(key, result);\n    }\n    return result;\n  }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from './aot/static_symbol';\nimport {ChangeDetectionStrategy, SchemaMetadata, Type, ViewEncapsulation} from './core';\nimport {LifecycleHooks} from './lifecycle_reflector';\nimport {ParseTreeResult as HtmlParseTreeResult} from './ml_parser/parser';\nimport {splitAtColon, stringify} from './util';\n\n// group 0: \"[prop] or (event) or @trigger\"\n// group 1: \"prop\" from \"[prop]\"\n// group 2: \"event\" from \"(event)\"\n// group 3: \"@trigger\" from \"@trigger\"\nconst HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\n\nexport function sanitizeIdentifier(name: string): string {\n  return name.replace(/\\W/g, '_');\n}\n\nlet _anonymousTypeIndex = 0;\n\nexport function identifierName(compileIdentifier: CompileIdentifierMetadata | null | undefined):\n    string|null {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n  const ref = compileIdentifier.reference;\n  if (ref instanceof StaticSymbol) {\n    return ref.name;\n  }\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n  let identifier = stringify(ref);\n  if (identifier.indexOf('(') >= 0) {\n    // case: anonymous functions!\n    identifier = `anonymous_${_anonymousTypeIndex++}`;\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n  return identifier;\n}\n\nexport function identifierModuleUrl(compileIdentifier: CompileIdentifierMetadata): string {\n  const ref = compileIdentifier.reference;\n  if (ref instanceof StaticSymbol) {\n    return ref.filePath;\n  }\n  // Runtime type\n  return `./${stringify(ref)}`;\n}\n\nexport function viewClassName(compType: any, embeddedTemplateIndex: number): string {\n  return `View_${identifierName({reference: compType})}_${embeddedTemplateIndex}`;\n}\n\nexport function rendererTypeName(compType: any): string {\n  return `RenderType_${identifierName({reference: compType})}`;\n}\n\nexport function hostViewClassName(compType: any): string {\n  return `HostView_${identifierName({reference: compType})}`;\n}\n\nexport function componentFactoryName(compType: any): string {\n  return `${identifierName({reference: compType})}NgFactory`;\n}\n\nexport interface ProxyClass { setDelegate(delegate: any): void; }\n\nexport interface CompileIdentifierMetadata { reference: any; }\n\nexport enum CompileSummaryKind {\n  Pipe,\n  Directive,\n  NgModule,\n  Injectable\n}\n\n/**\n * A CompileSummary is the data needed to use a directive / pipe / module\n * in other modules / components. However, this data is not enough to compile\n * the directive / module itself.\n */\nexport interface CompileTypeSummary {\n  summaryKind: CompileSummaryKind|null;\n  type: CompileTypeMetadata;\n}\n\nexport interface CompileDiDependencyMetadata {\n  isAttribute?: boolean;\n  isSelf?: boolean;\n  isHost?: boolean;\n  isSkipSelf?: boolean;\n  isOptional?: boolean;\n  isValue?: boolean;\n  token?: CompileTokenMetadata;\n  value?: any;\n}\n\nexport interface CompileProviderMetadata {\n  token: CompileTokenMetadata;\n  useClass?: CompileTypeMetadata;\n  useValue?: any;\n  useExisting?: CompileTokenMetadata;\n  useFactory?: CompileFactoryMetadata;\n  deps?: CompileDiDependencyMetadata[];\n  multi?: boolean;\n}\n\nexport interface CompileFactoryMetadata extends CompileIdentifierMetadata {\n  diDeps: CompileDiDependencyMetadata[];\n  reference: any;\n}\n\nexport function tokenName(token: CompileTokenMetadata) {\n  return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);\n}\n\nexport function tokenReference(token: CompileTokenMetadata) {\n  if (token.identifier != null) {\n    return token.identifier.reference;\n  } else {\n    return token.value;\n  }\n}\n\nexport interface CompileTokenMetadata {\n  value?: any;\n  identifier?: CompileIdentifierMetadata|CompileTypeMetadata;\n}\n\nexport interface CompileInjectableMetadata {\n  symbol: StaticSymbol;\n  type: CompileTypeMetadata;\n\n  providedIn?: StaticSymbol;\n\n  useValue?: any;\n  useClass?: StaticSymbol;\n  useExisting?: StaticSymbol;\n  useFactory?: StaticSymbol;\n  deps?: any[];\n}\n\n/**\n * Metadata regarding compilation of a type.\n */\nexport interface CompileTypeMetadata extends CompileIdentifierMetadata {\n  diDeps: CompileDiDependencyMetadata[];\n  lifecycleHooks: LifecycleHooks[];\n  reference: any;\n}\n\nexport interface CompileQueryMetadata {\n  selectors: Array<CompileTokenMetadata>;\n  descendants: boolean;\n  first: boolean;\n  propertyName: string;\n  read: CompileTokenMetadata;\n  static?: boolean;\n}\n\n/**\n * Metadata about a stylesheet\n */\nexport class CompileStylesheetMetadata {\n  moduleUrl: string|null;\n  styles: string[];\n  styleUrls: string[];\n  constructor(\n      {moduleUrl, styles,\n       styleUrls}: {moduleUrl?: string, styles?: string[], styleUrls?: string[]} = {}) {\n    this.moduleUrl = moduleUrl || null;\n    this.styles = _normalizeArray(styles);\n    this.styleUrls = _normalizeArray(styleUrls);\n  }\n}\n\n/**\n * Summary Metadata regarding compilation of a template.\n */\nexport interface CompileTemplateSummary {\n  ngContentSelectors: string[];\n  encapsulation: ViewEncapsulation|null;\n  styles: string[];\n  animations: any[]|null;\n}\n\n/**\n * Metadata regarding compilation of a template.\n */\nexport class CompileTemplateMetadata {\n  encapsulation: ViewEncapsulation|null;\n  template: string|null;\n  templateUrl: string|null;\n  htmlAst: HtmlParseTreeResult|null;\n  isInline: boolean;\n  styles: string[];\n  styleUrls: string[];\n  externalStylesheets: CompileStylesheetMetadata[];\n  animations: any[];\n  ngContentSelectors: string[];\n  interpolation: [string, string]|null;\n  preserveWhitespaces: boolean;\n  constructor({encapsulation, template, templateUrl, htmlAst, styles, styleUrls,\n               externalStylesheets, animations, ngContentSelectors, interpolation, isInline,\n               preserveWhitespaces}: {\n    encapsulation: ViewEncapsulation | null,\n    template: string|null,\n    templateUrl: string|null,\n    htmlAst: HtmlParseTreeResult|null,\n    styles: string[],\n    styleUrls: string[],\n    externalStylesheets: CompileStylesheetMetadata[],\n    ngContentSelectors: string[],\n    animations: any[],\n    interpolation: [string, string]|null,\n    isInline: boolean,\n    preserveWhitespaces: boolean\n  }) {\n    this.encapsulation = encapsulation;\n    this.template = template;\n    this.templateUrl = templateUrl;\n    this.htmlAst = htmlAst;\n    this.styles = _normalizeArray(styles);\n    this.styleUrls = _normalizeArray(styleUrls);\n    this.externalStylesheets = _normalizeArray(externalStylesheets);\n    this.animations = animations ? flatten(animations) : [];\n    this.ngContentSelectors = ngContentSelectors || [];\n    if (interpolation && interpolation.length != 2) {\n      throw new Error(`'interpolation' should have a start and an end symbol.`);\n    }\n    this.interpolation = interpolation;\n    this.isInline = isInline;\n    this.preserveWhitespaces = preserveWhitespaces;\n  }\n\n  toSummary(): CompileTemplateSummary {\n    return {\n      ngContentSelectors: this.ngContentSelectors,\n      encapsulation: this.encapsulation,\n      styles: this.styles,\n      animations: this.animations\n    };\n  }\n}\n\nexport interface CompileEntryComponentMetadata {\n  componentType: any;\n  componentFactory: StaticSymbol|object;\n}\n\n// Note: This should only use interfaces as nested data types\n// as we need to be able to serialize this from/to JSON!\nexport interface CompileDirectiveSummary extends CompileTypeSummary {\n  type: CompileTypeMetadata;\n  isComponent: boolean;\n  selector: string|null;\n  exportAs: string|null;\n  inputs: {[key: string]: string};\n  outputs: {[key: string]: string};\n  hostListeners: {[key: string]: string};\n  hostProperties: {[key: string]: string};\n  hostAttributes: {[key: string]: string};\n  providers: CompileProviderMetadata[];\n  viewProviders: CompileProviderMetadata[];\n  queries: CompileQueryMetadata[];\n  guards: {[key: string]: any};\n  viewQueries: CompileQueryMetadata[];\n  entryComponents: CompileEntryComponentMetadata[];\n  changeDetection: ChangeDetectionStrategy|null;\n  template: CompileTemplateSummary|null;\n  componentViewType: StaticSymbol|ProxyClass|null;\n  rendererType: StaticSymbol|object|null;\n  componentFactory: StaticSymbol|object|null;\n}\n\n/**\n * Metadata regarding compilation of a directive.\n */\nexport class CompileDirectiveMetadata {\n  static create({isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs,\n                 host, providers, viewProviders, queries, guards, viewQueries, entryComponents,\n                 template, componentViewType, rendererType, componentFactory}: {\n    isHost: boolean,\n    type: CompileTypeMetadata,\n    isComponent: boolean,\n    selector: string|null,\n    exportAs: string|null,\n    changeDetection: ChangeDetectionStrategy|null,\n    inputs: string[],\n    outputs: string[],\n    host: {[key: string]: string},\n    providers: CompileProviderMetadata[],\n    viewProviders: CompileProviderMetadata[],\n    queries: CompileQueryMetadata[],\n    guards: {[key: string]: any};\n    viewQueries: CompileQueryMetadata[],\n    entryComponents: CompileEntryComponentMetadata[],\n    template: CompileTemplateMetadata,\n    componentViewType: StaticSymbol|ProxyClass|null,\n    rendererType: StaticSymbol|object|null,\n    componentFactory: StaticSymbol|object|null,\n  }): CompileDirectiveMetadata {\n    const hostListeners: {[key: string]: string} = {};\n    const hostProperties: {[key: string]: string} = {};\n    const hostAttributes: {[key: string]: string} = {};\n    if (host != null) {\n      Object.keys(host).forEach(key => {\n        const value = host[key];\n        const matches = key.match(HOST_REG_EXP);\n        if (matches === null) {\n          hostAttributes[key] = value;\n        } else if (matches[1] != null) {\n          hostProperties[matches[1]] = value;\n        } else if (matches[2] != null) {\n          hostListeners[matches[2]] = value;\n        }\n      });\n    }\n    const inputsMap: {[key: string]: string} = {};\n    if (inputs != null) {\n      inputs.forEach((bindConfig: string) => {\n        // canonical syntax: `dirProp: elProp`\n        // if there is no `:`, use dirProp = elProp\n        const parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n        inputsMap[parts[0]] = parts[1];\n      });\n    }\n    const outputsMap: {[key: string]: string} = {};\n    if (outputs != null) {\n      outputs.forEach((bindConfig: string) => {\n        // canonical syntax: `dirProp: elProp`\n        // if there is no `:`, use dirProp = elProp\n        const parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n        outputsMap[parts[0]] = parts[1];\n      });\n    }\n\n    return new CompileDirectiveMetadata({\n      isHost,\n      type,\n      isComponent: !!isComponent, selector, exportAs, changeDetection,\n      inputs: inputsMap,\n      outputs: outputsMap,\n      hostListeners,\n      hostProperties,\n      hostAttributes,\n      providers,\n      viewProviders,\n      queries,\n      guards,\n      viewQueries,\n      entryComponents,\n      template,\n      componentViewType,\n      rendererType,\n      componentFactory,\n    });\n  }\n  isHost: boolean;\n  type: CompileTypeMetadata;\n  isComponent: boolean;\n  selector: string|null;\n  exportAs: string|null;\n  changeDetection: ChangeDetectionStrategy|null;\n  inputs: {[key: string]: string};\n  outputs: {[key: string]: string};\n  hostListeners: {[key: string]: string};\n  hostProperties: {[key: string]: string};\n  hostAttributes: {[key: string]: string};\n  providers: CompileProviderMetadata[];\n  viewProviders: CompileProviderMetadata[];\n  queries: CompileQueryMetadata[];\n  guards: {[key: string]: any};\n  viewQueries: CompileQueryMetadata[];\n  entryComponents: CompileEntryComponentMetadata[];\n\n  template: CompileTemplateMetadata|null;\n\n  componentViewType: StaticSymbol|ProxyClass|null;\n  rendererType: StaticSymbol|object|null;\n  componentFactory: StaticSymbol|object|null;\n\n  constructor({isHost,\n               type,\n               isComponent,\n               selector,\n               exportAs,\n               changeDetection,\n               inputs,\n               outputs,\n               hostListeners,\n               hostProperties,\n               hostAttributes,\n               providers,\n               viewProviders,\n               queries,\n               guards,\n               viewQueries,\n               entryComponents,\n               template,\n               componentViewType,\n               rendererType,\n               componentFactory}: {\n    isHost: boolean,\n    type: CompileTypeMetadata,\n    isComponent: boolean,\n    selector: string|null,\n    exportAs: string|null,\n    changeDetection: ChangeDetectionStrategy|null,\n    inputs: {[key: string]: string},\n    outputs: {[key: string]: string},\n    hostListeners: {[key: string]: string},\n    hostProperties: {[key: string]: string},\n    hostAttributes: {[key: string]: string},\n    providers: CompileProviderMetadata[],\n    viewProviders: CompileProviderMetadata[],\n    queries: CompileQueryMetadata[],\n    guards: {[key: string]: any},\n    viewQueries: CompileQueryMetadata[],\n    entryComponents: CompileEntryComponentMetadata[],\n    template: CompileTemplateMetadata|null,\n    componentViewType: StaticSymbol|ProxyClass|null,\n    rendererType: StaticSymbol|object|null,\n    componentFactory: StaticSymbol|object|null,\n  }) {\n    this.isHost = !!isHost;\n    this.type = type;\n    this.isComponent = isComponent;\n    this.selector = selector;\n    this.exportAs = exportAs;\n    this.changeDetection = changeDetection;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.hostListeners = hostListeners;\n    this.hostProperties = hostProperties;\n    this.hostAttributes = hostAttributes;\n    this.providers = _normalizeArray(providers);\n    this.viewProviders = _normalizeArray(viewProviders);\n    this.queries = _normalizeArray(queries);\n    this.guards = guards;\n    this.viewQueries = _normalizeArray(viewQueries);\n    this.entryComponents = _normalizeArray(entryComponents);\n    this.template = template;\n\n    this.componentViewType = componentViewType;\n    this.rendererType = rendererType;\n    this.componentFactory = componentFactory;\n  }\n\n  toSummary(): CompileDirectiveSummary {\n    return {\n      summaryKind: CompileSummaryKind.Directive,\n      type: this.type,\n      isComponent: this.isComponent,\n      selector: this.selector,\n      exportAs: this.exportAs,\n      inputs: this.inputs,\n      outputs: this.outputs,\n      hostListeners: this.hostListeners,\n      hostProperties: this.hostProperties,\n      hostAttributes: this.hostAttributes,\n      providers: this.providers,\n      viewProviders: this.viewProviders,\n      queries: this.queries,\n      guards: this.guards,\n      viewQueries: this.viewQueries,\n      entryComponents: this.entryComponents,\n      changeDetection: this.changeDetection,\n      template: this.template && this.template.toSummary(),\n      componentViewType: this.componentViewType,\n      rendererType: this.rendererType,\n      componentFactory: this.componentFactory\n    };\n  }\n}\n\nexport interface CompilePipeSummary extends CompileTypeSummary {\n  type: CompileTypeMetadata;\n  name: string;\n  pure: boolean;\n}\n\nexport class CompilePipeMetadata {\n  type: CompileTypeMetadata;\n  name: string;\n  pure: boolean;\n\n  constructor({type, name, pure}: {\n    type: CompileTypeMetadata,\n    name: string,\n    pure: boolean,\n  }) {\n    this.type = type;\n    this.name = name;\n    this.pure = !!pure;\n  }\n\n  toSummary(): CompilePipeSummary {\n    return {\n      summaryKind: CompileSummaryKind.Pipe,\n      type: this.type,\n      name: this.name,\n      pure: this.pure\n    };\n  }\n}\n\n// Note: This should only use interfaces as nested data types\n// as we need to be able to serialize this from/to JSON!\nexport interface CompileNgModuleSummary extends CompileTypeSummary {\n  type: CompileTypeMetadata;\n\n  // Note: This is transitive over the exported modules.\n  exportedDirectives: CompileIdentifierMetadata[];\n  // Note: This is transitive over the exported modules.\n  exportedPipes: CompileIdentifierMetadata[];\n\n  // Note: This is transitive.\n  entryComponents: CompileEntryComponentMetadata[];\n  // Note: This is transitive.\n  providers: {provider: CompileProviderMetadata, module: CompileIdentifierMetadata}[];\n  // Note: This is transitive.\n  modules: CompileTypeMetadata[];\n}\n\nexport class CompileShallowModuleMetadata {\n  // TODO(issue/24571): remove '!'.\n  type !: CompileTypeMetadata;\n\n  rawExports: any;\n  rawImports: any;\n  rawProviders: any;\n}\n\n/**\n * Metadata regarding compilation of a module.\n */\nexport class CompileNgModuleMetadata {\n  type: CompileTypeMetadata;\n  declaredDirectives: CompileIdentifierMetadata[];\n  exportedDirectives: CompileIdentifierMetadata[];\n  declaredPipes: CompileIdentifierMetadata[];\n\n  exportedPipes: CompileIdentifierMetadata[];\n  entryComponents: CompileEntryComponentMetadata[];\n  bootstrapComponents: CompileIdentifierMetadata[];\n  providers: CompileProviderMetadata[];\n\n  importedModules: CompileNgModuleSummary[];\n  exportedModules: CompileNgModuleSummary[];\n  schemas: SchemaMetadata[];\n  id: string|null;\n\n  transitiveModule: TransitiveCompileNgModuleMetadata;\n\n  constructor({type, providers, declaredDirectives, exportedDirectives, declaredPipes,\n               exportedPipes, entryComponents, bootstrapComponents, importedModules,\n               exportedModules, schemas, transitiveModule, id}: {\n    type: CompileTypeMetadata,\n    providers: CompileProviderMetadata[],\n    declaredDirectives: CompileIdentifierMetadata[],\n    exportedDirectives: CompileIdentifierMetadata[],\n    declaredPipes: CompileIdentifierMetadata[],\n    exportedPipes: CompileIdentifierMetadata[],\n    entryComponents: CompileEntryComponentMetadata[],\n    bootstrapComponents: CompileIdentifierMetadata[],\n    importedModules: CompileNgModuleSummary[],\n    exportedModules: CompileNgModuleSummary[],\n    transitiveModule: TransitiveCompileNgModuleMetadata,\n    schemas: SchemaMetadata[],\n    id: string|null\n  }) {\n    this.type = type || null;\n    this.declaredDirectives = _normalizeArray(declaredDirectives);\n    this.exportedDirectives = _normalizeArray(exportedDirectives);\n    this.declaredPipes = _normalizeArray(declaredPipes);\n    this.exportedPipes = _normalizeArray(exportedPipes);\n    this.providers = _normalizeArray(providers);\n    this.entryComponents = _normalizeArray(entryComponents);\n    this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n    this.importedModules = _normalizeArray(importedModules);\n    this.exportedModules = _normalizeArray(exportedModules);\n    this.schemas = _normalizeArray(schemas);\n    this.id = id || null;\n    this.transitiveModule = transitiveModule || null;\n  }\n\n  toSummary(): CompileNgModuleSummary {\n    const module = this.transitiveModule !;\n    return {\n      summaryKind: CompileSummaryKind.NgModule,\n      type: this.type,\n      entryComponents: module.entryComponents,\n      providers: module.providers,\n      modules: module.modules,\n      exportedDirectives: module.exportedDirectives,\n      exportedPipes: module.exportedPipes\n    };\n  }\n}\n\nexport class TransitiveCompileNgModuleMetadata {\n  directivesSet = new Set<any>();\n  directives: CompileIdentifierMetadata[] = [];\n  exportedDirectivesSet = new Set<any>();\n  exportedDirectives: CompileIdentifierMetadata[] = [];\n  pipesSet = new Set<any>();\n  pipes: CompileIdentifierMetadata[] = [];\n  exportedPipesSet = new Set<any>();\n  exportedPipes: CompileIdentifierMetadata[] = [];\n  modulesSet = new Set<any>();\n  modules: CompileTypeMetadata[] = [];\n  entryComponentsSet = new Set<any>();\n  entryComponents: CompileEntryComponentMetadata[] = [];\n\n  providers: {provider: CompileProviderMetadata, module: CompileIdentifierMetadata}[] = [];\n\n  addProvider(provider: CompileProviderMetadata, module: CompileIdentifierMetadata) {\n    this.providers.push({provider: provider, module: module});\n  }\n\n  addDirective(id: CompileIdentifierMetadata) {\n    if (!this.directivesSet.has(id.reference)) {\n      this.directivesSet.add(id.reference);\n      this.directives.push(id);\n    }\n  }\n  addExportedDirective(id: CompileIdentifierMetadata) {\n    if (!this.exportedDirectivesSet.has(id.reference)) {\n      this.exportedDirectivesSet.add(id.reference);\n      this.exportedDirectives.push(id);\n    }\n  }\n  addPipe(id: CompileIdentifierMetadata) {\n    if (!this.pipesSet.has(id.reference)) {\n      this.pipesSet.add(id.reference);\n      this.pipes.push(id);\n    }\n  }\n  addExportedPipe(id: CompileIdentifierMetadata) {\n    if (!this.exportedPipesSet.has(id.reference)) {\n      this.exportedPipesSet.add(id.reference);\n      this.exportedPipes.push(id);\n    }\n  }\n  addModule(id: CompileTypeMetadata) {\n    if (!this.modulesSet.has(id.reference)) {\n      this.modulesSet.add(id.reference);\n      this.modules.push(id);\n    }\n  }\n  addEntryComponent(ec: CompileEntryComponentMetadata) {\n    if (!this.entryComponentsSet.has(ec.componentType)) {\n      this.entryComponentsSet.add(ec.componentType);\n      this.entryComponents.push(ec);\n    }\n  }\n}\n\nfunction _normalizeArray(obj: any[] | undefined | null): any[] {\n  return obj || [];\n}\n\nexport class ProviderMeta {\n  token: any;\n  useClass: Type|null;\n  useValue: any;\n  useExisting: any;\n  useFactory: Function|null;\n  dependencies: Object[]|null;\n  multi: boolean;\n\n  constructor(token: any, {useClass, useValue, useExisting, useFactory, deps, multi}: {\n    useClass?: Type,\n    useValue?: any,\n    useExisting?: any,\n    useFactory?: Function|null,\n    deps?: Object[]|null,\n    multi?: boolean\n  }) {\n    this.token = token;\n    this.useClass = useClass || null;\n    this.useValue = useValue;\n    this.useExisting = useExisting;\n    this.useFactory = useFactory || null;\n    this.dependencies = deps || null;\n    this.multi = !!multi;\n  }\n}\n\nexport function flatten<T>(list: Array<T|T[]>): T[] {\n  return list.reduce((flat: any[], item: T | T[]): T[] => {\n    const flatItem = Array.isArray(item) ? flatten(item) : item;\n    return (<T[]>flat).concat(flatItem);\n  }, []);\n}\n\nfunction jitSourceUrl(url: string) {\n  // Note: We need 3 \"/\" so that ng shows up as a separate domain\n  // in the chrome dev tools.\n  return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n}\n\nexport function templateSourceUrl(\n    ngModuleType: CompileIdentifierMetadata, compMeta: {type: CompileIdentifierMetadata},\n    templateMeta: {isInline: boolean, templateUrl: string | null}) {\n  let url: string;\n  if (templateMeta.isInline) {\n    if (compMeta.type.reference instanceof StaticSymbol) {\n      // Note: a .ts file might contain multiple components with inline templates,\n      // so we need to give them unique urls, as these will be used for sourcemaps.\n      url = `${compMeta.type.reference.filePath}.${compMeta.type.reference.name}.html`;\n    } else {\n      url = `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.html`;\n    }\n  } else {\n    url = templateMeta.templateUrl !;\n  }\n  return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);\n}\n\nexport function sharedStylesheetJitUrl(meta: CompileStylesheetMetadata, id: number) {\n  const pathParts = meta.moduleUrl !.split(/\\/\\\\/g);\n  const baseName = pathParts[pathParts.length - 1];\n  return jitSourceUrl(`css/${id}${baseName}.ngstyle.js`);\n}\n\nexport function ngModuleJitUrl(moduleMeta: CompileNgModuleMetadata): string {\n  return jitSourceUrl(`${identifierName(moduleMeta.type)}/module.ngfactory.js`);\n}\n\nexport function templateJitUrl(\n    ngModuleType: CompileIdentifierMetadata, compMeta: CompileDirectiveMetadata): string {\n  return jitSourceUrl(\n      `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.ngfactory.js`);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from '../output/output_ast';\n\nconst CORE = '@angular/core';\n\nexport class Identifiers {\n  /* Methods */\n  static NEW_METHOD = 'factory';\n  static TRANSFORM_METHOD = 'transform';\n  static PATCH_DEPS = 'patchedDeps';\n\n  /* Instructions */\n  static namespaceHTML: o.ExternalReference = {name: 'ÉµÉµnamespaceHTML', moduleName: CORE};\n\n  static namespaceMathML: o.ExternalReference = {name: 'ÉµÉµnamespaceMathML', moduleName: CORE};\n\n  static namespaceSVG: o.ExternalReference = {name: 'ÉµÉµnamespaceSVG', moduleName: CORE};\n\n  static element: o.ExternalReference = {name: 'ÉµÉµelement', moduleName: CORE};\n\n  static elementStart: o.ExternalReference = {name: 'ÉµÉµelementStart', moduleName: CORE};\n\n  static elementEnd: o.ExternalReference = {name: 'ÉµÉµelementEnd', moduleName: CORE};\n\n  static select: o.ExternalReference = {name: 'ÉµÉµselect', moduleName: CORE};\n  static advance: o.ExternalReference = {name: 'ÉµÉµadvance', moduleName: CORE};\n\n  static updateSyntheticHostBinding:\n      o.ExternalReference = {name: 'ÉµÉµupdateSyntheticHostBinding', moduleName: CORE};\n\n  static componentHostSyntheticListener:\n      o.ExternalReference = {name: 'ÉµÉµcomponentHostSyntheticListener', moduleName: CORE};\n\n  static attribute: o.ExternalReference = {name: 'ÉµÉµattribute', moduleName: CORE};\n\n  static attributeInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate1', moduleName: CORE};\n  static attributeInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate2', moduleName: CORE};\n  static attributeInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate3', moduleName: CORE};\n  static attributeInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate4', moduleName: CORE};\n  static attributeInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate5', moduleName: CORE};\n  static attributeInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate6', moduleName: CORE};\n  static attributeInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate7', moduleName: CORE};\n  static attributeInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolate8', moduleName: CORE};\n  static attributeInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµattributeInterpolateV', moduleName: CORE};\n\n  static classProp: o.ExternalReference = {name: 'ÉµÉµclassProp', moduleName: CORE};\n\n  static elementContainerStart:\n      o.ExternalReference = {name: 'ÉµÉµelementContainerStart', moduleName: CORE};\n\n  static elementContainerEnd:\n      o.ExternalReference = {name: 'ÉµÉµelementContainerEnd', moduleName: CORE};\n\n  static elementContainer: o.ExternalReference = {name: 'ÉµÉµelementContainer', moduleName: CORE};\n\n  static styleMap: o.ExternalReference = {name: 'ÉµÉµstyleMap', moduleName: CORE};\n\n  static classMap: o.ExternalReference = {name: 'ÉµÉµclassMap', moduleName: CORE};\n\n  static classMapInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate1', moduleName: CORE};\n  static classMapInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate2', moduleName: CORE};\n  static classMapInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate3', moduleName: CORE};\n  static classMapInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate4', moduleName: CORE};\n  static classMapInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate5', moduleName: CORE};\n  static classMapInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate6', moduleName: CORE};\n  static classMapInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate7', moduleName: CORE};\n  static classMapInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolate8', moduleName: CORE};\n  static classMapInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµclassMapInterpolateV', moduleName: CORE};\n\n  static styleProp: o.ExternalReference = {name: 'ÉµÉµstyleProp', moduleName: CORE};\n\n  static stylePropInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate1', moduleName: CORE};\n  static stylePropInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate2', moduleName: CORE};\n  static stylePropInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate3', moduleName: CORE};\n  static stylePropInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate4', moduleName: CORE};\n  static stylePropInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate5', moduleName: CORE};\n  static stylePropInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate6', moduleName: CORE};\n  static stylePropInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate7', moduleName: CORE};\n  static stylePropInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolate8', moduleName: CORE};\n  static stylePropInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµstylePropInterpolateV', moduleName: CORE};\n\n  static containerCreate: o.ExternalReference = {name: 'ÉµÉµcontainer', moduleName: CORE};\n\n  static nextContext: o.ExternalReference = {name: 'ÉµÉµnextContext', moduleName: CORE};\n\n  static templateCreate: o.ExternalReference = {name: 'ÉµÉµtemplate', moduleName: CORE};\n\n  static text: o.ExternalReference = {name: 'ÉµÉµtext', moduleName: CORE};\n\n  static enableBindings: o.ExternalReference = {name: 'ÉµÉµenableBindings', moduleName: CORE};\n\n  static disableBindings: o.ExternalReference = {name: 'ÉµÉµdisableBindings', moduleName: CORE};\n\n  static getCurrentView: o.ExternalReference = {name: 'ÉµÉµgetCurrentView', moduleName: CORE};\n\n  static textInterpolate: o.ExternalReference = {name: 'ÉµÉµtextInterpolate', moduleName: CORE};\n  static textInterpolate1: o.ExternalReference = {name: 'ÉµÉµtextInterpolate1', moduleName: CORE};\n  static textInterpolate2: o.ExternalReference = {name: 'ÉµÉµtextInterpolate2', moduleName: CORE};\n  static textInterpolate3: o.ExternalReference = {name: 'ÉµÉµtextInterpolate3', moduleName: CORE};\n  static textInterpolate4: o.ExternalReference = {name: 'ÉµÉµtextInterpolate4', moduleName: CORE};\n  static textInterpolate5: o.ExternalReference = {name: 'ÉµÉµtextInterpolate5', moduleName: CORE};\n  static textInterpolate6: o.ExternalReference = {name: 'ÉµÉµtextInterpolate6', moduleName: CORE};\n  static textInterpolate7: o.ExternalReference = {name: 'ÉµÉµtextInterpolate7', moduleName: CORE};\n  static textInterpolate8: o.ExternalReference = {name: 'ÉµÉµtextInterpolate8', moduleName: CORE};\n  static textInterpolateV: o.ExternalReference = {name: 'ÉµÉµtextInterpolateV', moduleName: CORE};\n\n  static restoreView: o.ExternalReference = {name: 'ÉµÉµrestoreView', moduleName: CORE};\n\n  static pureFunction0: o.ExternalReference = {name: 'ÉµÉµpureFunction0', moduleName: CORE};\n  static pureFunction1: o.ExternalReference = {name: 'ÉµÉµpureFunction1', moduleName: CORE};\n  static pureFunction2: o.ExternalReference = {name: 'ÉµÉµpureFunction2', moduleName: CORE};\n  static pureFunction3: o.ExternalReference = {name: 'ÉµÉµpureFunction3', moduleName: CORE};\n  static pureFunction4: o.ExternalReference = {name: 'ÉµÉµpureFunction4', moduleName: CORE};\n  static pureFunction5: o.ExternalReference = {name: 'ÉµÉµpureFunction5', moduleName: CORE};\n  static pureFunction6: o.ExternalReference = {name: 'ÉµÉµpureFunction6', moduleName: CORE};\n  static pureFunction7: o.ExternalReference = {name: 'ÉµÉµpureFunction7', moduleName: CORE};\n  static pureFunction8: o.ExternalReference = {name: 'ÉµÉµpureFunction8', moduleName: CORE};\n  static pureFunctionV: o.ExternalReference = {name: 'ÉµÉµpureFunctionV', moduleName: CORE};\n\n  static pipeBind1: o.ExternalReference = {name: 'ÉµÉµpipeBind1', moduleName: CORE};\n  static pipeBind2: o.ExternalReference = {name: 'ÉµÉµpipeBind2', moduleName: CORE};\n  static pipeBind3: o.ExternalReference = {name: 'ÉµÉµpipeBind3', moduleName: CORE};\n  static pipeBind4: o.ExternalReference = {name: 'ÉµÉµpipeBind4', moduleName: CORE};\n  static pipeBindV: o.ExternalReference = {name: 'ÉµÉµpipeBindV', moduleName: CORE};\n\n  static hostProperty: o.ExternalReference = {name: 'ÉµÉµhostProperty', moduleName: CORE};\n\n  static property: o.ExternalReference = {name: 'ÉµÉµproperty', moduleName: CORE};\n\n  static propertyInterpolate:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate', moduleName: CORE};\n  static propertyInterpolate1:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate1', moduleName: CORE};\n  static propertyInterpolate2:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate2', moduleName: CORE};\n  static propertyInterpolate3:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate3', moduleName: CORE};\n  static propertyInterpolate4:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate4', moduleName: CORE};\n  static propertyInterpolate5:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate5', moduleName: CORE};\n  static propertyInterpolate6:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate6', moduleName: CORE};\n  static propertyInterpolate7:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate7', moduleName: CORE};\n  static propertyInterpolate8:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolate8', moduleName: CORE};\n  static propertyInterpolateV:\n      o.ExternalReference = {name: 'ÉµÉµpropertyInterpolateV', moduleName: CORE};\n\n  static i18n: o.ExternalReference = {name: 'ÉµÉµi18n', moduleName: CORE};\n  static i18nAttributes: o.ExternalReference = {name: 'ÉµÉµi18nAttributes', moduleName: CORE};\n  static i18nExp: o.ExternalReference = {name: 'ÉµÉµi18nExp', moduleName: CORE};\n  static i18nStart: o.ExternalReference = {name: 'ÉµÉµi18nStart', moduleName: CORE};\n  static i18nEnd: o.ExternalReference = {name: 'ÉµÉµi18nEnd', moduleName: CORE};\n  static i18nApply: o.ExternalReference = {name: 'ÉµÉµi18nApply', moduleName: CORE};\n  static i18nPostprocess: o.ExternalReference = {name: 'ÉµÉµi18nPostprocess', moduleName: CORE};\n\n  static pipe: o.ExternalReference = {name: 'ÉµÉµpipe', moduleName: CORE};\n\n  static projection: o.ExternalReference = {name: 'ÉµÉµprojection', moduleName: CORE};\n  static projectionDef: o.ExternalReference = {name: 'ÉµÉµprojectionDef', moduleName: CORE};\n\n  static reference: o.ExternalReference = {name: 'ÉµÉµreference', moduleName: CORE};\n\n  static inject: o.ExternalReference = {name: 'ÉµÉµinject', moduleName: CORE};\n\n  static injectAttribute: o.ExternalReference = {name: 'ÉµÉµinjectAttribute', moduleName: CORE};\n\n  static injectPipeChangeDetectorRef:\n      o.ExternalReference = {name: 'ÉµÉµinjectPipeChangeDetectorRef', moduleName: CORE};\n\n  static directiveInject: o.ExternalReference = {name: 'ÉµÉµdirectiveInject', moduleName: CORE};\n  static invalidFactory: o.ExternalReference = {name: 'ÉµÉµinvalidFactory', moduleName: CORE};\n  static invalidFactoryDep: o.ExternalReference = {name: 'ÉµÉµinvalidFactoryDep', moduleName: CORE};\n\n  static templateRefExtractor:\n      o.ExternalReference = {name: 'ÉµÉµtemplateRefExtractor', moduleName: CORE};\n\n  static resolveWindow: o.ExternalReference = {name: 'ÉµÉµresolveWindow', moduleName: CORE};\n  static resolveDocument: o.ExternalReference = {name: 'ÉµÉµresolveDocument', moduleName: CORE};\n  static resolveBody: o.ExternalReference = {name: 'ÉµÉµresolveBody', moduleName: CORE};\n\n  static defineComponent: o.ExternalReference = {name: 'ÉµÉµdefineComponent', moduleName: CORE};\n\n  static setComponentScope: o.ExternalReference = {name: 'ÉµÉµsetComponentScope', moduleName: CORE};\n\n  static ComponentDefWithMeta: o.ExternalReference = {\n    name: 'ÉµÉµComponentDefWithMeta',\n    moduleName: CORE,\n  };\n\n  static FactoryDef: o.ExternalReference = {\n    name: 'ÉµÉµFactoryDef',\n    moduleName: CORE,\n  };\n\n  static defineDirective: o.ExternalReference = {\n    name: 'ÉµÉµdefineDirective',\n    moduleName: CORE,\n  };\n\n  static DirectiveDefWithMeta: o.ExternalReference = {\n    name: 'ÉµÉµDirectiveDefWithMeta',\n    moduleName: CORE,\n  };\n\n  static InjectorDef: o.ExternalReference = {\n    name: 'ÉµÉµInjectorDef',\n    moduleName: CORE,\n  };\n\n  static defineInjector: o.ExternalReference = {\n    name: 'ÉµÉµdefineInjector',\n    moduleName: CORE,\n  };\n\n  static NgModuleDefWithMeta: o.ExternalReference = {\n    name: 'ÉµÉµNgModuleDefWithMeta',\n    moduleName: CORE,\n  };\n\n  static ModuleWithProviders: o.ExternalReference = {\n    name: 'ModuleWithProviders',\n    moduleName: CORE,\n  };\n\n  static defineNgModule: o.ExternalReference = {name: 'ÉµÉµdefineNgModule', moduleName: CORE};\n  static setNgModuleScope: o.ExternalReference = {name: 'ÉµÉµsetNgModuleScope', moduleName: CORE};\n\n  static PipeDefWithMeta: o.ExternalReference = {name: 'ÉµÉµPipeDefWithMeta', moduleName: CORE};\n\n  static definePipe: o.ExternalReference = {name: 'ÉµÉµdefinePipe', moduleName: CORE};\n\n  static queryRefresh: o.ExternalReference = {name: 'ÉµÉµqueryRefresh', moduleName: CORE};\n  static viewQuery: o.ExternalReference = {name: 'ÉµÉµviewQuery', moduleName: CORE};\n  static staticViewQuery: o.ExternalReference = {name: 'ÉµÉµstaticViewQuery', moduleName: CORE};\n  static staticContentQuery: o.ExternalReference = {name: 'ÉµÉµstaticContentQuery', moduleName: CORE};\n  static loadQuery: o.ExternalReference = {name: 'ÉµÉµloadQuery', moduleName: CORE};\n  static contentQuery: o.ExternalReference = {name: 'ÉµÉµcontentQuery', moduleName: CORE};\n\n  static NgOnChangesFeature: o.ExternalReference = {name: 'ÉµÉµNgOnChangesFeature', moduleName: CORE};\n\n  static InheritDefinitionFeature:\n      o.ExternalReference = {name: 'ÉµÉµInheritDefinitionFeature', moduleName: CORE};\n\n  static CopyDefinitionFeature:\n      o.ExternalReference = {name: 'ÉµÉµCopyDefinitionFeature', moduleName: CORE};\n\n  static ProvidersFeature: o.ExternalReference = {name: 'ÉµÉµProvidersFeature', moduleName: CORE};\n\n  static listener: o.ExternalReference = {name: 'ÉµÉµlistener', moduleName: CORE};\n\n  static getFactoryOf: o.ExternalReference = {\n    name: 'ÉµÉµgetFactoryOf',\n    moduleName: CORE,\n  };\n\n  static getInheritedFactory: o.ExternalReference = {\n    name: 'ÉµÉµgetInheritedFactory',\n    moduleName: CORE,\n  };\n\n  // sanitization-related functions\n  static sanitizeHtml: o.ExternalReference = {name: 'ÉµÉµsanitizeHtml', moduleName: CORE};\n  static sanitizeStyle: o.ExternalReference = {name: 'ÉµÉµsanitizeStyle', moduleName: CORE};\n  static defaultStyleSanitizer:\n      o.ExternalReference = {name: 'ÉµÉµdefaultStyleSanitizer', moduleName: CORE};\n  static sanitizeResourceUrl:\n      o.ExternalReference = {name: 'ÉµÉµsanitizeResourceUrl', moduleName: CORE};\n  static sanitizeScript: o.ExternalReference = {name: 'ÉµÉµsanitizeScript', moduleName: CORE};\n  static sanitizeUrl: o.ExternalReference = {name: 'ÉµÉµsanitizeUrl', moduleName: CORE};\n  static sanitizeUrlOrResourceUrl:\n      o.ExternalReference = {name: 'ÉµÉµsanitizeUrlOrResourceUrl', moduleName: CORE};\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from '../aot/static_symbol';\nimport * as o from '../output/output_ast';\nimport {OutputContext} from '../util';\n\n/**\n * Convert an object map with `Expression` values into a `LiteralMapExpr`.\n */\nexport function mapToMapExpression(map: {[key: string]: o.Expression | undefined}):\n    o.LiteralMapExpr {\n  const result = Object.keys(map).map(\n      key => ({\n        key,\n        // The assertion here is because really TypeScript doesn't allow us to express that if the\n        // key is present, it will have a value, but this is true in reality.\n        value: map[key] !,\n        quoted: false,\n      }));\n  return o.literalMap(result);\n}\n\n/**\n * Convert metadata into an `Expression` in the given `OutputContext`.\n *\n * This operation will handle arrays, references to symbols, or literal `null` or `undefined`.\n */\nexport function convertMetaToOutput(meta: any, ctx: OutputContext): o.Expression {\n  if (Array.isArray(meta)) {\n    return o.literalArr(meta.map(entry => convertMetaToOutput(entry, ctx)));\n  }\n  if (meta instanceof StaticSymbol) {\n    return ctx.importExpr(meta);\n  }\n  if (meta == null) {\n    return o.literal(meta);\n  }\n\n  throw new Error(`Internal error: Unsupported or unknown metadata: ${meta}`);\n}\n\nexport function typeWithParameters(type: o.Expression, numParams: number): o.ExpressionType {\n  let params: o.Type[]|null = null;\n  if (numParams > 0) {\n    params = [];\n    for (let i = 0; i < numParams; i++) {\n      params.push(o.DYNAMIC_TYPE);\n    }\n  }\n  return o.expressionType(type, null, params);\n}\n\nexport interface R3Reference {\n  value: o.Expression;\n  type: o.Expression;\n}\n\nconst ANIMATE_SYMBOL_PREFIX = '@';\nexport function prepareSyntheticPropertyName(name: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}`;\n}\n\nexport function prepareSyntheticListenerName(name: string, phase: string) {\n  return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\n}\n\nexport function isSyntheticPropertyOrListener(name: string) {\n  return name.charAt(0) == ANIMATE_SYMBOL_PREFIX;\n}\n\nexport function getSyntheticPropertyName(name: string) {\n  // this will strip out listener phase values...\n  // @foo.start => @foo\n  const i = name.indexOf('.');\n  name = i > 0 ? name.substring(0, i) : name;\n  if (name.charAt(0) !== ANIMATE_SYMBOL_PREFIX) {\n    name = ANIMATE_SYMBOL_PREFIX + name;\n  }\n  return name;\n}\n\nexport function prepareSyntheticListenerFunctionName(name: string, phase: string) {\n  return `animation_${name}_${phase}`;\n}\n\nexport function jitOnlyGuardedExpression(expr: o.Expression): o.Expression {\n  const ngJitMode = new o.ExternalExpr({name: 'ngJitMode', moduleName: null});\n  const jitFlagNotDefined = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Identical, new o.TypeofExpr(ngJitMode), o.literal('undefined'));\n  const jitFlagUndefinedOrTrue = new o.BinaryOperatorExpr(\n      o.BinaryOperator.Or, jitFlagNotDefined, ngJitMode, /* type */ undefined,\n      /* sourceSpan */ undefined, true);\n  return new o.BinaryOperatorExpr(o.BinaryOperator.And, jitFlagUndefinedOrTrue, expr);\n}\n\nexport function wrapReference(value: any): R3Reference {\n  const wrapped = new o.WrappedNodeExpr(value);\n  return {value: wrapped, type: wrapped};\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const $EOF = 0;\nexport const $BSPACE = 8;\nexport const $TAB = 9;\nexport const $LF = 10;\nexport const $VTAB = 11;\nexport const $FF = 12;\nexport const $CR = 13;\nexport const $SPACE = 32;\nexport const $BANG = 33;\nexport const $DQ = 34;\nexport const $HASH = 35;\nexport const $$ = 36;\nexport const $PERCENT = 37;\nexport const $AMPERSAND = 38;\nexport const $SQ = 39;\nexport const $LPAREN = 40;\nexport const $RPAREN = 41;\nexport const $STAR = 42;\nexport const $PLUS = 43;\nexport const $COMMA = 44;\nexport const $MINUS = 45;\nexport const $PERIOD = 46;\nexport const $SLASH = 47;\nexport const $COLON = 58;\nexport const $SEMICOLON = 59;\nexport const $LT = 60;\nexport const $EQ = 61;\nexport const $GT = 62;\nexport const $QUESTION = 63;\n\nexport const $0 = 48;\nexport const $7 = 55;\nexport const $9 = 57;\n\nexport const $A = 65;\nexport const $E = 69;\nexport const $F = 70;\nexport const $X = 88;\nexport const $Z = 90;\n\nexport const $LBRACKET = 91;\nexport const $BACKSLASH = 92;\nexport const $RBRACKET = 93;\nexport const $CARET = 94;\nexport const $_ = 95;\n\nexport const $a = 97;\nexport const $b = 98;\nexport const $e = 101;\nexport const $f = 102;\nexport const $n = 110;\nexport const $r = 114;\nexport const $t = 116;\nexport const $u = 117;\nexport const $v = 118;\nexport const $x = 120;\nexport const $z = 122;\n\nexport const $LBRACE = 123;\nexport const $BAR = 124;\nexport const $RBRACE = 125;\nexport const $NBSP = 160;\n\nexport const $PIPE = 124;\nexport const $TILDA = 126;\nexport const $AT = 64;\n\nexport const $BT = 96;\n\nexport function isWhitespace(code: number): boolean {\n  return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\n}\n\nexport function isDigit(code: number): boolean {\n  return $0 <= code && code <= $9;\n}\n\nexport function isAsciiLetter(code: number): boolean {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n\nexport function isAsciiHexDigit(code: number): boolean {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n\nexport function isNewLine(code: number): boolean {\n  return code === $LF || code === $CR;\n}\n\nexport function isOctalDigit(code: number): boolean {\n  return $0 <= code && code <= $7;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as chars from './chars';\nimport {CompileIdentifierMetadata, identifierModuleUrl, identifierName} from './compile_metadata';\nimport {error} from './util';\n\nexport class ParseLocation {\n  constructor(\n      public file: ParseSourceFile, public offset: number, public line: number,\n      public col: number) {}\n\n  toString(): string {\n    return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\n  }\n\n  moveBy(delta: number): ParseLocation {\n    const source = this.file.content;\n    const len = source.length;\n    let offset = this.offset;\n    let line = this.line;\n    let col = this.col;\n    while (offset > 0 && delta < 0) {\n      offset--;\n      delta++;\n      const ch = source.charCodeAt(offset);\n      if (ch == chars.$LF) {\n        line--;\n        const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode(chars.$LF));\n        col = priorLine > 0 ? offset - priorLine : offset;\n      } else {\n        col--;\n      }\n    }\n    while (offset < len && delta > 0) {\n      const ch = source.charCodeAt(offset);\n      offset++;\n      delta--;\n      if (ch == chars.$LF) {\n        line++;\n        col = 0;\n      } else {\n        col++;\n      }\n    }\n    return new ParseLocation(this.file, offset, line, col);\n  }\n\n  // Return the source around the location\n  // Up to `maxChars` or `maxLines` on each side of the location\n  getContext(maxChars: number, maxLines: number): {before: string, after: string}|null {\n    const content = this.file.content;\n    let startOffset = this.offset;\n\n    if (startOffset != null) {\n      if (startOffset > content.length - 1) {\n        startOffset = content.length - 1;\n      }\n      let endOffset = startOffset;\n      let ctxChars = 0;\n      let ctxLines = 0;\n\n      while (ctxChars < maxChars && startOffset > 0) {\n        startOffset--;\n        ctxChars++;\n        if (content[startOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      ctxChars = 0;\n      ctxLines = 0;\n      while (ctxChars < maxChars && endOffset < content.length - 1) {\n        endOffset++;\n        ctxChars++;\n        if (content[endOffset] == '\\n') {\n          if (++ctxLines == maxLines) {\n            break;\n          }\n        }\n      }\n\n      return {\n        before: content.substring(startOffset, this.offset),\n        after: content.substring(this.offset, endOffset + 1),\n      };\n    }\n\n    return null;\n  }\n}\n\nexport class ParseSourceFile {\n  constructor(public content: string, public url: string) {}\n}\n\nexport class ParseSourceSpan {\n  constructor(\n      public start: ParseLocation, public end: ParseLocation, public details: string|null = null) {}\n\n  toString(): string {\n    return this.start.file.content.substring(this.start.offset, this.end.offset);\n  }\n}\n\nexport const EMPTY_PARSE_LOCATION = new ParseLocation(new ParseSourceFile('', ''), 0, 0, 0);\nexport const EMPTY_SOURCE_SPAN = new ParseSourceSpan(EMPTY_PARSE_LOCATION, EMPTY_PARSE_LOCATION);\n\nexport enum ParseErrorLevel {\n  WARNING,\n  ERROR,\n}\n\nexport class ParseError {\n  constructor(\n      public span: ParseSourceSpan, public msg: string,\n      public level: ParseErrorLevel = ParseErrorLevel.ERROR) {}\n\n  contextualMessage(): string {\n    const ctx = this.span.start.getContext(100, 3);\n    return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\n                 this.msg;\n  }\n\n  toString(): string {\n    const details = this.span.details ? `, ${this.span.details}` : '';\n    return `${this.contextualMessage()}: ${this.span.start}${details}`;\n  }\n}\n\nexport function typeSourceSpan(kind: string, type: CompileIdentifierMetadata): ParseSourceSpan {\n  const moduleUrl = identifierModuleUrl(type);\n  const sourceFileName = moduleUrl != null ? `in ${kind} ${identifierName(type)} in ${moduleUrl}` :\n                                             `in ${kind} ${identifierName(type)}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n      new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\nexport function r3JitTypeSourceSpan(\n    kind: string, typeName: string, sourceUrl: string): ParseSourceSpan {\n  const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\n  const sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(\n      new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {AST, BindingType, BoundElementProperty, ParsedEvent, ParsedEventType} from '../expression_parser/ast';\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit<Result>(visitor: Visitor<Result>): Result;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitText(this); }\n}\n\nexport class BoundText implements Node {\n  constructor(public value: AST, public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitBoundText(this); }\n}\n\nexport class TextAttribute implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      public valueSpan?: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitTextAttribute(this); }\n}\n\nexport class BoundAttribute implements Node {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: AST, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      public valueSpan?: ParseSourceSpan, public i18n?: I18nMeta) {}\n\n  static fromBoundElementProperty(prop: BoundElementProperty, i18n?: I18nMeta) {\n    return new BoundAttribute(\n        prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan,\n        prop.valueSpan, i18n);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitBoundAttribute(this); }\n}\n\nexport class BoundEvent implements Node {\n  constructor(\n      public name: string, public type: ParsedEventType, public handler: AST,\n      public target: string|null, public phase: string|null, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan) {}\n\n  static fromParsedEvent(event: ParsedEvent) {\n    const target: string|null = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase: string|null =\n        event.type === ParsedEventType.Animation ? event.targetOrPhase : null;\n    return new BoundEvent(\n        event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan);\n  }\n\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitBoundEvent(this); }\n}\n\nexport class Element implements Node {\n  constructor(\n      public name: string, public attributes: TextAttribute[], public inputs: BoundAttribute[],\n      public outputs: BoundEvent[], public children: Node[], public references: Reference[],\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan|null,\n      public endSourceSpan: ParseSourceSpan|null, public i18n?: I18nMeta) {\n    // If the element is empty then the source span should include any closing tag\n    if (children.length === 0 && startSourceSpan && endSourceSpan) {\n      this.sourceSpan = new ParseSourceSpan(sourceSpan.start, endSourceSpan.end);\n    }\n  }\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitElement(this); }\n}\n\nexport class Template implements Node {\n  constructor(\n      public tagName: string, public attributes: TextAttribute[], public inputs: BoundAttribute[],\n      public outputs: BoundEvent[], public templateAttrs: (BoundAttribute|TextAttribute)[],\n      public children: Node[], public references: Reference[], public variables: Variable[],\n      public sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan|null,\n      public endSourceSpan: ParseSourceSpan|null, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitTemplate(this); }\n}\n\nexport class Content implements Node {\n  constructor(\n      public selector: string, public attributes: TextAttribute[],\n      public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitContent(this); }\n}\n\nexport class Variable implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      public valueSpan?: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitVariable(this); }\n}\n\nexport class Reference implements Node {\n  constructor(\n      public name: string, public value: string, public sourceSpan: ParseSourceSpan,\n      public valueSpan?: ParseSourceSpan) {}\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitReference(this); }\n}\n\nexport class Icu implements Node {\n  constructor(\n      public vars: {[name: string]: BoundText},\n      public placeholders: {[name: string]: Text | BoundText}, public sourceSpan: ParseSourceSpan,\n      public i18n?: I18nMeta) {}\n  visit<Result>(visitor: Visitor<Result>): Result { return visitor.visitIcu(this); }\n}\n\nexport interface Visitor<Result = any> {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node): Result;\n\n  visitElement(element: Element): Result;\n  visitTemplate(template: Template): Result;\n  visitContent(content: Content): Result;\n  visitVariable(variable: Variable): Result;\n  visitReference(reference: Reference): Result;\n  visitTextAttribute(attribute: TextAttribute): Result;\n  visitBoundAttribute(attribute: BoundAttribute): Result;\n  visitBoundEvent(attribute: BoundEvent): Result;\n  visitText(text: Text): Result;\n  visitBoundText(text: BoundText): Result;\n  visitIcu(icu: Icu): Result;\n}\n\nexport class NullVisitor implements Visitor<void> {\n  visitElement(element: Element): void {}\n  visitTemplate(template: Template): void {}\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\nexport class RecursiveVisitor implements Visitor<void> {\n  visitElement(element: Element): void {\n    visitAll(this, element.attributes);\n    visitAll(this, element.children);\n    visitAll(this, element.references);\n  }\n  visitTemplate(template: Template): void {\n    visitAll(this, template.attributes);\n    visitAll(this, template.children);\n    visitAll(this, template.references);\n    visitAll(this, template.variables);\n  }\n  visitContent(content: Content): void {}\n  visitVariable(variable: Variable): void {}\n  visitReference(reference: Reference): void {}\n  visitTextAttribute(attribute: TextAttribute): void {}\n  visitBoundAttribute(attribute: BoundAttribute): void {}\n  visitBoundEvent(attribute: BoundEvent): void {}\n  visitText(text: Text): void {}\n  visitBoundText(text: BoundText): void {}\n  visitIcu(icu: Icu): void {}\n}\n\nexport class TransformVisitor implements Visitor<Node> {\n  visitElement(element: Element): Node {\n    const newAttributes = transformAll(this, element.attributes);\n    const newInputs = transformAll(this, element.inputs);\n    const newOutputs = transformAll(this, element.outputs);\n    const newChildren = transformAll(this, element.children);\n    const newReferences = transformAll(this, element.references);\n    if (newAttributes != element.attributes || newInputs != element.inputs ||\n        newOutputs != element.outputs || newChildren != element.children ||\n        newReferences != element.references) {\n      return new Element(\n          element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences,\n          element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    }\n    return element;\n  }\n\n  visitTemplate(template: Template): Node {\n    const newAttributes = transformAll(this, template.attributes);\n    const newInputs = transformAll(this, template.inputs);\n    const newOutputs = transformAll(this, template.outputs);\n    const newTemplateAttrs = transformAll(this, template.templateAttrs);\n    const newChildren = transformAll(this, template.children);\n    const newReferences = transformAll(this, template.references);\n    const newVariables = transformAll(this, template.variables);\n    if (newAttributes != template.attributes || newInputs != template.inputs ||\n        newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs ||\n        newChildren != template.children || newReferences != template.references ||\n        newVariables != template.variables) {\n      return new Template(\n          template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren,\n          newReferences, newVariables, template.sourceSpan, template.startSourceSpan,\n          template.endSourceSpan);\n    }\n    return template;\n  }\n\n  visitContent(content: Content): Node { return content; }\n\n  visitVariable(variable: Variable): Node { return variable; }\n  visitReference(reference: Reference): Node { return reference; }\n  visitTextAttribute(attribute: TextAttribute): Node { return attribute; }\n  visitBoundAttribute(attribute: BoundAttribute): Node { return attribute; }\n  visitBoundEvent(attribute: BoundEvent): Node { return attribute; }\n  visitText(text: Text): Node { return text; }\n  visitBoundText(text: BoundText): Node { return text; }\n  visitIcu(icu: Icu): Node { return icu; }\n}\n\nexport function visitAll<Result>(visitor: Visitor<Result>, nodes: Node[]): Result[] {\n  const result: Result[] = [];\n  if (visitor.visit) {\n    for (const node of nodes) {\n      const newNode = visitor.visit(node) || node.visit(visitor);\n    }\n  } else {\n    for (const node of nodes) {\n      const newNode = node.visit(visitor);\n      if (newNode) {\n        result.push(newNode);\n      }\n    }\n  }\n  return result;\n}\n\nexport function transformAll<Result extends Node>(\n    visitor: Visitor<Node>, nodes: Result[]): Result[] {\n  const result: Result[] = [];\n  let changed = false;\n  for (const node of nodes) {\n    const newNode = node.visit(visitor);\n    if (newNode) {\n      result.push(newNode as Result);\n    }\n    changed = changed || newNode != node;\n  }\n  return changed ? result : nodes;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class Message {\n  sources: MessageSpan[];\n  id: string = this.customId;\n  /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n  legacyIds: string[] = [];\n\n  /**\n   * @param nodes message AST\n   * @param placeholders maps placeholder names to static content\n   * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n   * @param meaning\n   * @param description\n   * @param customId\n   */\n  constructor(\n      public nodes: Node[], public placeholders: {[phName: string]: string},\n      public placeholderToMessage: {[phName: string]: Message}, public meaning: string,\n      public description: string, public customId: string) {\n    if (nodes.length) {\n      this.sources = [{\n        filePath: nodes[0].sourceSpan.start.file.url,\n        startLine: nodes[0].sourceSpan.start.line + 1,\n        startCol: nodes[0].sourceSpan.start.col + 1,\n        endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n        endCol: nodes[0].sourceSpan.start.col + 1\n      }];\n    } else {\n      this.sources = [];\n    }\n  }\n}\n\n// line and columns indexes are 1 based\nexport interface MessageSpan {\n  filePath: string;\n  startLine: number;\n  startCol: number;\n  endLine: number;\n  endCol: number;\n}\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context?: any): any;\n}\n\nexport class Text implements Node {\n  constructor(public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any { return visitor.visitText(this, context); }\n}\n\n// TODO(vicb): do we really need this node (vs an array) ?\nexport class Container implements Node {\n  constructor(public children: Node[], public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any { return visitor.visitContainer(this, context); }\n}\n\nexport class Icu implements Node {\n  // TODO(issue/24571): remove '!'.\n  public expressionPlaceholder !: string;\n  constructor(\n      public expression: string, public type: string, public cases: {[k: string]: Node},\n      public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any { return visitor.visitIcu(this, context); }\n}\n\nexport class TagPlaceholder implements Node {\n  constructor(\n      public tag: string, public attrs: {[k: string]: string}, public startName: string,\n      public closeName: string, public children: Node[], public isVoid: boolean,\n      public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any { return visitor.visitTagPlaceholder(this, context); }\n}\n\nexport class Placeholder implements Node {\n  constructor(public value: string, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any { return visitor.visitPlaceholder(this, context); }\n}\n\nexport class IcuPlaceholder implements Node {\n  /** Used to capture a message computed from a previous processing pass (see `setI18nRefs()`). */\n  previousMessage?: Message;\n  constructor(public value: Icu, public name: string, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context?: any): any { return visitor.visitIcuPlaceholder(this, context); }\n}\n\n/**\n * Each HTML node that is affect by an i18n tag will also have an `i18n` property that is of type\n * `I18nMeta`.\n * This information is either a `Message`, which indicates it is the root of an i18n message, or a\n * `Node`, which indicates is it part of a containing `Message`.\n */\nexport type I18nMeta = Message | Node;\n\nexport interface Visitor {\n  visitText(text: Text, context?: any): any;\n  visitContainer(container: Container, context?: any): any;\n  visitIcu(icu: Icu, context?: any): any;\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any;\n  visitPlaceholder(ph: Placeholder, context?: any): any;\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any;\n}\n\n// Clone the AST\nexport class CloneVisitor implements Visitor {\n  visitText(text: Text, context?: any): Text { return new Text(text.value, text.sourceSpan); }\n\n  visitContainer(container: Container, context?: any): Container {\n    const children = container.children.map(n => n.visit(this, context));\n    return new Container(children, container.sourceSpan);\n  }\n\n  visitIcu(icu: Icu, context?: any): Icu {\n    const cases: {[k: string]: Node} = {};\n    Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\n    const msg = new Icu(icu.expression, icu.type, cases, icu.sourceSpan);\n    msg.expressionPlaceholder = icu.expressionPlaceholder;\n    return msg;\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): TagPlaceholder {\n    const children = ph.children.map(n => n.visit(this, context));\n    return new TagPlaceholder(\n        ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): Placeholder {\n    return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n  }\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): IcuPlaceholder {\n    return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n  }\n}\n\n// Visit all the nodes recursively\nexport class RecurseVisitor implements Visitor {\n  visitText(text: Text, context?: any): any {}\n\n  visitContainer(container: Container, context?: any): any {\n    container.children.forEach(child => child.visit(this));\n  }\n\n  visitIcu(icu: Icu, context?: any): any {\n    Object.keys(icu.cases).forEach(k => { icu.cases[k].visit(this); });\n  }\n\n  visitTagPlaceholder(ph: TagPlaceholder, context?: any): any {\n    ph.children.forEach(child => child.visit(this));\n  }\n\n  visitPlaceholder(ph: Placeholder, context?: any): any {}\n\n  visitIcuPlaceholder(ph: IcuPlaceholder, context?: any): any {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {newArray, utf8Encode} from '../util';\n\nimport * as i18n from './i18n_ast';\n\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\nexport function digest(message: i18n.Message): string {\n  return message.id || computeDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF1 digest.\n */\nexport function computeDigest(message: i18n.Message): string {\n  return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\n}\n\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\nexport function decimalDigest(message: i18n.Message): string {\n  return message.id || computeDecimalDigest(message);\n}\n\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\nexport function computeDecimalDigest(message: i18n.Message): string {\n  const visitor = new _SerializerIgnoreIcuExpVisitor();\n  const parts = message.nodes.map(a => a.visit(visitor, null));\n  return computeMsgId(parts.join(''), message.meaning);\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\nclass _SerializerVisitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context: any): any { return text.value; }\n\n  visitContainer(container: i18n.Container, context: any): any {\n    return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\n  }\n\n  visitIcu(icu: i18n.Icu, context: any): any {\n    const strCases =\n        Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context: any): any {\n    return ph.isVoid ?\n        `<ph tag name=\"${ph.startName}\"/>` :\n        `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context: any): any {\n    return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\n  }\n}\n\nconst serializerVisitor = new _SerializerVisitor();\n\nexport function serializeNodes(nodes: i18n.Node[]): string[] {\n  return nodes.map(a => a.visit(serializerVisitor, null));\n}\n\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\n  visitIcu(icu: i18n.Icu, context: any): any {\n    let strCases = Object.keys(icu.cases).map((k: string) => `${k} {${icu.cases[k].visit(this)}}`);\n    // Do not take the expression into account\n    return `{${icu.type}, ${strCases.join(', ')}}`;\n  }\n}\n\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\nexport function sha1(str: string): string {\n  const utf8 = utf8Encode(str);\n  const words32 = stringToWords32(utf8, Endian.Big);\n  const len = utf8.length * 8;\n\n  const w = newArray(80);\n  let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;\n\n  words32[len >> 5] |= 0x80 << (24 - len % 32);\n  words32[((len + 64 >> 9) << 4) + 15] = len;\n\n  for (let i = 0; i < words32.length; i += 16) {\n    const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;\n\n    for (let j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      const fkVal = fk(j, b, c, d);\n      const f = fkVal[0];\n      const k = fkVal[1];\n      const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n\n  return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n}\n\nfunction fk(index: number, b: number, c: number, d: number): [number, number] {\n  if (index < 20) {\n    return [(b & c) | (~b & d), 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\nexport function fingerprint(str: string): [number, number] {\n  const utf8 = utf8Encode(str);\n\n  let hi = hash32(utf8, 0);\n  let lo = hash32(utf8, 102072);\n\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return [hi, lo];\n}\n\nexport function computeMsgId(msg: string, meaning: string = ''): string {\n  let msgFingerprint = fingerprint(msg);\n\n  if (meaning) {\n    const meaningFingerprint = fingerprint(meaning);\n    msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n  }\n\n  const hi = msgFingerprint[0];\n  const lo = msgFingerprint[1];\n\n  return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n}\n\nfunction hash32(str: string, c: number): number {\n  let a = 0x9e3779b9, b = 0x9e3779b9;\n  let i: number;\n\n  const len = str.length;\n\n  for (i = 0; i + 12 <= len; i += 12) {\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    c = add32(c, wordAt(str, i + 8, Endian.Little));\n    const res = mix(a, b, c);\n    a = res[0], b = res[1], c = res[2];\n  }\n\n  a = add32(a, wordAt(str, i, Endian.Little));\n  b = add32(b, wordAt(str, i + 4, Endian.Little));\n  // the first byte of c is reserved for the length\n  c = add32(c, len);\n  c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n\n  return mix(a, b, c)[2];\n}\n\n// clang-format off\nfunction mix(a: number, b: number, c: number): [number, number, number] {\n  a = sub32(a, b); a = sub32(a, c); a ^= c >>> 13;\n  b = sub32(b, c); b = sub32(b, a); b ^= a << 8;\n  c = sub32(c, a); c = sub32(c, b); c ^= b >>> 13;\n  a = sub32(a, b); a = sub32(a, c); a ^= c >>> 12;\n  b = sub32(b, c); b = sub32(b, a); b ^= a << 16;\n  c = sub32(c, a); c = sub32(c, b); c ^= b >>> 5;\n  a = sub32(a, b); a = sub32(a, c); a ^= c >>> 3;\n  b = sub32(b, c); b = sub32(b, a); b ^= a << 10;\n  c = sub32(c, a); c = sub32(c, b); c ^= b >>> 15;\n  return [a, b, c];\n}\n// clang-format on\n\n// Utils\n\nenum Endian {\n  Little,\n  Big,\n}\n\nfunction add32(a: number, b: number): number {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a: number, b: number): [number, number] {\n  const low = (a & 0xffff) + (b & 0xffff);\n  const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, (high << 16) | (low & 0xffff)];\n}\n\nfunction add64(a: [number, number], b: [number, number]): [number, number] {\n  const ah = a[0], al = a[1];\n  const bh = b[0], bl = b[1];\n  const result = add32to64(al, bl);\n  const carry = result[0];\n  const l = result[1];\n  const h = add32(add32(ah, bh), carry);\n  return [h, l];\n}\n\nfunction sub32(a: number, b: number): number {\n  const low = (a & 0xffff) - (b & 0xffff);\n  const high = (a >> 16) - (b >> 16) + (low >> 16);\n  return (high << 16) | (low & 0xffff);\n}\n\n// Rotate a 32b number left `count` position\nfunction rol32(a: number, count: number): number {\n  return (a << count) | (a >>> (32 - count));\n}\n\n// Rotate a 64b number left `count` position\nfunction rol64(num: [number, number], count: number): [number, number] {\n  const hi = num[0], lo = num[1];\n  const h = (hi << count) | (lo >>> (32 - count));\n  const l = (lo << count) | (hi >>> (32 - count));\n  return [h, l];\n}\n\nfunction stringToWords32(str: string, endian: Endian): number[] {\n  const size = (str.length + 3) >>> 2;\n  const words32 = [];\n\n  for (let i = 0; i < size; i++) {\n    words32[i] = wordAt(str, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(str: string, index: number): number {\n  return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\n\nfunction wordAt(str: string, index: number, endian: Endian): number {\n  let word = 0;\n  if (endian === Endian.Big) {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(str, index + i) << (24 - 8 * i);\n    }\n  } else {\n    for (let i = 0; i < 4; i++) {\n      word += byteAt(str, index + i) << 8 * i;\n    }\n  }\n  return word;\n}\n\nfunction words32ToByteString(words32: number[]): string {\n  return words32.reduce((str, word) => str + word32ToByteString(word), '');\n}\n\nfunction word32ToByteString(word: number): string {\n  let str = '';\n  for (let i = 0; i < 4; i++) {\n    str += String.fromCharCode((word >>> 8 * (3 - i)) & 0xff);\n  }\n  return str;\n}\n\nfunction byteStringToHexString(str: string): string {\n  let hex: string = '';\n  for (let i = 0; i < str.length; i++) {\n    const b = byteAt(str, i);\n    hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n  }\n  return hex.toLowerCase();\n}\n\n// based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)\nfunction byteStringToDecString(str: string): string {\n  let decimal = '';\n  let toThePower = '1';\n\n  for (let i = str.length - 1; i >= 0; i--) {\n    decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n    toThePower = numberTimesBigInt(256, toThePower);\n  }\n\n  return decimal.split('').reverse().join('');\n}\n\n// x and y decimal, lowest significant digit first\nfunction addBigInt(x: string, y: string): string {\n  let sum = '';\n  const len = Math.max(x.length, y.length);\n  for (let i = 0, carry = 0; i < len || carry; i++) {\n    const tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n    if (tmpSum >= 10) {\n      carry = 1;\n      sum += tmpSum - 10;\n    } else {\n      carry = 0;\n      sum += tmpSum;\n    }\n  }\n\n  return sum;\n}\n\nfunction numberTimesBigInt(num: number, b: string): string {\n  let product = '';\n  let bToThePower = b;\n  for (; num !== 0; num = num >>> 1) {\n    if (num & 1) product = addBigInt(product, bToThePower);\n    bToThePower = addBigInt(bToThePower, bToThePower);\n  }\n  return product;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as i18n from '../i18n_ast';\n\nexport abstract class Serializer {\n  // - The `placeholders` and `placeholderToMessage` properties are irrelevant in the input messages\n  // - The `id` contains the message id that the serializer is expected to use\n  // - Placeholder names are already map to public names using the provided mapper\n  abstract write(messages: i18n.Message[], locale: string|null): string;\n\n  abstract load(content: string, url: string):\n      {locale: string | null, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}};\n\n  abstract digest(message: i18n.Message): string;\n\n  // Creates a name mapper, see `PlaceholderMapper`\n  // Returning `null` means that no name mapping is used.\n  createNameMapper(message: i18n.Message): PlaceholderMapper|null { return null; }\n}\n\n/**\n * A `PlaceholderMapper` converts placeholder names from internal to serialized representation and\n * back.\n *\n * It should be used for serialization format that put constraints on the placeholder names.\n */\nexport interface PlaceholderMapper {\n  toPublicName(internalName: string): string|null;\n\n  toInternalName(publicName: string): string|null;\n}\n\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\nexport class SimplePlaceholderMapper extends i18n.RecurseVisitor implements PlaceholderMapper {\n  private internalToPublic: {[k: string]: string} = {};\n  private publicToNextId: {[k: string]: number} = {};\n  private publicToInternal: {[k: string]: string} = {};\n\n  // create a mapping from the message\n  constructor(message: i18n.Message, private mapName: (name: string) => string) {\n    super();\n    message.nodes.forEach(node => node.visit(this));\n  }\n\n  toPublicName(internalName: string): string|null {\n    return this.internalToPublic.hasOwnProperty(internalName) ?\n        this.internalToPublic[internalName] :\n        null;\n  }\n\n  toInternalName(publicName: string): string|null {\n    return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\n                                                              null;\n  }\n\n  visitText(text: i18n.Text, context?: any): any { return null; }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.startName);\n    super.visitTagPlaceholder(ph, context);\n    this.visitPlaceholderName(ph.closeName);\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): any { this.visitPlaceholderName(ph.name); }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): any {\n    this.visitPlaceholderName(ph.name);\n  }\n\n  // XMB placeholders could only contains A-Z, 0-9 and _\n  private visitPlaceholderName(internalName: string): void {\n    if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n      return;\n    }\n\n    let publicName = this.mapName(internalName);\n\n    if (this.publicToInternal.hasOwnProperty(publicName)) {\n      // Create a new XMB when it has already been used\n      const nextId = this.publicToNextId[publicName];\n      this.publicToNextId[publicName] = nextId + 1;\n      publicName = `${publicName}_${nextId}`;\n    } else {\n      this.publicToNextId[publicName] = 1;\n    }\n\n    this.internalToPublic[internalName] = publicName;\n    this.publicToInternal[publicName] = internalName;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface IVisitor {\n  visitTag(tag: Tag): any;\n  visitText(text: Text): any;\n  visitDeclaration(decl: Declaration): any;\n  visitDoctype(doctype: Doctype): any;\n}\n\nclass _Visitor implements IVisitor {\n  visitTag(tag: Tag): string {\n    const strAttrs = this._serializeAttributes(tag.attrs);\n\n    if (tag.children.length == 0) {\n      return `<${tag.name}${strAttrs}/>`;\n    }\n\n    const strChildren = tag.children.map(node => node.visit(this));\n    return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\n  }\n\n  visitText(text: Text): string { return text.value; }\n\n  visitDeclaration(decl: Declaration): string {\n    return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\n  }\n\n  private _serializeAttributes(attrs: {[k: string]: string}) {\n    const strAttrs = Object.keys(attrs).map((name: string) => `${name}=\"${attrs[name]}\"`).join(' ');\n    return strAttrs.length > 0 ? ' ' + strAttrs : '';\n  }\n\n  visitDoctype(doctype: Doctype): any {\n    return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\n  }\n}\n\nconst _visitor = new _Visitor();\n\nexport function serialize(nodes: Node[]): string {\n  return nodes.map((node: Node): string => node.visit(_visitor)).join('');\n}\n\nexport interface Node { visit(visitor: IVisitor): any; }\n\nexport class Declaration implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(unescapedAttrs: {[k: string]: string}) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any { return visitor.visitDeclaration(this); }\n}\n\nexport class Doctype implements Node {\n  constructor(public rootTag: string, public dtd: string) {}\n\n  visit(visitor: IVisitor): any { return visitor.visitDoctype(this); }\n}\n\nexport class Tag implements Node {\n  public attrs: {[k: string]: string} = {};\n\n  constructor(\n      public name: string, unescapedAttrs: {[k: string]: string} = {},\n      public children: Node[] = []) {\n    Object.keys(unescapedAttrs).forEach((k: string) => {\n      this.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  visit(visitor: IVisitor): any { return visitor.visitTag(this); }\n}\n\nexport class Text implements Node {\n  value: string;\n  constructor(unescapedValue: string) { this.value = escapeXml(unescapedValue); }\n\n  visit(visitor: IVisitor): any { return visitor.visitText(this); }\n}\n\nexport class CR extends Text {\n  constructor(ws: number = 0) { super(`\\n${new Array(ws + 1).join(' ')}`); }\n}\n\nconst _ESCAPED_CHARS: [RegExp, string][] = [\n  [/&/g, '&amp;'],\n  [/\"/g, '&quot;'],\n  [/'/g, '&apos;'],\n  [/</g, '&lt;'],\n  [/>/g, '&gt;'],\n];\n\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\nexport function escapeXml(text: string): string {\n  return _ESCAPED_CHARS.reduce(\n      (text: string, entry: [RegExp, string]) => text.replace(entry[0], entry[1]), text);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {decimalDigest} from '../digest';\nimport * as i18n from '../i18n_ast';\n\nimport {PlaceholderMapper, Serializer, SimplePlaceholderMapper} from './serializer';\nimport * as xml from './xml_helper';\n\nconst _MESSAGES_TAG = 'messagebundle';\nconst _MESSAGE_TAG = 'msg';\nconst _PLACEHOLDER_TAG = 'ph';\nconst _EXAMPLE_TAG = 'ex';\nconst _SOURCE_TAG = 'source';\n\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\n<!ATTLIST messagebundle class CDATA #IMPLIED>\n\n<!ELEMENT msg (#PCDATA|ph|source)*>\n<!ATTLIST msg id CDATA #IMPLIED>\n<!ATTLIST msg seq CDATA #IMPLIED>\n<!ATTLIST msg name CDATA #IMPLIED>\n<!ATTLIST msg desc CDATA #IMPLIED>\n<!ATTLIST msg meaning CDATA #IMPLIED>\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\n<!ATTLIST msg xml:space (default|preserve) \"default\">\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\n\n<!ELEMENT source (#PCDATA)>\n\n<!ELEMENT ph (#PCDATA|ex)*>\n<!ATTLIST ph name CDATA #REQUIRED>\n\n<!ELEMENT ex (#PCDATA)>`;\n\nexport class Xmb extends Serializer {\n  write(messages: i18n.Message[], locale: string|null): string {\n    const exampleVisitor = new ExampleVisitor();\n    const visitor = new _Visitor();\n    let rootNode = new xml.Tag(_MESSAGES_TAG);\n\n    messages.forEach(message => {\n      const attrs: {[k: string]: string} = {id: message.id};\n\n      if (message.description) {\n        attrs['desc'] = message.description;\n      }\n\n      if (message.meaning) {\n        attrs['meaning'] = message.meaning;\n      }\n\n      let sourceTags: xml.Tag[] = [];\n      message.sources.forEach((source: i18n.MessageSpan) => {\n        sourceTags.push(new xml.Tag(_SOURCE_TAG, {}, [\n          new xml.Text(\n              `${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)\n        ]));\n      });\n\n      rootNode.children.push(\n          new xml.CR(2),\n          new xml.Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\n    });\n\n    rootNode.children.push(new xml.CR());\n\n    return xml.serialize([\n      new xml.Declaration({version: '1.0', encoding: 'UTF-8'}),\n      new xml.CR(),\n      new xml.Doctype(_MESSAGES_TAG, _DOCTYPE),\n      new xml.CR(),\n      exampleVisitor.addDefaultExamples(rootNode),\n      new xml.CR(),\n    ]);\n  }\n\n  load(content: string, url: string):\n      {locale: string, i18nNodesByMsgId: {[msgId: string]: i18n.Node[]}} {\n    throw new Error('Unsupported');\n  }\n\n  digest(message: i18n.Message): string { return digest(message); }\n\n\n  createNameMapper(message: i18n.Message): PlaceholderMapper {\n    return new SimplePlaceholderMapper(message, toPublicName);\n  }\n}\n\nclass _Visitor implements i18n.Visitor {\n  visitText(text: i18n.Text, context?: any): xml.Node[] { return [new xml.Text(text.value)]; }\n\n  visitContainer(container: i18n.Container, context: any): xml.Node[] {\n    const nodes: xml.Node[] = [];\n    container.children.forEach((node: i18n.Node) => nodes.push(...node.visit(this)));\n    return nodes;\n  }\n\n  visitIcu(icu: i18n.Icu, context?: any): xml.Node[] {\n    const nodes = [new xml.Text(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\n\n    Object.keys(icu.cases).forEach((c: string) => {\n      nodes.push(new xml.Text(`${c} {`), ...icu.cases[c].visit(this), new xml.Text(`} `));\n    });\n\n    nodes.push(new xml.Text(`}`));\n\n    return nodes;\n  }\n\n  visitTagPlaceholder(ph: i18n.TagPlaceholder, context?: any): xml.Node[] {\n    const startTagAsText = new xml.Text(`<${ph.tag}>`);\n    const startEx = new xml.Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const startTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {name: ph.startName}, [startEx, startTagAsText]);\n    if (ph.isVoid) {\n      // void tags have no children nor closing tags\n      return [startTagPh];\n    }\n\n    const closeTagAsText = new xml.Text(`</${ph.tag}>`);\n    const closeEx = new xml.Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\n    // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n    const closeTagPh =\n        new xml.Tag(_PLACEHOLDER_TAG, {name: ph.closeName}, [closeEx, closeTagAsText]);\n\n    return [startTagPh, ...this.serialize(ph.children), closeTagPh];\n  }\n\n  visitPlaceholder(ph: i18n.Placeholder, context?: any): xml.Node[] {\n    const interpolationAsText = new xml.Text(`{{${ph.value}}}`);\n    // Example tag needs to be not-empty for TC.\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, interpolationAsText])\n    ];\n  }\n\n  visitIcuPlaceholder(ph: i18n.IcuPlaceholder, context?: any): xml.Node[] {\n    const icuExpression = ph.value.expression;\n    const icuType = ph.value.type;\n    const icuCases = Object.keys(ph.value.cases).map((value: string) => value + ' {...}').join(' ');\n    const icuAsText = new xml.Text(`{${icuExpression}, ${icuType}, ${icuCases}}`);\n    const exTag = new xml.Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n    return [\n      // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new xml.Tag(_PLACEHOLDER_TAG, {name: ph.name}, [exTag, icuAsText])\n    ];\n  }\n\n  serialize(nodes: i18n.Node[]): xml.Node[] {\n    return [].concat(...nodes.map(node => node.visit(this)));\n  }\n}\n\nexport function digest(message: i18n.Message): string {\n  return decimalDigest(message);\n}\n\n// TC requires at least one non-empty example on placeholders\nclass ExampleVisitor implements xml.IVisitor {\n  addDefaultExamples(node: xml.Node): xml.Node {\n    node.visit(this);\n    return node;\n  }\n\n  visitTag(tag: xml.Tag): void {\n    if (tag.name === _PLACEHOLDER_TAG) {\n      if (!tag.children || tag.children.length == 0) {\n        const exText = new xml.Text(tag.attrs['name'] || '...');\n        tag.children = [new xml.Tag(_EXAMPLE_TAG, {}, [exText])];\n      }\n    } else if (tag.children) {\n      tag.children.forEach(node => node.visit(this));\n    }\n  }\n\n  visitText(text: xml.Text): void {}\n  visitDeclaration(decl: xml.Declaration): void {}\n  visitDoctype(doctype: xml.Doctype): void {}\n}\n\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\nexport function toPublicName(internalName: string): string {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport * as i18n from '../../../i18n/i18n_ast';\nimport {toPublicName} from '../../../i18n/serializers/xmb';\nimport * as html from '../../../ml_parser/ast';\nimport * as o from '../../../output/output_ast';\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\nconst CLOSURE_TRANSLATION_PREFIX = 'MSG_';\n\n/* Prefix for non-`goog.getMsg` i18n-related vars */\nexport const TRANSLATION_PREFIX = 'I18N_';\n\n/** Name of the i18n attributes **/\nexport const I18N_ATTR = 'i18n';\nexport const I18N_ATTR_PREFIX = 'i18n-';\n\n/** Prefix of var expressions used in ICUs */\nexport const I18N_ICU_VAR_PREFIX = 'VAR_';\n\n/** Prefix of ICU expressions for post processing */\nexport const I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n\n/** Placeholder wrapper for i18n expressions **/\nexport const I18N_PLACEHOLDER_SYMBOL = 'ï¿½';\n\nexport function isI18nAttribute(name: string): boolean {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\n\nexport function isI18nRootNode(meta?: i18n.I18nMeta): meta is i18n.Message {\n  return meta instanceof i18n.Message;\n}\n\nexport function isSingleI18nIcu(meta?: i18n.I18nMeta): boolean {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof i18n.Icu;\n}\n\nexport function hasI18nAttrs(element: html.Element): boolean {\n  return element.attrs.some((attr: html.Attribute) => isI18nAttribute(attr.name));\n}\n\nexport function icuFromI18nMessage(message: i18n.Message) {\n  return message.nodes[0] as i18n.IcuPlaceholder;\n}\n\nexport function wrapI18nPlaceholder(content: string | number, contextId: number = 0): string {\n  const blockId = contextId > 0 ? `:${contextId}` : '';\n  return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;\n}\n\nexport function assembleI18nBoundString(\n    strings: string[], bindingStartIndex: number = 0, contextId: number = 0): string {\n  if (!strings.length) return '';\n  let acc = '';\n  const lastIdx = strings.length - 1;\n  for (let i = 0; i < lastIdx; i++) {\n    acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;\n  }\n  acc += strings[lastIdx];\n  return acc;\n}\n\nexport function getSeqNumberGenerator(startsAt: number = 0): () => number {\n  let current = startsAt;\n  return () => current++;\n}\n\nexport function placeholdersToParams(placeholders: Map<string, string[]>):\n    {[name: string]: o.LiteralExpr} {\n  const params: {[name: string]: o.LiteralExpr} = {};\n  placeholders.forEach((values: string[], key: string) => {\n    params[key] = o.literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\n  });\n  return params;\n}\n\nexport function updatePlaceholderMap(map: Map<string, any[]>, name: string, ...values: any[]) {\n  const current = map.get(name) || [];\n  current.push(...values);\n  map.set(name, current);\n}\n\nexport function assembleBoundTextPlaceholders(\n    meta: i18n.I18nMeta, bindingStartIndex: number = 0, contextId: number = 0): Map<string, any[]> {\n  const startIdx = bindingStartIndex;\n  const placeholders = new Map<string, any>();\n  const node =\n      meta instanceof i18n.Message ? meta.nodes.find(node => node instanceof i18n.Container) : meta;\n  if (node) {\n    (node as i18n.Container)\n        .children\n        .filter((child: i18n.Node): child is i18n.Placeholder => child instanceof i18n.Placeholder)\n        .forEach((child: i18n.Placeholder, idx: number) => {\n          const content = wrapI18nPlaceholder(startIdx + idx, contextId);\n          updatePlaceholderMap(placeholders, child.name, content);\n        });\n  }\n  return placeholders;\n}\n\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\nexport function i18nFormatPlaceholderNames(\n    params: {[name: string]: o.Expression} = {}, useCamelCase: boolean) {\n  const _params: {[key: string]: o.Expression} = {};\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(\n        key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\n  }\n  return _params;\n}\n\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\nexport function formatI18nPlaceholderName(name: string, useCamelCase: boolean = true): string {\n  const publicName = toPublicName(name);\n  if (!useCamelCase) {\n    return publicName;\n  }\n  const chunks = publicName.split('_');\n  if (chunks.length === 1) {\n    // if no \"_\" found - just lowercase the value\n    return name.toLowerCase();\n  }\n  let postfix;\n  // eject last element if it's a number\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n  let raw = chunks.shift() !.toLowerCase();\n  if (chunks.length) {\n    raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\n  }\n  return postfix ? `${raw}_${postfix}` : raw;\n}\n\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\nexport function getTranslationConstPrefix(extra: string): string {\n  return `${CLOSURE_TRANSLATION_PREFIX}${extra}`.toUpperCase();\n}\n\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\nexport function declareI18nVariable(variable: o.ReadVarExpr): o.Statement {\n  return new o.DeclareVarStmt(\n      variable.name !, undefined, o.INFERRED_TYPE, null, variable.sourceSpan);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ConstantPool} from '../../constant_pool';\nimport {Interpolation} from '../../expression_parser/ast';\nimport * as o from '../../output/output_ast';\nimport {ParseSourceSpan} from '../../parse_util';\nimport {splitAtColon} from '../../util';\nimport * as t from '../r3_ast';\n\nimport {R3QueryMetadata} from './api';\nimport {isI18nAttribute} from './i18n/util';\n\n\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n\n/** Name of the temporary to use during data binding */\nexport const TEMPORARY_NAME = '_t';\n\n/** Name of the context parameter passed into a template function */\nexport const CONTEXT_NAME = 'ctx';\n\n/** Name of the RenderFlag passed into a template function */\nexport const RENDER_FLAGS = 'rf';\n\n/** The prefix reference variables */\nexport const REFERENCE_PREFIX = '_r';\n\n/** The name of the implicit context reference */\nexport const IMPLICIT_REFERENCE = '$implicit';\n\n/** Non bindable attribute name **/\nexport const NON_BINDABLE_ATTR = 'ngNonBindable';\n\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\nexport function temporaryAllocator(statements: o.Statement[], name: string): () => o.ReadVarExpr {\n  let temp: o.ReadVarExpr|null = null;\n  return () => {\n    if (!temp) {\n      statements.push(new o.DeclareVarStmt(TEMPORARY_NAME, undefined, o.DYNAMIC_TYPE));\n      temp = o.variable(name);\n    }\n    return temp;\n  };\n}\n\n\nexport function unsupported(this: void|Function, feature: string): never {\n  if (this) {\n    throw new Error(`Builder ${this.constructor.name} doesn't support ${feature} yet`);\n  }\n  throw new Error(`Feature ${feature} is not supported yet`);\n}\n\nexport function invalid<T>(this: t.Visitor, arg: o.Expression | o.Statement | t.Node): never {\n  throw new Error(\n      `Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\n}\n\nexport function asLiteral(value: any): o.Expression {\n  if (Array.isArray(value)) {\n    return o.literalArr(value.map(asLiteral));\n  }\n  return o.literal(value, o.INFERRED_TYPE);\n}\n\nexport function conditionallyCreateMapObjectLiteral(\n    keys: {[key: string]: string | string[]}, keepDeclared?: boolean): o.Expression|null {\n  if (Object.getOwnPropertyNames(keys).length > 0) {\n    return mapToExpression(keys, keepDeclared);\n  }\n  return null;\n}\n\nfunction mapToExpression(\n    map: {[key: string]: string | string[]}, keepDeclared?: boolean): o.Expression {\n  return o.literalMap(Object.getOwnPropertyNames(map).map(key => {\n    // canonical syntax: `dirProp: publicProp`\n    // if there is no `:`, use dirProp = elProp\n    const value = map[key];\n    let declaredName: string;\n    let publicName: string;\n    let minifiedName: string;\n    if (Array.isArray(value)) {\n      [publicName, declaredName] = value;\n    } else {\n      [declaredName, publicName] = splitAtColon(key, [key, value]);\n    }\n    minifiedName = declaredName;\n    return {\n      key: minifiedName,\n      // put quotes around keys that contain potentially unsafe characters\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: (keepDeclared && publicName !== declaredName) ?\n          o.literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\n          asLiteral(publicName)\n    };\n  }));\n}\n\n/**\n *  Remove trailing null nodes as they are implied.\n */\nexport function trimTrailingNulls(parameters: o.Expression[]): o.Expression[] {\n  while (o.isNull(parameters[parameters.length - 1])) {\n    parameters.pop();\n  }\n  return parameters;\n}\n\nexport function getQueryPredicate(\n    query: R3QueryMetadata, constantPool: ConstantPool): o.Expression {\n  if (Array.isArray(query.predicate)) {\n    let predicate: o.Expression[] = [];\n    query.predicate.forEach((selector: string): void => {\n      // Each item in predicates array may contain strings with comma-separated refs\n      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n      // as separate array entities\n      const selectors = selector.split(',').map(token => o.literal(token.trim()));\n      predicate.push(...selectors);\n    });\n    return constantPool.getConstLiteral(o.literalArr(predicate), true);\n  } else {\n    return query.predicate;\n  }\n}\n\nexport function noop() {}\n\nexport class DefinitionMap {\n  values: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  set(key: string, value: o.Expression|null): void {\n    if (value) {\n      this.values.push({key, value, quoted: false});\n    }\n  }\n\n  toLiteralMap(): o.LiteralMapExpr { return o.literalMap(this.values); }\n}\n\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\nexport function getAttrsForDirectiveMatching(elOrTpl: t.Element | t.Template):\n    {[name: string]: string} {\n  const attributesMap: {[name: string]: string} = {};\n\n\n  if (elOrTpl instanceof t.Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\n  } else {\n    elOrTpl.attributes.forEach(a => {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n\n    elOrTpl.inputs.forEach(i => { attributesMap[i.name] = ''; });\n    elOrTpl.outputs.forEach(o => { attributesMap[o.name] = ''; });\n  }\n\n  return attributesMap;\n}\n\n/** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */\nexport function chainedInstruction(\n    reference: o.ExternalReference, calls: o.Expression[][], span?: ParseSourceSpan | null) {\n  let expression = o.importExpr(reference, null, span) as o.Expression;\n\n  if (calls.length > 0) {\n    for (let i = 0; i < calls.length; i++) {\n      expression = expression.callFn(calls[i], span);\n    }\n  } else {\n    // Add a blank invocation, in case the `calls` array is empty.\n    expression = expression.callFn([], span);\n  }\n\n  return expression;\n}\n\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\nexport function getInterpolationArgsLength(interpolation: Interpolation) {\n  const {expressions, strings} = interpolation;\n  if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n    // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n    // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n    // `textInterpolate`.\n    return 1;\n  } else {\n    return expressions.length + strings.length;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StaticSymbol} from '../aot/static_symbol';\nimport {CompileTypeMetadata, tokenReference} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {InjectFlags} from '../core';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {Identifiers as R3} from '../render3/r3_identifiers';\nimport {OutputContext} from '../util';\n\nimport {R3Reference, typeWithParameters} from './util';\nimport {unsupported} from './view/util';\n\n\n\n/**\n * Metadata required by the factory generator to generate a `factory` function for a type.\n */\nexport interface R3ConstructorFactoryMetadata {\n  /**\n   * String name of the type being generated (used to name the factory function).\n   */\n  name: string;\n\n  /**\n   * An expression representing the interface type being constructed.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the constructor type, intended for use within a class definition\n   * itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /** Number of arguments for the `type`. */\n  typeArgumentCount: number;\n\n  /**\n   * Regardless of whether `fnOrClass` is a constructor function or a user-defined factory, it\n   * may have 0 or more parameters, which will be injected according to the `R3DependencyMetadata`\n   * for those parameters. If this is `null`, then the type's constructor is nonexistent and will\n   * be inherited from `fnOrClass` which is interpreted as the current type. If this is `'invalid'`,\n   * then one or more of the parameters wasn't resolvable and any attempt to use these deps will\n   * result in a runtime error.\n   */\n  deps: R3DependencyMetadata[]|'invalid'|null;\n\n  /**\n   * An expression for the function which will be used to inject dependencies. The API of this\n   * function could be different, and other options control how it will be invoked.\n   */\n  injectFn: o.ExternalReference;\n\n  /**\n   * Type of the target being created by the factory.\n   */\n  target: R3FactoryTarget;\n}\n\nexport enum R3FactoryDelegateType {\n  Class,\n  Function,\n  Factory,\n}\n\nexport interface R3DelegatedFactoryMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType.Factory;\n}\n\nexport interface R3DelegatedFnOrClassMetadata extends R3ConstructorFactoryMetadata {\n  delegate: o.Expression;\n  delegateType: R3FactoryDelegateType.Class|R3FactoryDelegateType.Function;\n  delegateDeps: R3DependencyMetadata[];\n}\n\nexport interface R3ExpressionFactoryMetadata extends R3ConstructorFactoryMetadata {\n  expression: o.Expression;\n}\n\nexport type R3FactoryMetadata = R3ConstructorFactoryMetadata | R3DelegatedFactoryMetadata |\n    R3DelegatedFnOrClassMetadata | R3ExpressionFactoryMetadata;\n\nexport enum R3FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\n/**\n * Resolved type of a dependency.\n *\n * Occasionally, dependencies will have special significance which is known statically. In that\n * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\n * should be generated specially (usually by calling a special injection function instead of the\n * standard one).\n */\nexport enum R3ResolvedDependencyType {\n  /**\n   * A normal token dependency.\n   */\n  Token = 0,\n\n  /**\n   * The dependency is for an attribute.\n   *\n   * The token expression is a string representing the attribute name.\n   */\n  Attribute = 1,\n\n  /**\n   * Injecting the `ChangeDetectorRef` token. Needs special handling when injected into a pipe.\n   */\n  ChangeDetectorRef = 2,\n\n  /**\n   * An invalid dependency (no token could be determined). An error should be thrown at runtime.\n   */\n  Invalid = 3,\n}\n\n/**\n * Metadata representing a single dependency to be injected into a constructor or function call.\n */\nexport interface R3DependencyMetadata {\n  /**\n   * An expression representing the token or value to be injected.\n   */\n  token: o.Expression;\n\n  /**\n   * An enum indicating whether this dependency has special meaning to Angular and needs to be\n   * injected specially.\n   */\n  resolved: R3ResolvedDependencyType;\n\n  /**\n   * Whether the dependency has an @Host qualifier.\n   */\n  host: boolean;\n\n  /**\n   * Whether the dependency has an @Optional qualifier.\n   */\n  optional: boolean;\n\n  /**\n   * Whether the dependency has an @Self qualifier.\n   */\n  self: boolean;\n\n  /**\n   * Whether the dependency has an @SkipSelf qualifier.\n   */\n  skipSelf: boolean;\n}\n\nexport interface R3FactoryFn {\n  factory: o.Expression;\n  statements: o.Statement[];\n  type: o.ExpressionType;\n}\n\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\nexport function compileFactoryFunction(meta: R3FactoryMetadata): R3FactoryFn {\n  const t = o.variable('t');\n  const statements: o.Statement[] = [];\n\n  // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n  const typeForCtor = !isDelegatedMetadata(meta) ?\n      new o.BinaryOperatorExpr(o.BinaryOperator.Or, t, meta.internalType) :\n      t;\n\n  let ctorExpr: o.Expression|null = null;\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new o.InstantiateExpr(\n          typeForCtor,\n          injectDependencies(meta.deps, meta.injectFn, meta.target === R3FactoryTarget.Pipe));\n    }\n  } else {\n    const baseFactory = o.variable(`Éµ${meta.name}_BaseFactory`);\n    const getInheritedFactory = o.importExpr(R3.getInheritedFactory);\n    const baseFactoryStmt =\n        baseFactory.set(getInheritedFactory.callFn([meta.internalType]))\n            .toDeclStmt(o.INFERRED_TYPE, [o.StmtModifier.Exported, o.StmtModifier.Final]);\n    statements.push(baseFactoryStmt);\n\n    // There is no constructor, use the base class' factory to construct typeForCtor.\n    ctorExpr = baseFactory.callFn([typeForCtor]);\n  }\n  const ctorExprFinal = ctorExpr;\n\n  const body: o.Statement[] = [];\n  let retExpr: o.Expression|null = null;\n\n  function makeConditionalFactory(nonCtorExpr: o.Expression): o.ReadVarExpr {\n    const r = o.variable('r');\n    body.push(r.set(o.NULL_EXPR).toDeclStmt());\n    let ctorStmt: o.Statement|null = null;\n    if (ctorExprFinal !== null) {\n      ctorStmt = r.set(ctorExprFinal).toStmt();\n    } else {\n      ctorStmt = o.importExpr(R3.invalidFactory).callFn([]).toStmt();\n    }\n    body.push(o.ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedMetadata(meta) && meta.delegateType === R3FactoryDelegateType.Factory) {\n    const delegateFactory = o.variable(`Éµ${meta.name}_BaseFactory`);\n    const getFactoryOf = o.importExpr(R3.getFactoryOf);\n    if (meta.delegate.isEquivalent(meta.internalType)) {\n      throw new Error(`Illegal state: compiling factory that delegates to itself`);\n    }\n    const delegateFactoryStmt =\n        delegateFactory.set(getFactoryOf.callFn([meta.delegate])).toDeclStmt(o.INFERRED_TYPE, [\n          o.StmtModifier.Exported, o.StmtModifier.Final\n        ]);\n\n    statements.push(delegateFactoryStmt);\n    retExpr = makeConditionalFactory(delegateFactory.callFn([]));\n  } else if (isDelegatedMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    const delegateArgs =\n        injectDependencies(meta.delegateDeps, meta.injectFn, meta.target === R3FactoryTarget.Pipe);\n    // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n    const factoryExpr = new (\n        meta.delegateType === R3FactoryDelegateType.Class ?\n            o.InstantiateExpr :\n            o.InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n\n  if (retExpr !== null) {\n    body.push(new o.ReturnStatement(retExpr));\n  } else {\n    body.push(o.importExpr(R3.invalidFactory).callFn([]).toStmt());\n  }\n\n  return {\n    factory: o.fn(\n        [new o.FnParam('t', o.DYNAMIC_TYPE)], body, o.INFERRED_TYPE, undefined,\n        `${meta.name}_Factory`),\n    statements,\n    type: o.expressionType(\n        o.importExpr(R3.FactoryDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]))\n  };\n}\n\nfunction injectDependencies(\n    deps: R3DependencyMetadata[], injectFn: o.ExternalReference, isPipe: boolean): o.Expression[] {\n  return deps.map((dep, index) => compileInjectDependency(dep, injectFn, isPipe, index));\n}\n\nfunction compileInjectDependency(\n    dep: R3DependencyMetadata, injectFn: o.ExternalReference, isPipe: boolean,\n    index: number): o.Expression {\n  // Interpret the dependency according to its resolved type.\n  switch (dep.resolved) {\n    case R3ResolvedDependencyType.Token:\n    case R3ResolvedDependencyType.ChangeDetectorRef:\n      // Build up the injection flags according to the metadata.\n      const flags = InjectFlags.Default | (dep.self ? InjectFlags.Self : 0) |\n          (dep.skipSelf ? InjectFlags.SkipSelf : 0) | (dep.host ? InjectFlags.Host : 0) |\n          (dep.optional ? InjectFlags.Optional : 0);\n\n      // If this dependency is optional or otherwise has non-default flags, then additional\n      // parameters describing how to inject the dependency must be passed to the inject function\n      // that's being used.\n      let flagsParam: o.LiteralExpr|null =\n          (flags !== InjectFlags.Default || dep.optional) ? o.literal(flags) : null;\n\n      // We have a separate instruction for injecting ChangeDetectorRef into a pipe.\n      if (isPipe && dep.resolved === R3ResolvedDependencyType.ChangeDetectorRef) {\n        return o.importExpr(R3.injectPipeChangeDetectorRef).callFn(flagsParam ? [flagsParam] : []);\n      }\n\n      // Build up the arguments to the injectFn call.\n      const injectArgs = [dep.token];\n      if (flagsParam) {\n        injectArgs.push(flagsParam);\n      }\n      return o.importExpr(injectFn).callFn(injectArgs);\n    case R3ResolvedDependencyType.Attribute:\n      // In the case of attributes, the attribute name in question is given as the token.\n      return o.importExpr(R3.injectAttribute).callFn([dep.token]);\n    case R3ResolvedDependencyType.Invalid:\n      return o.importExpr(R3.invalidFactoryDep).callFn([o.literal(index)]);\n    default:\n      return unsupported(\n          `Unknown R3ResolvedDependencyType: ${R3ResolvedDependencyType[dep.resolved]}`);\n  }\n}\n\n/**\n * A helper function useful for extracting `R3DependencyMetadata` from a Render2\n * `CompileTypeMetadata` instance.\n */\nexport function dependenciesFromGlobalMetadata(\n    type: CompileTypeMetadata, outputCtx: OutputContext,\n    reflector: CompileReflector): R3DependencyMetadata[] {\n  // Use the `CompileReflector` to look up references to some well-known Angular types. These will\n  // be compared with the token to statically determine whether the token has significance to\n  // Angular, and set the correct `R3ResolvedDependencyType` as a result.\n  const injectorRef = reflector.resolveExternalReference(Identifiers.Injector);\n\n  // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.\n  const deps: R3DependencyMetadata[] = [];\n  for (let dependency of type.diDeps) {\n    if (dependency.token) {\n      const tokenRef = tokenReference(dependency.token);\n      let resolved: R3ResolvedDependencyType = dependency.isAttribute ?\n          R3ResolvedDependencyType.Attribute :\n          R3ResolvedDependencyType.Token;\n\n      // In the case of most dependencies, the token will be a reference to a type. Sometimes,\n      // however, it can be a string, in the case of older Angular code or @Attribute injection.\n      const token =\n          tokenRef instanceof StaticSymbol ? outputCtx.importExpr(tokenRef) : o.literal(tokenRef);\n\n      // Construct the dependency.\n      deps.push({\n        token,\n        resolved,\n        host: !!dependency.isHost,\n        optional: !!dependency.isOptional,\n        self: !!dependency.isSelf,\n        skipSelf: !!dependency.isSkipSelf,\n      });\n    } else {\n      unsupported('dependency without a token');\n    }\n  }\n\n  return deps;\n}\n\nfunction isDelegatedMetadata(meta: R3FactoryMetadata): meta is R3DelegatedFactoryMetadata|\n    R3DelegatedFnOrClassMetadata {\n  return (meta as any).delegateType !== undefined;\n}\n\nfunction isExpressionFactoryMetadata(meta: R3FactoryMetadata): meta is R3ExpressionFactoryMetadata {\n  return (meta as any).expression !== undefined;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Identifiers} from './identifiers';\nimport * as o from './output/output_ast';\nimport {R3DependencyMetadata, R3FactoryDelegateType, R3FactoryMetadata, R3FactoryTarget, compileFactoryFunction} from './render3/r3_factory';\nimport {R3Reference, mapToMapExpression, typeWithParameters} from './render3/util';\n\nexport interface InjectableDef {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nexport interface R3InjectableMetadata {\n  name: string;\n  type: R3Reference;\n  internalType: o.Expression;\n  typeArgumentCount: number;\n  providedIn: o.Expression;\n  useClass?: o.Expression;\n  useFactory?: o.Expression;\n  useExisting?: o.Expression;\n  useValue?: o.Expression;\n  userDeps?: R3DependencyMetadata[];\n}\n\nexport function compileInjectable(meta: R3InjectableMetadata): InjectableDef {\n  let result: {factory: o.Expression, statements: o.Statement[]}|null = null;\n\n  const factoryMeta: R3FactoryMetadata = {\n    name: meta.name,\n    type: meta.type,\n    internalType: meta.internalType,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    injectFn: Identifiers.inject,\n    target: R3FactoryTarget.Injectable,\n  };\n\n  if (meta.useClass !== undefined) {\n    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n    // used to instantiate the class with dependencies injected, or deps are not specified and\n    // the factory of the class is used to instantiate it.\n    //\n    // A special case exists for useClass: Type where Type is the injectable type itself and no\n    // deps are specified, in which case 'useClass' is effectively ignored.\n\n    const useClassOnSelf = meta.useClass.isEquivalent(meta.internalType);\n    let deps: R3DependencyMetadata[]|undefined = undefined;\n    if (meta.userDeps !== undefined) {\n      deps = meta.userDeps;\n    }\n\n    if (deps !== undefined) {\n      // factory: () => new meta.useClass(...deps)\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useClass,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class,\n      });\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = delegateToFactory(\n          meta.type.value as o.WrappedNodeExpr<any>, meta.useClass as o.WrappedNodeExpr<any>);\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.userDeps !== undefined) {\n      result = compileFactoryFunction({\n        ...factoryMeta,\n        delegate: meta.useFactory,\n        delegateDeps: meta.userDeps || [],\n        delegateType: R3FactoryDelegateType.Function,\n      });\n    } else {\n      result = {\n        statements: [],\n        factory: o.fn([], [new o.ReturnStatement(meta.useFactory.callFn([]))])\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: meta.useValue,\n    });\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    result = compileFactoryFunction({\n      ...factoryMeta,\n      expression: o.importExpr(Identifiers.inject).callFn([meta.useExisting]),\n    });\n  } else {\n    result = delegateToFactory(\n        meta.type.value as o.WrappedNodeExpr<any>, meta.internalType as o.WrappedNodeExpr<any>);\n  }\n\n  const token = meta.internalType;\n\n  const injectableProps: {[key: string]: o.Expression} = {token, factory: result.factory};\n\n  // Only generate providedIn property if it has a non-null value\n  if ((meta.providedIn as o.LiteralExpr).value !== null) {\n    injectableProps.providedIn = meta.providedIn;\n  }\n\n  const expression =\n      o.importExpr(Identifiers.ÉµÉµdefineInjectable).callFn([mapToMapExpression(injectableProps)]);\n  const type = new o.ExpressionType(o.importExpr(\n      Identifiers.InjectableDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n\n  return {\n    expression,\n    type,\n    statements: result.statements,\n  };\n}\n\nfunction delegateToFactory(type: o.WrappedNodeExpr<any>, internalType: o.WrappedNodeExpr<any>) {\n  return {\n    statements: [],\n    // If types are the same, we can generate `factory: type.Éµfac`\n    // If types are different, we have to generate a wrapper function to ensure\n    // the internal type has been resolved (`factory: function(t) { return type.Éµfac(t); }`)\n    factory: type.node === internalType.node ?\n        internalType.prop('Éµfac') :\n        o.fn([new o.FnParam('t', o.DYNAMIC_TYPE)], [new o.ReturnStatement(internalType.callMethod(\n                                                       'Éµfac', [o.variable('t')]))])\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function assertArrayOfStrings(identifier: string, value: any) {\n  if (value == null) {\n    return;\n  }\n  if (!Array.isArray(value)) {\n    throw new Error(`Expected '${identifier}' to be an array of strings.`);\n  }\n  for (let i = 0; i < value.length; i += 1) {\n    if (typeof value[i] !== 'string') {\n      throw new Error(`Expected '${identifier}' to be an array of strings.`);\n    }\n  }\n}\n\nconst UNUSABLE_INTERPOLATION_REGEXPS = [\n  /^\\s*$/,        // empty\n  /[<>]/,         // html tag\n  /^[{}]$/,       // i18n expansion\n  /&(#|[a-z])/i,  // character reference,\n  /^\\/\\//,        // comment\n];\n\nexport function assertInterpolationSymbols(identifier: string, value: any): void {\n  if (value != null && !(Array.isArray(value) && value.length == 2)) {\n    throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\n  } else if (value != null) {\n    const start = value[0] as string;\n    const end = value[1] as string;\n    // Check for unusable interpolation symbols\n    UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\n      if (regexp.test(start) || regexp.test(end)) {\n        throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\n      }\n    });\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertInterpolationSymbols} from '../assertions';\n\nexport class InterpolationConfig {\n  static fromArray(markers: [string, string]|null): InterpolationConfig {\n    if (!markers) {\n      return DEFAULT_INTERPOLATION_CONFIG;\n    }\n\n    assertInterpolationSymbols('interpolation', markers);\n    return new InterpolationConfig(markers[0], markers[1]);\n  }\n\n  constructor(public start: string, public end: string) {}\n}\n\nexport const DEFAULT_INTERPOLATION_CONFIG: InterpolationConfig =\n    new InterpolationConfig('{{', '}}');\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {utf8Encode} from '../util';\n\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\nconst VERSION = 3;\n\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\ntype Segment = {\n  col0: number,\n  sourceUrl?: string,\n  sourceLine0?: number,\n  sourceCol0?: number,\n};\n\nexport type SourceMap = {\n  version: number,\n  file?: string,\n  sourceRoot: string,\n  sources: string[],\n  sourcesContent: (string | null)[],\n  mappings: string,\n};\n\nexport class SourceMapGenerator {\n  private sourcesContent: Map<string, string|null> = new Map();\n  private lines: Segment[][] = [];\n  private lastCol0: number = 0;\n  private hasMappings = false;\n\n  constructor(private file: string|null = null) {}\n\n  // The content is `null` when the content is expected to be loaded using the URL\n  addSource(url: string, content: string|null = null): this {\n    if (!this.sourcesContent.has(url)) {\n      this.sourcesContent.set(url, content);\n    }\n    return this;\n  }\n\n  addLine(): this {\n    this.lines.push([]);\n    this.lastCol0 = 0;\n    return this;\n  }\n\n  addMapping(col0: number, sourceUrl?: string, sourceLine0?: number, sourceCol0?: number): this {\n    if (!this.currentLine) {\n      throw new Error(`A line must be added before mappings can be added`);\n    }\n    if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n      throw new Error(`Unknown source file \"${sourceUrl}\"`);\n    }\n    if (col0 == null) {\n      throw new Error(`The column in the generated code must be provided`);\n    }\n    if (col0 < this.lastCol0) {\n      throw new Error(`Mapping should be added in output order`);\n    }\n    if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n      throw new Error(`The source location must be provided when a source url is provided`);\n    }\n\n    this.hasMappings = true;\n    this.lastCol0 = col0;\n    this.currentLine.push({col0, sourceUrl, sourceLine0, sourceCol0});\n    return this;\n  }\n\n  /**\n  * @internal strip this from published d.ts files due to\n  * https://github.com/microsoft/TypeScript/issues/36216\n  */\n  private get currentLine(): Segment[]|null { return this.lines.slice(-1)[0]; }\n\n  toJSON(): SourceMap|null {\n    if (!this.hasMappings) {\n      return null;\n    }\n\n    const sourcesIndex = new Map<string, number>();\n    const sources: string[] = [];\n    const sourcesContent: (string | null)[] = [];\n\n    Array.from(this.sourcesContent.keys()).forEach((url: string, i: number) => {\n      sourcesIndex.set(url, i);\n      sources.push(url);\n      sourcesContent.push(this.sourcesContent.get(url) || null);\n    });\n\n    let mappings: string = '';\n    let lastCol0: number = 0;\n    let lastSourceIndex: number = 0;\n    let lastSourceLine0: number = 0;\n    let lastSourceCol0: number = 0;\n\n    this.lines.forEach(segments => {\n      lastCol0 = 0;\n\n      mappings += segments\n                      .map(segment => {\n                        // zero-based starting column of the line in the generated code\n                        let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n                        lastCol0 = segment.col0;\n\n                        if (segment.sourceUrl != null) {\n                          // zero-based index into the âsourcesâ list\n                          segAsStr +=\n                              toBase64VLQ(sourcesIndex.get(segment.sourceUrl) ! - lastSourceIndex);\n                          lastSourceIndex = sourcesIndex.get(segment.sourceUrl) !;\n                          // the zero-based starting line in the original source\n                          segAsStr += toBase64VLQ(segment.sourceLine0 ! - lastSourceLine0);\n                          lastSourceLine0 = segment.sourceLine0 !;\n                          // the zero-based starting column in the original source\n                          segAsStr += toBase64VLQ(segment.sourceCol0 ! - lastSourceCol0);\n                          lastSourceCol0 = segment.sourceCol0 !;\n                        }\n\n                        return segAsStr;\n                      })\n                      .join(',');\n      mappings += ';';\n    });\n\n    mappings = mappings.slice(0, -1);\n\n    return {\n      'file': this.file || '',\n      'version': VERSION,\n      'sourceRoot': '',\n      'sources': sources,\n      'sourcesContent': sourcesContent,\n      'mappings': mappings,\n    };\n  }\n\n  toJsComment(): string {\n    return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\n                              '';\n  }\n}\n\nexport function toBase64String(value: string): string {\n  let b64 = '';\n  value = utf8Encode(value);\n  for (let i = 0; i < value.length;) {\n    const i1 = value.charCodeAt(i++);\n    const i2 = value.charCodeAt(i++);\n    const i3 = value.charCodeAt(i++);\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit(((i1 & 3) << 4) | (isNaN(i2) ? 0 : i2 >> 4));\n    b64 += isNaN(i2) ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 >> 6));\n    b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n  }\n\n  return b64;\n}\n\nfunction toBase64VLQ(value: number): string {\n  value = value < 0 ? ((-value) << 1) + 1 : value << 1;\n\n  let out = '';\n  do {\n    let digit = value & 31;\n    value = value >> 5;\n    if (value > 0) {\n      digit = digit | 32;\n    }\n    out += toBase64Digit(digit);\n  } while (value > 0);\n\n  return out;\n}\n\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction toBase64Digit(value: number): string {\n  if (value < 0 || value >= 64) {\n    throw new Error(`Can only encode value in the range [0, 63]`);\n  }\n\n  return B64_DIGITS[value];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseSourceSpan} from '../parse_util';\nimport * as o from './output_ast';\nimport {SourceMapGenerator} from './source_map';\n\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nconst _INDENT_WITH = '  ';\nexport const CATCH_ERROR_VAR = o.variable('error', null, null);\nexport const CATCH_STACK_VAR = o.variable('stack', null, null);\n\nexport interface OutputEmitter {\n  emitStatements(genFilePath: string, stmts: o.Statement[], preamble?: string|null): string;\n}\n\nclass _EmittedLine {\n  partsLength = 0;\n  parts: string[] = [];\n  srcSpans: (ParseSourceSpan|null)[] = [];\n  constructor(public indent: number) {}\n}\n\nexport class EmitterVisitorContext {\n  static createRoot(): EmitterVisitorContext { return new EmitterVisitorContext(0); }\n\n  private _lines: _EmittedLine[];\n  private _classes: o.ClassStmt[] = [];\n  private _preambleLineCount = 0;\n\n  constructor(private _indent: number) { this._lines = [new _EmittedLine(_indent)]; }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get _currentLine(): _EmittedLine { return this._lines[this._lines.length - 1]; }\n\n  println(from?: {sourceSpan: ParseSourceSpan | null}|null, lastPart: string = ''): void {\n    this.print(from || null, lastPart, true);\n  }\n\n  lineIsEmpty(): boolean { return this._currentLine.parts.length === 0; }\n\n  lineLength(): number {\n    return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n  }\n\n  print(from: {sourceSpan: ParseSourceSpan | null}|null, part: string, newLine: boolean = false) {\n    if (part.length > 0) {\n      this._currentLine.parts.push(part);\n      this._currentLine.partsLength += part.length;\n      this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n    }\n    if (newLine) {\n      this._lines.push(new _EmittedLine(this._indent));\n    }\n  }\n\n  removeEmptyLastLine() {\n    if (this.lineIsEmpty()) {\n      this._lines.pop();\n    }\n  }\n\n  incIndent() {\n    this._indent++;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  decIndent() {\n    this._indent--;\n    if (this.lineIsEmpty()) {\n      this._currentLine.indent = this._indent;\n    }\n  }\n\n  pushClass(clazz: o.ClassStmt) { this._classes.push(clazz); }\n\n  popClass(): o.ClassStmt { return this._classes.pop() !; }\n\n  get currentClass(): o.ClassStmt|null {\n    return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n  }\n\n  toSource(): string {\n    return this.sourceLines\n        .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\n        .join('\\n');\n  }\n\n  toSourceMapGenerator(genFilePath: string, startsAtLine: number = 0): SourceMapGenerator {\n    const map = new SourceMapGenerator(genFilePath);\n\n    let firstOffsetMapped = false;\n    const mapFirstOffsetIfNeeded = () => {\n      if (!firstOffsetMapped) {\n        // Add a single space so that tools won't try to load the file from disk.\n        // Note: We are using virtual urls like `ng:///`, so we have to\n        // provide a content here.\n        map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n        firstOffsetMapped = true;\n      }\n    };\n\n    for (let i = 0; i < startsAtLine; i++) {\n      map.addLine();\n      mapFirstOffsetIfNeeded();\n    }\n\n    this.sourceLines.forEach((line, lineIdx) => {\n      map.addLine();\n\n      const spans = line.srcSpans;\n      const parts = line.parts;\n      let col0 = line.indent * _INDENT_WITH.length;\n      let spanIdx = 0;\n      // skip leading parts without source spans\n      while (spanIdx < spans.length && !spans[spanIdx]) {\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n      }\n      if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n        firstOffsetMapped = true;\n      } else {\n        mapFirstOffsetIfNeeded();\n      }\n\n      while (spanIdx < spans.length) {\n        const span = spans[spanIdx] !;\n        const source = span.start.file;\n        const sourceLine = span.start.line;\n        const sourceCol = span.start.col;\n        map.addSource(source.url, source.content)\n            .addMapping(col0, source.url, sourceLine, sourceCol);\n\n        col0 += parts[spanIdx].length;\n        spanIdx++;\n\n        // assign parts without span or the same span to the previous segment\n        while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n      }\n    });\n\n    return map;\n  }\n\n  setPreambleLineCount(count: number) { return this._preambleLineCount = count; }\n\n  spanOf(line: number, column: number): ParseSourceSpan|null {\n    const emittedLine = this._lines[line - this._preambleLineCount];\n    if (emittedLine) {\n      let columnsLeft = column - _createIndent(emittedLine.indent).length;\n      for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n        const part = emittedLine.parts[partIndex];\n        if (part.length > columnsLeft) {\n          return emittedLine.srcSpans[partIndex];\n        }\n        columnsLeft -= part.length;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  private get sourceLines(): _EmittedLine[] {\n    if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n      return this._lines.slice(0, -1);\n    }\n    return this._lines;\n  }\n}\n\nexport abstract class AbstractEmitterVisitor implements o.StatementVisitor, o.ExpressionVisitor {\n  constructor(private _escapeDollarInStrings: boolean) {}\n\n  visitExpressionStmt(stmt: o.ExpressionStatement, ctx: EmitterVisitorContext): any {\n    stmt.expr.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  visitReturnStmt(stmt: o.ReturnStatement, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `return `);\n    stmt.value.visitExpression(this, ctx);\n    ctx.println(stmt, ';');\n    return null;\n  }\n\n  abstract visitCastExpr(ast: o.CastExpr, context: any): any;\n\n  abstract visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any;\n\n  visitIfStmt(stmt: o.IfStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `if (`);\n    stmt.condition.visitExpression(this, ctx);\n    ctx.print(stmt, `) {`);\n    const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n    if (stmt.trueCase.length <= 1 && !hasElseCase) {\n      ctx.print(stmt, ` `);\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.removeEmptyLastLine();\n      ctx.print(stmt, ` `);\n    } else {\n      ctx.println();\n      ctx.incIndent();\n      this.visitAllStatements(stmt.trueCase, ctx);\n      ctx.decIndent();\n      if (hasElseCase) {\n        ctx.println(stmt, `} else {`);\n        ctx.incIndent();\n        this.visitAllStatements(stmt.falseCase, ctx);\n        ctx.decIndent();\n      }\n    }\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  abstract visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any;\n\n  visitThrowStmt(stmt: o.ThrowStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `throw `);\n    stmt.error.visitExpression(this, ctx);\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  visitCommentStmt(stmt: o.CommentStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.multiline) {\n      ctx.println(stmt, `/* ${stmt.comment} */`);\n    } else {\n      stmt.comment.split('\\n').forEach((line) => { ctx.println(stmt, `// ${line}`); });\n    }\n    return null;\n  }\n  visitJSDocCommentStmt(stmt: o.JSDocCommentStmt, ctx: EmitterVisitorContext) {\n    ctx.println(stmt, `/*${stmt.toString()}*/`);\n    return null;\n  }\n\n  abstract visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any;\n\n  visitWriteVarExpr(expr: o.WriteVarExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    ctx.print(expr, `${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWriteKeyExpr(expr: o.WriteKeyExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `[`);\n    expr.index.visitExpression(this, ctx);\n    ctx.print(expr, `] = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitWritePropExpr(expr: o.WritePropExpr, ctx: EmitterVisitorContext): any {\n    const lineWasEmpty = ctx.lineIsEmpty();\n    if (!lineWasEmpty) {\n      ctx.print(expr, '(');\n    }\n    expr.receiver.visitExpression(this, ctx);\n    ctx.print(expr, `.${expr.name} = `);\n    expr.value.visitExpression(this, ctx);\n    if (!lineWasEmpty) {\n      ctx.print(expr, ')');\n    }\n    return null;\n  }\n  visitInvokeMethodExpr(expr: o.InvokeMethodExpr, ctx: EmitterVisitorContext): any {\n    expr.receiver.visitExpression(this, ctx);\n    let name = expr.name;\n    if (expr.builtin != null) {\n      name = this.getBuiltinMethodName(expr.builtin);\n      if (name == null) {\n        // some builtins just mean to skip the call.\n        return null;\n      }\n    }\n    ctx.print(expr, `.${name}(`);\n    this.visitAllExpressions(expr.args, ctx, `,`);\n    ctx.print(expr, `)`);\n    return null;\n  }\n\n  abstract getBuiltinMethodName(method: o.BuiltinMethod): string;\n\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): any {\n    expr.fn.visitExpression(this, ctx);\n    ctx.print(expr, `(`);\n    this.visitAllExpressions(expr.args, ctx, ',');\n    ctx.print(expr, `)`);\n    return null;\n  }\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n  }\n  visitTypeofExpr(expr: o.TypeofExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(expr, 'typeof ');\n    expr.expr.visitExpression(this, ctx);\n  }\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): any {\n    let varName = ast.name !;\n    if (ast.builtin != null) {\n      switch (ast.builtin) {\n        case o.BuiltinVar.Super:\n          varName = 'super';\n          break;\n        case o.BuiltinVar.This:\n          varName = 'this';\n          break;\n        case o.BuiltinVar.CatchError:\n          varName = CATCH_ERROR_VAR.name !;\n          break;\n        case o.BuiltinVar.CatchStack:\n          varName = CATCH_STACK_VAR.name !;\n          break;\n        default:\n          throw new Error(`Unknown builtin variable ${ast.builtin}`);\n      }\n    }\n    ctx.print(ast, varName);\n    return null;\n  }\n  visitInstantiateExpr(ast: o.InstantiateExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `new `);\n    ast.classExpr.visitExpression(this, ctx);\n    ctx.print(ast, `(`);\n    this.visitAllExpressions(ast.args, ctx, ',');\n    ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitLiteralExpr(ast: o.LiteralExpr, ctx: EmitterVisitorContext): any {\n    const value = ast.value;\n    if (typeof value === 'string') {\n      ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n    } else {\n      ctx.print(ast, `${value}`);\n    }\n    return null;\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    const head = ast.serializeI18nHead();\n    ctx.print(ast, '$localize `' + head.raw);\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      ctx.print(ast, '${');\n      ast.expressions[i - 1].visitExpression(this, ctx);\n      ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\n    }\n    ctx.print(ast, '`');\n    return null;\n  }\n\n  abstract visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any;\n\n  visitConditionalExpr(ast: o.ConditionalExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `(`);\n    ast.condition.visitExpression(this, ctx);\n    ctx.print(ast, '? ');\n    ast.trueCase.visitExpression(this, ctx);\n    ctx.print(ast, ': ');\n    ast.falseCase !.visitExpression(this, ctx);\n    ctx.print(ast, `)`);\n    return null;\n  }\n  visitNotExpr(ast: o.NotExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '!');\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  visitAssertNotNullExpr(ast: o.AssertNotNull, ctx: EmitterVisitorContext): any {\n    ast.condition.visitExpression(this, ctx);\n    return null;\n  }\n  abstract visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any;\n  abstract visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, context: any): any;\n\n  visitBinaryOperatorExpr(ast: o.BinaryOperatorExpr, ctx: EmitterVisitorContext): any {\n    let opStr: string;\n    switch (ast.operator) {\n      case o.BinaryOperator.Equals:\n        opStr = '==';\n        break;\n      case o.BinaryOperator.Identical:\n        opStr = '===';\n        break;\n      case o.BinaryOperator.NotEquals:\n        opStr = '!=';\n        break;\n      case o.BinaryOperator.NotIdentical:\n        opStr = '!==';\n        break;\n      case o.BinaryOperator.And:\n        opStr = '&&';\n        break;\n      case o.BinaryOperator.BitwiseAnd:\n        opStr = '&';\n        break;\n      case o.BinaryOperator.Or:\n        opStr = '||';\n        break;\n      case o.BinaryOperator.Plus:\n        opStr = '+';\n        break;\n      case o.BinaryOperator.Minus:\n        opStr = '-';\n        break;\n      case o.BinaryOperator.Divide:\n        opStr = '/';\n        break;\n      case o.BinaryOperator.Multiply:\n        opStr = '*';\n        break;\n      case o.BinaryOperator.Modulo:\n        opStr = '%';\n        break;\n      case o.BinaryOperator.Lower:\n        opStr = '<';\n        break;\n      case o.BinaryOperator.LowerEquals:\n        opStr = '<=';\n        break;\n      case o.BinaryOperator.Bigger:\n        opStr = '>';\n        break;\n      case o.BinaryOperator.BiggerEquals:\n        opStr = '>=';\n        break;\n      default:\n        throw new Error(`Unknown operator ${ast.operator}`);\n    }\n    if (ast.parens) ctx.print(ast, `(`);\n    ast.lhs.visitExpression(this, ctx);\n    ctx.print(ast, ` ${opStr} `);\n    ast.rhs.visitExpression(this, ctx);\n    if (ast.parens) ctx.print(ast, `)`);\n    return null;\n  }\n\n  visitReadPropExpr(ast: o.ReadPropExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `.`);\n    ctx.print(ast, ast.name);\n    return null;\n  }\n  visitReadKeyExpr(ast: o.ReadKeyExpr, ctx: EmitterVisitorContext): any {\n    ast.receiver.visitExpression(this, ctx);\n    ctx.print(ast, `[`);\n    ast.index.visitExpression(this, ctx);\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralArrayExpr(ast: o.LiteralArrayExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `[`);\n    this.visitAllExpressions(ast.entries, ctx, ',');\n    ctx.print(ast, `]`);\n    return null;\n  }\n  visitLiteralMapExpr(ast: o.LiteralMapExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `{`);\n    this.visitAllObjects(entry => {\n      ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\n      entry.value.visitExpression(this, ctx);\n    }, ast.entries, ctx, ',');\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitCommaExpr(ast: o.CommaExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, '(');\n    this.visitAllExpressions(ast.parts, ctx, ',');\n    ctx.print(ast, ')');\n    return null;\n  }\n  visitAllExpressions(expressions: o.Expression[], ctx: EmitterVisitorContext, separator: string):\n      void {\n    this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\n  }\n\n  visitAllObjects<T>(\n      handler: (t: T) => void, expressions: T[], ctx: EmitterVisitorContext,\n      separator: string): void {\n    let incrementedIndent = false;\n    for (let i = 0; i < expressions.length; i++) {\n      if (i > 0) {\n        if (ctx.lineLength() > 80) {\n          ctx.print(null, separator, true);\n          if (!incrementedIndent) {\n            // continuation are marked with double indent.\n            ctx.incIndent();\n            ctx.incIndent();\n            incrementedIndent = true;\n          }\n        } else {\n          ctx.print(null, separator, false);\n        }\n      }\n      handler(expressions[i]);\n    }\n    if (incrementedIndent) {\n      // continuation are marked with double indent.\n      ctx.decIndent();\n      ctx.decIndent();\n    }\n  }\n\n  visitAllStatements(statements: o.Statement[], ctx: EmitterVisitorContext): void {\n    statements.forEach((stmt) => stmt.visitStatement(this, ctx));\n  }\n}\n\nexport function escapeIdentifier(\n    input: string, escapeDollar: boolean, alwaysQuote: boolean = true): any {\n  if (input == null) {\n    return null;\n  }\n  const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match: string[]) => {\n    if (match[0] == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if (match[0] == '\\n') {\n      return '\\\\n';\n    } else if (match[0] == '\\r') {\n      return '\\\\r';\n    } else {\n      return `\\\\${match[0]}`;\n    }\n  });\n  const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? `'${body}'` : body;\n}\n\nfunction _createIndent(count: number): string {\n  let res = '';\n  for (let i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {AbstractEmitterVisitor, CATCH_ERROR_VAR, CATCH_STACK_VAR, EmitterVisitorContext, escapeIdentifier} from './abstract_emitter';\nimport * as o from './output_ast';\n\nexport abstract class AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\n  constructor() { super(false); }\n  visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any {\n    ctx.pushClass(stmt);\n    this._visitClassConstructor(stmt, ctx);\n\n    if (stmt.parent != null) {\n      ctx.print(stmt, `${stmt.name}.prototype = Object.create(`);\n      stmt.parent.visitExpression(this, ctx);\n      ctx.println(stmt, `.prototype);`);\n    }\n    stmt.getters.forEach((getter) => this._visitClassGetter(stmt, getter, ctx));\n    stmt.methods.forEach((method) => this._visitClassMethod(stmt, method, ctx));\n    ctx.popClass();\n    return null;\n  }\n\n  private _visitClassConstructor(stmt: o.ClassStmt, ctx: EmitterVisitorContext) {\n    ctx.print(stmt, `function ${stmt.name}(`);\n    if (stmt.constructorMethod != null) {\n      this._visitParams(stmt.constructorMethod.params, ctx);\n    }\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    if (stmt.constructorMethod != null) {\n      if (stmt.constructorMethod.body.length > 0) {\n        ctx.println(stmt, `var self = this;`);\n        this.visitAllStatements(stmt.constructorMethod.body, ctx);\n      }\n    }\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n  }\n\n  private _visitClassGetter(stmt: o.ClassStmt, getter: o.ClassGetter, ctx: EmitterVisitorContext) {\n    ctx.println(\n        stmt,\n        `Object.defineProperty(${stmt.name}.prototype, '${getter.name}', { get: function() {`);\n    ctx.incIndent();\n    if (getter.body.length > 0) {\n      ctx.println(stmt, `var self = this;`);\n      this.visitAllStatements(getter.body, ctx);\n    }\n    ctx.decIndent();\n    ctx.println(stmt, `}});`);\n  }\n\n  private _visitClassMethod(stmt: o.ClassStmt, method: o.ClassMethod, ctx: EmitterVisitorContext) {\n    ctx.print(stmt, `${stmt.name}.prototype.${method.name} = function(`);\n    this._visitParams(method.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    if (method.body.length > 0) {\n      ctx.println(stmt, `var self = this;`);\n      this.visitAllStatements(method.body, ctx);\n    }\n    ctx.decIndent();\n    ctx.println(stmt, `};`);\n  }\n\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n  }\n\n  visitReadVarExpr(ast: o.ReadVarExpr, ctx: EmitterVisitorContext): string|null {\n    if (ast.builtin === o.BuiltinVar.This) {\n      ctx.print(ast, 'self');\n    } else if (ast.builtin === o.BuiltinVar.Super) {\n      throw new Error(\n          `'super' needs to be handled at a parent ast node, not at the variable level!`);\n    } else {\n      super.visitReadVarExpr(ast, ctx);\n    }\n    return null;\n  }\n  visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `var ${stmt.name}`);\n    if (stmt.value) {\n      ctx.print(stmt, ' = ');\n      stmt.value.visitExpression(this, ctx);\n    }\n    ctx.println(stmt, `;`);\n    return null;\n  }\n  visitCastExpr(ast: o.CastExpr, ctx: EmitterVisitorContext): any {\n    ast.value.visitExpression(this, ctx);\n    return null;\n  }\n  visitInvokeFunctionExpr(expr: o.InvokeFunctionExpr, ctx: EmitterVisitorContext): string|null {\n    const fnExpr = expr.fn;\n    if (fnExpr instanceof o.ReadVarExpr && fnExpr.builtin === o.BuiltinVar.Super) {\n      ctx.currentClass !.parent !.visitExpression(this, ctx);\n      ctx.print(expr, `.call(this`);\n      if (expr.args.length > 0) {\n        ctx.print(expr, `, `);\n        this.visitAllExpressions(expr.args, ctx, ',');\n      }\n      ctx.print(expr, `)`);\n    } else {\n      super.visitInvokeFunctionExpr(expr, ctx);\n    }\n    return null;\n  }\n  visitFunctionExpr(ast: o.FunctionExpr, ctx: EmitterVisitorContext): any {\n    ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\n    this._visitParams(ast.params, ctx);\n    ctx.println(ast, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(ast.statements, ctx);\n    ctx.decIndent();\n    ctx.print(ast, `}`);\n    return null;\n  }\n  visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    ctx.print(stmt, `function ${stmt.name}(`);\n    this._visitParams(stmt.params, ctx);\n    ctx.println(stmt, `) {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.statements, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n  visitTryCatchStmt(stmt: o.TryCatchStmt, ctx: EmitterVisitorContext): any {\n    ctx.println(stmt, `try {`);\n    ctx.incIndent();\n    this.visitAllStatements(stmt.bodyStmts, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `} catch (${CATCH_ERROR_VAR.name}) {`);\n    ctx.incIndent();\n    const catchStmts =\n        [<o.Statement>CATCH_STACK_VAR.set(CATCH_ERROR_VAR.prop('stack')).toDeclStmt(null, [\n          o.StmtModifier.Final\n        ])].concat(stmt.catchStmts);\n    this.visitAllStatements(catchStmts, ctx);\n    ctx.decIndent();\n    ctx.println(stmt, `}`);\n    return null;\n  }\n\n  visitLocalizedString(ast: o.LocalizedString, ctx: EmitterVisitorContext): any {\n    // The following convoluted piece of code is effectively the downlevelled equivalent of\n    // ```\n    // $localize `...`\n    // ```\n    // which is effectively like:\n    // ```\n    // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n    // ```\n    //\n    // The `$localize` function expects a \"template object\", which is an array of \"cooked\" strings\n    // plus a `raw` property that contains an array of \"raw\" strings.\n    //\n    // In some environments a helper function called `__makeTemplateObject(cooked, raw)` might be\n    // available, in which case we use that. Otherwise we must create our own helper function\n    // inline.\n    //\n    // In the inline function, if `Object.defineProperty` is available we use that to attach the\n    // `raw` array.\n    ctx.print(\n        ast,\n        '$localize((this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})(');\n    const parts = [ast.serializeI18nHead()];\n    for (let i = 1; i < ast.messageParts.length; i++) {\n      parts.push(ast.serializeI18nTemplatePart(i));\n    }\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\n    ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\n    ast.expressions.forEach(expression => {\n      ctx.print(ast, ', ');\n      expression.visitExpression(this, ctx);\n    });\n    ctx.print(ast, ')');\n    return null;\n  }\n\n  private _visitParams(params: o.FnParam[], ctx: EmitterVisitorContext): void {\n    this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\n  }\n\n  getBuiltinMethodName(method: o.BuiltinMethod): string {\n    let name: string;\n    switch (method) {\n      case o.BuiltinMethod.ConcatArray:\n        name = 'concat';\n        break;\n      case o.BuiltinMethod.SubscribeObservable:\n        name = 'subscribe';\n        break;\n      case o.BuiltinMethod.Bind:\n        name = 'bind';\n        break;\n      default:\n        throw new Error(`Unknown builtin method: ${method}`);\n    }\n    return name;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {identifierName} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\n\nimport {EmitterVisitorContext} from './abstract_emitter';\nimport {AbstractJsEmitterVisitor} from './abstract_js_emitter';\nimport * as o from './output_ast';\n\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\nexport class JitEvaluator {\n  /**\n   *\n   * @param sourceUrl The URL of the generated code.\n   * @param statements An array of Angular statement AST nodes to be evaluated.\n   * @param reflector A helper used when converting the statements to executable code.\n   * @param createSourceMaps If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns A map of all the variables in the generated code.\n   */\n  evaluateStatements(\n      sourceUrl: string, statements: o.Statement[], reflector: CompileReflector,\n      createSourceMaps: boolean): {[key: string]: any} {\n    const converter = new JitEmitterVisitor(reflector);\n    const ctx = EmitterVisitorContext.createRoot();\n    // Ensure generated code is in strict mode\n    if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n      statements = [\n        o.literal('use strict').toStmt(),\n        ...statements,\n      ];\n    }\n    converter.visitAllStatements(statements, ctx);\n    converter.createReturnStmt(ctx);\n    return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n  }\n\n  /**\n   * Evaluate a piece of JIT generated code.\n   * @param sourceUrl The URL of this generated code.\n   * @param ctx A context object that contains an AST of the code to be evaluated.\n   * @param vars A map containing the names and values of variables that the evaluated code might\n   * reference.\n   * @param createSourceMap If true then create a source-map for the generated code and include it\n   * inline as a source-map comment.\n   * @returns The result of evaluating the code.\n   */\n  evaluateCode(\n      sourceUrl: string, ctx: EmitterVisitorContext, vars: {[key: string]: any},\n      createSourceMap: boolean): any {\n    let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\n    const fnArgNames: string[] = [];\n    const fnArgValues: any[] = [];\n    for (const argName in vars) {\n      fnArgValues.push(vars[argName]);\n      fnArgNames.push(argName);\n    }\n    if (createSourceMap) {\n      // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n      // E.g. ```\n      // function anonymous(a,b,c\n      // /**/) { ... }```\n      // We don't want to hard code this fact, so we auto detect it via an empty function first.\n      const emptyFn = new Function(...fnArgNames.concat('return null;')).toString();\n      const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n      fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\n    }\n    const fn = new Function(...fnArgNames.concat(fnBody));\n    return this.executeFunction(fn, fnArgValues);\n  }\n\n  /**\n   * Execute a JIT generated function by calling it.\n   *\n   * This method can be overridden in tests to capture the functions that are generated\n   * by this `JitEvaluator` class.\n   *\n   * @param fn A function to execute.\n   * @param args The arguments to pass to the function being executed.\n   * @returns The return value of the executed function.\n   */\n  executeFunction(fn: Function, args: any[]) { return fn(...args); }\n}\n\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\nexport class JitEmitterVisitor extends AbstractJsEmitterVisitor {\n  private _evalArgNames: string[] = [];\n  private _evalArgValues: any[] = [];\n  private _evalExportedVars: string[] = [];\n\n  constructor(private reflector: CompileReflector) { super(); }\n\n  createReturnStmt(ctx: EmitterVisitorContext) {\n    const stmt = new o.ReturnStatement(new o.LiteralMapExpr(this._evalExportedVars.map(\n        resultVar => new o.LiteralMapEntry(resultVar, o.variable(resultVar), false))));\n    stmt.visitStatement(this, ctx);\n  }\n\n  getArgs(): {[key: string]: any} {\n    const result: {[key: string]: any} = {};\n    for (let i = 0; i < this._evalArgNames.length; i++) {\n      result[this._evalArgNames[i]] = this._evalArgValues[i];\n    }\n    return result;\n  }\n\n  visitExternalExpr(ast: o.ExternalExpr, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);\n    return null;\n  }\n\n  visitWrappedNodeExpr(ast: o.WrappedNodeExpr<any>, ctx: EmitterVisitorContext): any {\n    this._emitReferenceToExternal(ast, ast.node, ctx);\n    return null;\n  }\n\n  visitDeclareVarStmt(stmt: o.DeclareVarStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareVarStmt(stmt, ctx);\n  }\n\n  visitDeclareFunctionStmt(stmt: o.DeclareFunctionStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareFunctionStmt(stmt, ctx);\n  }\n\n  visitDeclareClassStmt(stmt: o.ClassStmt, ctx: EmitterVisitorContext): any {\n    if (stmt.hasModifier(o.StmtModifier.Exported)) {\n      this._evalExportedVars.push(stmt.name);\n    }\n    return super.visitDeclareClassStmt(stmt, ctx);\n  }\n\n  private _emitReferenceToExternal(ast: o.Expression, value: any, ctx: EmitterVisitorContext):\n      void {\n    let id = this._evalArgValues.indexOf(value);\n    if (id === -1) {\n      id = this._evalArgValues.length;\n      this._evalArgValues.push(value);\n      const name = identifierName({reference: value}) || 'val';\n      this._evalArgNames.push(`jit_${name}_${id}`);\n    }\n    ctx.print(ast, this._evalArgNames[id]);\n  }\n}\n\n\nfunction isUseStrictStatement(statement: o.Statement): boolean {\n  return statement.isEquivalent(o.literal('use strict').toStmt());\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileReflector} from '../compile_reflector';\nimport * as o from '../output/output_ast';\n\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\nexport class R3JitReflector implements CompileReflector {\n  constructor(private context: {[key: string]: any}) {}\n\n  resolveExternalReference(ref: o.ExternalReference): any {\n    // This reflector only handles @angular/core imports.\n    if (ref.moduleName !== '@angular/core') {\n      throw new Error(\n          `Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);\n    }\n    if (!this.context.hasOwnProperty(ref.name !)) {\n      throw new Error(`No value provided for @angular/core symbol '${ref.name!}'.`);\n    }\n    return this.context[ref.name !];\n  }\n\n  parameters(typeOrFunc: any): any[][] { throw new Error('Not implemented.'); }\n\n  annotations(typeOrFunc: any): any[] { throw new Error('Not implemented.'); }\n\n  shallowAnnotations(typeOrFunc: any): any[] { throw new Error('Not implemented.'); }\n\n  tryAnnotations(typeOrFunc: any): any[] { throw new Error('Not implemented.'); }\n\n  propMetadata(typeOrFunc: any): {[key: string]: any[];} { throw new Error('Not implemented.'); }\n\n  hasLifecycleHook(type: any, lcProperty: string): boolean { throw new Error('Not implemented.'); }\n\n  guards(typeOrFunc: any): {[key: string]: any;} { throw new Error('Not implemented.'); }\n\n  componentModuleUrl(type: any, cmpMetadata: any): string { throw new Error('Not implemented.'); }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as o from './output_ast';\n\nexport type MapEntry = {\n  key: string,\n  quoted: boolean,\n  value: o.Expression\n};\n\nexport type MapLiteral = MapEntry[];\n\nexport function mapEntry(key: string, value: o.Expression): MapEntry {\n  return {key, value, quoted: false};\n}\n\nexport function mapLiteral(\n    obj: {[key: string]: o.Expression}, quoted: boolean = false): o.Expression {\n  return o.literalMap(Object.keys(obj).map(key => ({\n                                             key,\n                                             quoted,\n                                             value: obj[key],\n                                           })));\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileShallowModuleMetadata, identifierName} from '../compile_metadata';\nimport {InjectableCompiler} from '../injectable_compiler';\nimport {mapLiteral} from '../output/map_util';\nimport * as o from '../output/output_ast';\nimport {OutputContext} from '../util';\n\nimport {R3DependencyMetadata, R3FactoryTarget, compileFactoryFunction} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3Reference, convertMetaToOutput, jitOnlyGuardedExpression, mapToMapExpression} from './util';\n\nexport interface R3NgModuleDef {\n  expression: o.Expression;\n  type: o.Type;\n  additionalStatements: o.Statement[];\n}\n\n/**\n * Metadata required by the module compiler to generate a module def (`Éµmod`) for a type.\n */\nexport interface R3NgModuleMetadata {\n  /**\n   * An expression representing the module type being compiled.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the module type being compiled, intended for use within a class\n   * definition itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /**\n   * An expression intended for use by statements that are adjacent (i.e. tightly coupled) to but\n   * not internal to a class definition.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside\n   * an IIFE structure that uses a different name internally.\n   */\n  adjacentType: o.Expression;\n\n  /**\n   * An array of expressions representing the bootstrap components specified by the module.\n   */\n  bootstrap: R3Reference[];\n\n  /**\n   * An array of expressions representing the directives and pipes declared by the module.\n   */\n  declarations: R3Reference[];\n\n  /**\n   * An array of expressions representing the imports of the module.\n   */\n  imports: R3Reference[];\n\n  /**\n   * An array of expressions representing the exports of the module.\n   */\n  exports: R3Reference[];\n\n  /**\n   * Whether to emit the selector scope values (declarations, imports, exports) inline into the\n   * module definition, or to generate additional statements which patch them on. Inline emission\n   * does not allow components to be tree-shaken, but is useful for JIT mode.\n   */\n  emitInline: boolean;\n\n  /**\n   * Whether to generate closure wrappers for bootstrap, declarations, imports, and exports.\n   */\n  containsForwardDecls: boolean;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the NgModule.\n   */\n  schemas: R3Reference[]|null;\n\n  /** Unique ID or expression representing the unique ID of an NgModule. */\n  id: o.Expression|null;\n}\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\nexport function compileNgModule(meta: R3NgModuleMetadata): R3NgModuleDef {\n  const {\n    internalType,\n    type: moduleType,\n    bootstrap,\n    declarations,\n    imports,\n    exports,\n    schemas,\n    containsForwardDecls,\n    emitInline,\n    id\n  } = meta;\n\n  const additionalStatements: o.Statement[] = [];\n  const definitionMap = {\n    type: internalType\n  } as{\n    type: o.Expression,\n    bootstrap: o.Expression,\n    declarations: o.Expression,\n    imports: o.Expression,\n    exports: o.Expression,\n    schemas: o.LiteralArrayExpr,\n    id: o.Expression\n  };\n\n  // Only generate the keys in the metadata if the arrays have values.\n  if (bootstrap.length) {\n    definitionMap.bootstrap = refsToArray(bootstrap, containsForwardDecls);\n  }\n\n  // If requested to emit scope information inline, pass the declarations, imports and exports to\n  // the `ÉµÉµdefineNgModule` call. The JIT compilation uses this.\n  if (emitInline) {\n    if (declarations.length) {\n      definitionMap.declarations = refsToArray(declarations, containsForwardDecls);\n    }\n\n    if (imports.length) {\n      definitionMap.imports = refsToArray(imports, containsForwardDecls);\n    }\n\n    if (exports.length) {\n      definitionMap.exports = refsToArray(exports, containsForwardDecls);\n    }\n  }\n\n  // If not emitting inline, the scope information is not passed into `ÉµÉµdefineNgModule` as it would\n  // prevent tree-shaking of the declarations, imports and exports references.\n  else {\n    const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n    if (setNgModuleScopeCall !== null) {\n      additionalStatements.push(setNgModuleScopeCall);\n    }\n  }\n\n  if (schemas && schemas.length) {\n    definitionMap.schemas = o.literalArr(schemas.map(ref => ref.value));\n  }\n\n  if (id) {\n    definitionMap.id = id;\n  }\n\n  const expression = o.importExpr(R3.defineNgModule).callFn([mapToMapExpression(definitionMap)]);\n  const type = new o.ExpressionType(o.importExpr(R3.NgModuleDefWithMeta, [\n    new o.ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),\n    tupleTypeOf(exports)\n  ]));\n\n\n  return {expression, type, additionalStatements};\n}\n\n/**\n * Generates a function call to `ÉµÉµsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\nfunction generateSetNgModuleScopeCall(meta: R3NgModuleMetadata): o.Statement|null {\n  const {adjacentType: moduleType, declarations, imports, exports, containsForwardDecls} = meta;\n\n  const scopeMap = {} as{\n    declarations: o.Expression,\n    imports: o.Expression,\n    exports: o.Expression,\n  };\n\n  if (declarations.length) {\n    scopeMap.declarations = refsToArray(declarations, containsForwardDecls);\n  }\n\n  if (imports.length) {\n    scopeMap.imports = refsToArray(imports, containsForwardDecls);\n  }\n\n  if (exports.length) {\n    scopeMap.exports = refsToArray(exports, containsForwardDecls);\n  }\n\n  if (Object.keys(scopeMap).length === 0) {\n    return null;\n  }\n\n  // setNgModuleScope(...)\n  const fnCall = new o.InvokeFunctionExpr(\n      /* fn */ o.importExpr(R3.setNgModuleScope),\n      /* args */[moduleType, mapToMapExpression(scopeMap)]);\n\n  // (ngJitMode guard) && setNgModuleScope(...)\n  const guardedCall = jitOnlyGuardedExpression(fnCall);\n\n  // function() { (ngJitMode guard) && setNgModuleScope(...); }\n  const iife = new o.FunctionExpr(\n      /* params */[],\n      /* statements */[guardedCall.toStmt()]);\n\n  // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n  const iifeCall = new o.InvokeFunctionExpr(\n      /* fn */ iife,\n      /* args */[]);\n\n  return iifeCall.toStmt();\n}\n\nexport interface R3InjectorDef {\n  expression: o.Expression;\n  type: o.Type;\n  statements: o.Statement[];\n}\n\nexport interface R3InjectorMetadata {\n  name: string;\n  type: R3Reference;\n  internalType: o.Expression;\n  deps: R3DependencyMetadata[]|null;\n  providers: o.Expression|null;\n  imports: o.Expression[];\n}\n\nexport function compileInjector(meta: R3InjectorMetadata): R3InjectorDef {\n  const result = compileFactoryFunction({\n    name: meta.name,\n    type: meta.type,\n    internalType: meta.internalType,\n    typeArgumentCount: 0,\n    deps: meta.deps,\n    injectFn: R3.inject,\n    target: R3FactoryTarget.NgModule,\n  });\n  const definitionMap = {\n    factory: result.factory,\n  } as{factory: o.Expression, providers: o.Expression, imports: o.Expression};\n\n  if (meta.providers !== null) {\n    definitionMap.providers = meta.providers;\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.imports = o.literalArr(meta.imports);\n  }\n\n  const expression = o.importExpr(R3.defineInjector).callFn([mapToMapExpression(definitionMap)]);\n  const type =\n      new o.ExpressionType(o.importExpr(R3.InjectorDef, [new o.ExpressionType(meta.type.type)]));\n  return {expression, type, statements: result.statements};\n}\n\n// TODO(alxhub): integrate this with `compileNgModule`. Currently the two are separate operations.\nexport function compileNgModuleFromRender2(\n    ctx: OutputContext, ngModule: CompileShallowModuleMetadata,\n    injectableCompiler: InjectableCompiler): void {\n  const className = identifierName(ngModule.type) !;\n\n  const rawImports = ngModule.rawImports ? [ngModule.rawImports] : [];\n  const rawExports = ngModule.rawExports ? [ngModule.rawExports] : [];\n\n  const injectorDefArg = mapLiteral({\n    'factory':\n        injectableCompiler.factoryFor({type: ngModule.type, symbol: ngModule.type.reference}, ctx),\n    'providers': convertMetaToOutput(ngModule.rawProviders, ctx),\n    'imports': convertMetaToOutput([...rawImports, ...rawExports], ctx),\n  });\n\n  const injectorDef = o.importExpr(R3.defineInjector).callFn([injectorDefArg]);\n\n  ctx.statements.push(new o.ClassStmt(\n      /* name */ className,\n      /* parent */ null,\n      /* fields */[new o.ClassField(\n          /* name */ 'Éµinj',\n          /* type */ o.INFERRED_TYPE,\n          /* modifiers */[o.StmtModifier.Static],\n          /* initializer */ injectorDef, )],\n      /* getters */[],\n      /* constructorMethod */ new o.ClassMethod(null, [], []),\n      /* methods */[]));\n}\n\nfunction accessExportScope(module: o.Expression): o.Expression {\n  const selectorScope = new o.ReadPropExpr(module, 'Éµmod');\n  return new o.ReadPropExpr(selectorScope, 'exported');\n}\n\nfunction tupleTypeOf(exp: R3Reference[]): o.Type {\n  const types = exp.map(ref => o.typeofExpr(ref.type));\n  return exp.length > 0 ? o.expressionType(o.literalArr(types)) : o.NONE_TYPE;\n}\n\nfunction refsToArray(refs: R3Reference[], shouldForwardDeclare: boolean): o.Expression {\n  const values = o.literalArr(refs.map(ref => ref.value));\n  return shouldForwardDeclare ? o.fn([], [new o.ReturnStatement(values)]) : values;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompilePipeMetadata, identifierName} from '../compile_metadata';\nimport {CompileReflector} from '../compile_reflector';\nimport {DefinitionKind} from '../constant_pool';\nimport * as o from '../output/output_ast';\nimport {OutputContext, error} from '../util';\n\nimport {R3DependencyMetadata, R3FactoryTarget, compileFactoryFunction, dependenciesFromGlobalMetadata} from './r3_factory';\nimport {Identifiers as R3} from './r3_identifiers';\nimport {R3Reference, typeWithParameters, wrapReference} from './util';\n\nexport interface R3PipeMetadata {\n  /**\n   * Name of the pipe type.\n   */\n  name: string;\n\n  /**\n   * An expression representing a reference to the pipe itself.\n   */\n  type: R3Reference;\n\n  /**\n   * An expression representing the pipe being compiled, intended for use within a class definition\n   * itself.\n   *\n   * This can differ from the outer `type` if the class is being compiled by ngcc and is inside an\n   * IIFE structure that uses a different name internally.\n   */\n  internalType: o.Expression;\n\n  /**\n   * Number of generic type parameters of the type itself.\n   */\n  typeArgumentCount: number;\n\n  /**\n   * Name of the pipe.\n   */\n  pipeName: string;\n\n  /**\n   * Dependencies of the pipe's constructor.\n   */\n  deps: R3DependencyMetadata[]|null;\n\n  /**\n   * Whether the pipe is marked as pure.\n   */\n  pure: boolean;\n}\n\nexport function compilePipeFromMetadata(metadata: R3PipeMetadata) {\n  const definitionMapValues: {key: string, quoted: boolean, value: o.Expression}[] = [];\n\n  // e.g. `name: 'myPipe'`\n  definitionMapValues.push({key: 'name', value: o.literal(metadata.pipeName), quoted: false});\n\n  // e.g. `type: MyPipe`\n  definitionMapValues.push({key: 'type', value: metadata.type.value, quoted: false});\n\n  // e.g. `pure: true`\n  definitionMapValues.push({key: 'pure', value: o.literal(metadata.pure), quoted: false});\n\n  const expression = o.importExpr(R3.definePipe).callFn([o.literalMap(definitionMapValues)]);\n  const type = new o.ExpressionType(o.importExpr(R3.PipeDefWithMeta, [\n    typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\n    new o.ExpressionType(new o.LiteralExpr(metadata.pipeName)),\n  ]));\n\n  return {expression, type};\n}\n\n/**\n * Write a pipe definition to the output context.\n */\nexport function compilePipeFromRender2(\n    outputCtx: OutputContext, pipe: CompilePipeMetadata, reflector: CompileReflector) {\n  const name = identifierName(pipe.type);\n\n  if (!name) {\n    return error(`Cannot resolve the name of ${pipe.type}`);\n  }\n\n  const type = outputCtx.importExpr(pipe.type.reference);\n  const metadata: R3PipeMetadata = {\n    name,\n    type: wrapReference(type),\n    internalType: type,\n    pipeName: pipe.name,\n    typeArgumentCount: 0,\n    deps: dependenciesFromGlobalMetadata(pipe.type, outputCtx, reflector),\n    pure: pipe.pure,\n  };\n  const res = compilePipeFromMetadata(metadata);\n  const factoryRes = compileFactoryFunction(\n      {...metadata, injectFn: R3.directiveInject, target: R3FactoryTarget.Pipe});\n  const definitionField = outputCtx.constantPool.propertyNameOf(DefinitionKind.Pipe);\n  const ngFactoryDefStatement = new o.ClassStmt(\n      /* name */ name,\n      /* parent */ null,\n      /* fields */\n      [new o.ClassField(\n          /* name */ 'Éµfac',\n          /* type */ o.INFERRED_TYPE,\n          /* modifiers */[o.StmtModifier.Static],\n          /* initializer */ factoryRes.factory)],\n      /* getters */[],\n      /* constructorMethod */ new o.ClassMethod(null, [], []),\n      /* methods */[]);\n  const pipeDefStatement = new o.ClassStmt(\n      /* name */ name,\n      /* parent */ null,\n      /* fields */[new o.ClassField(\n          /* name */ definitionField,\n          /* type */ o.INFERRED_TYPE,\n          /* modifiers */[o.StmtModifier.Static],\n          /* initializer */ res.expression)],\n      /* getters */[],\n      /* constructorMethod */ new o.ClassMethod(null, [], []),\n      /* methods */[]);\n\n  outputCtx.statements.push(ngFactoryDefStatement, pipeDefStatement);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '../core';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class ParserError {\n  public message: string;\n  constructor(\n      message: string, public input: string, public errLocation: string, public ctxLocation?: any) {\n    this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\n  }\n}\n\nexport class ParseSpan {\n  constructor(public start: number, public end: number) {}\n  toAbsolute(absoluteOffset: number): AbsoluteSourceSpan {\n    return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n  }\n}\n\nexport class AST {\n  constructor(\n      public span: ParseSpan,\n      /**\n       * Absolute location of the expression AST in a source code file.\n       */\n      public sourceSpan: AbsoluteSourceSpan) {}\n  visit(visitor: AstVisitor, context: any = null): any { return null; }\n  toString(): string { return 'AST'; }\n}\n\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\nexport class Quote extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public prefix: string,\n      public uninterpretedExpression: string, public location: any) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any { return visitor.visitQuote(this, context); }\n  toString(): string { return 'Quote'; }\n}\n\nexport class EmptyExpr extends AST {\n  visit(visitor: AstVisitor, context: any = null) {\n    // do nothing\n  }\n}\n\nexport class ImplicitReceiver extends AST {\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitImplicitReceiver(this, context);\n  }\n}\n\n/**\n * Multiple expressions separated by a semicolon.\n */\nexport class Chain extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any { return visitor.visitChain(this, context); }\n}\n\nexport class Conditional extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public condition: AST, public trueExp: AST,\n      public falseExp: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitConditional(this, context);\n  }\n}\n\nexport class PropertyRead extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public name: string) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyRead(this, context);\n  }\n}\n\nexport class PropertyWrite extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public name: string,\n      public value: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPropertyWrite(this, context);\n  }\n}\n\nexport class SafePropertyRead extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public name: string) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafePropertyRead(this, context);\n  }\n}\n\nexport class KeyedRead extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public obj: AST, public key: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedRead(this, context);\n  }\n}\n\nexport class KeyedWrite extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public obj: AST, public key: AST,\n      public value: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitKeyedWrite(this, context);\n  }\n}\n\nexport class BindingPipe extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public exp: AST, public name: string,\n      public args: any[], public nameSpan: AbsoluteSourceSpan) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any { return visitor.visitPipe(this, context); }\n}\n\nexport class LiteralPrimitive extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public value: any) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralPrimitive(this, context);\n  }\n}\n\nexport class LiteralArray extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralArray(this, context);\n  }\n}\n\nexport type LiteralMapKey = {\n  key: string; quoted: boolean;\n};\n\nexport class LiteralMap extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public keys: LiteralMapKey[],\n      public values: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitLiteralMap(this, context);\n  }\n}\n\nexport class Interpolation extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public strings: any[],\n      public expressions: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitInterpolation(this, context);\n  }\n}\n\nexport class Binary extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public operation: string, public left: AST,\n      public right: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitBinary(this, context);\n  }\n}\n\nexport class PrefixNot extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitPrefixNot(this, context);\n  }\n}\n\nexport class NonNullAssert extends AST {\n  constructor(span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public expression: AST) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitNonNullAssert(this, context);\n  }\n}\n\nexport class MethodCall extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public name: string,\n      public args: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitMethodCall(this, context);\n  }\n}\n\nexport class SafeMethodCall extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public receiver: AST, public name: string,\n      public args: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitSafeMethodCall(this, context);\n  }\n}\n\nexport class FunctionCall extends AST {\n  constructor(\n      span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public target: AST|null,\n      public args: any[]) {\n    super(span, sourceSpan);\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    return visitor.visitFunctionCall(this, context);\n  }\n}\n\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\nexport class AbsoluteSourceSpan {\n  constructor(public readonly start: number, public readonly end: number) {}\n}\n\nexport class ASTWithSource extends AST {\n  constructor(\n      public ast: AST, public source: string|null, public location: string, absoluteOffset: number,\n      public errors: ParserError[]) {\n    super(\n        new ParseSpan(0, source === null ? 0 : source.length),\n        new AbsoluteSourceSpan(\n            absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n  }\n  visit(visitor: AstVisitor, context: any = null): any {\n    if (visitor.visitASTWithSource) {\n      return visitor.visitASTWithSource(this, context);\n    }\n    return this.ast.visit(visitor, context);\n  }\n  toString(): string { return `${this.source} in ${this.location}`; }\n}\n\nexport class TemplateBinding {\n  constructor(\n      public span: ParseSpan, sourceSpan: AbsoluteSourceSpan, public key: string,\n      public keyIsVar: boolean, public name: string, public expression: ASTWithSource|null) {}\n}\n\nexport interface AstVisitor {\n  visitBinary(ast: Binary, context: any): any;\n  visitChain(ast: Chain, context: any): any;\n  visitConditional(ast: Conditional, context: any): any;\n  visitFunctionCall(ast: FunctionCall, context: any): any;\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any;\n  visitInterpolation(ast: Interpolation, context: any): any;\n  visitKeyedRead(ast: KeyedRead, context: any): any;\n  visitKeyedWrite(ast: KeyedWrite, context: any): any;\n  visitLiteralArray(ast: LiteralArray, context: any): any;\n  visitLiteralMap(ast: LiteralMap, context: any): any;\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any;\n  visitMethodCall(ast: MethodCall, context: any): any;\n  visitPipe(ast: BindingPipe, context: any): any;\n  visitPrefixNot(ast: PrefixNot, context: any): any;\n  visitNonNullAssert(ast: NonNullAssert, context: any): any;\n  visitPropertyRead(ast: PropertyRead, context: any): any;\n  visitPropertyWrite(ast: PropertyWrite, context: any): any;\n  visitQuote(ast: Quote, context: any): any;\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any;\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any;\n  visitASTWithSource?(ast: ASTWithSource, context: any): any;\n  visit?(ast: AST, context?: any): any;\n}\n\nexport class NullAstVisitor implements AstVisitor {\n  visitBinary(ast: Binary, context: any): any {}\n  visitChain(ast: Chain, context: any): any {}\n  visitConditional(ast: Conditional, context: any): any {}\n  visitFunctionCall(ast: FunctionCall, context: any): any {}\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any {}\n  visitInterpolation(ast: Interpolation, context: any): any {}\n  visitKeyedRead(ast: KeyedRead, context: any): any {}\n  visitKeyedWrite(ast: KeyedWrite, context: any): any {}\n  visitLiteralArray(ast: LiteralArray, context: any): any {}\n  visitLiteralMap(ast: LiteralMap, context: any): any {}\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any {}\n  visitMethodCall(ast: MethodCall, context: any): any {}\n  visitPipe(ast: BindingPipe, context: any): any {}\n  visitPrefixNot(ast: PrefixNot, context: any): any {}\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {}\n  visitPropertyRead(ast: PropertyRead, context: any): any {}\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {}\n  visitQuote(ast: Quote, context: any): any {}\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any {}\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {}\n}\n\nexport class RecursiveAstVisitor implements AstVisitor {\n  visitBinary(ast: Binary, context: any): any {\n    ast.left.visit(this, context);\n    ast.right.visit(this, context);\n    return null;\n  }\n  visitChain(ast: Chain, context: any): any { return this.visitAll(ast.expressions, context); }\n  visitConditional(ast: Conditional, context: any): any {\n    ast.condition.visit(this, context);\n    ast.trueExp.visit(this, context);\n    ast.falseExp.visit(this, context);\n    return null;\n  }\n  visitPipe(ast: BindingPipe, context: any): any {\n    ast.exp.visit(this, context);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n  visitFunctionCall(ast: FunctionCall, context: any): any {\n    ast.target !.visit(this, context);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): any { return null; }\n  visitInterpolation(ast: Interpolation, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitKeyedRead(ast: KeyedRead, context: any): any {\n    ast.obj.visit(this, context);\n    ast.key.visit(this, context);\n    return null;\n  }\n  visitKeyedWrite(ast: KeyedWrite, context: any): any {\n    ast.obj.visit(this, context);\n    ast.key.visit(this, context);\n    ast.value.visit(this, context);\n    return null;\n  }\n  visitLiteralArray(ast: LiteralArray, context: any): any {\n    return this.visitAll(ast.expressions, context);\n  }\n  visitLiteralMap(ast: LiteralMap, context: any): any { return this.visitAll(ast.values, context); }\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): any { return null; }\n  visitMethodCall(ast: MethodCall, context: any): any {\n    ast.receiver.visit(this, context);\n    return this.visitAll(ast.args, context);\n  }\n  visitPrefixNot(ast: PrefixNot, context: any): any {\n    ast.expression.visit(this, context);\n    return null;\n  }\n  visitNonNullAssert(ast: NonNullAssert, context: any): any {\n    ast.expression.visit(this, context);\n    return null;\n  }\n  visitPropertyRead(ast: PropertyRead, context: any): any {\n    ast.receiver.visit(this, context);\n    return null;\n  }\n  visitPropertyWrite(ast: PropertyWrite, context: any): any {\n    ast.receiver.visit(this, context);\n    ast.value.visit(this, context);\n    return null;\n  }\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): any {\n    ast.receiver.visit(this, context);\n    return null;\n  }\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): any {\n    ast.receiver.visit(this, context);\n    return this.visitAll(ast.args, context);\n  }\n  visitAll(asts: AST[], context: any): any {\n    asts.forEach(ast => ast.visit(this, context));\n    return null;\n  }\n  visitQuote(ast: Quote, context: any): any { return null; }\n}\n\nexport class AstTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST { return ast; }\n\n  visitInterpolation(ast: Interpolation, context: any): AST {\n    return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST {\n    return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n  }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    return new PropertyRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    return new PropertyWrite(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    return new SafePropertyRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.name);\n  }\n\n  visitMethodCall(ast: MethodCall, context: any): AST {\n    return new MethodCall(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n    return new SafeMethodCall(\n        ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n  }\n\n  visitFunctionCall(ast: FunctionCall, context: any): AST {\n    return new FunctionCall(\n        ast.span, ast.sourceSpan, ast.target !.visit(this), this.visitAll(ast.args));\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    return new Binary(\n        ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    return new Conditional(\n        ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this),\n        ast.falseExp.visit(this));\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    return new BindingPipe(\n        ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args),\n        ast.nameSpan);\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    return new KeyedRead(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this));\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    return new KeyedWrite(\n        ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    for (let i = 0; i < asts.length; ++i) {\n      res[i] = asts[i].visit(this);\n    }\n    return res;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n  }\n\n  visitQuote(ast: Quote, context: any): AST {\n    return new Quote(\n        ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);\n  }\n}\n\n// A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\nexport class AstMemoryEfficientTransformer implements AstVisitor {\n  visitImplicitReceiver(ast: ImplicitReceiver, context: any): AST { return ast; }\n\n  visitInterpolation(ast: Interpolation, context: any): Interpolation {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions)\n      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n    return ast;\n  }\n\n  visitLiteralPrimitive(ast: LiteralPrimitive, context: any): AST { return ast; }\n\n  visitPropertyRead(ast: PropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new PropertyRead(ast.span, ast.sourceSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitPropertyWrite(ast: PropertyWrite, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const value = ast.value.visit(this);\n    if (receiver !== ast.receiver || value !== ast.value) {\n      return new PropertyWrite(ast.span, ast.sourceSpan, receiver, ast.name, value);\n    }\n    return ast;\n  }\n\n  visitSafePropertyRead(ast: SafePropertyRead, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    if (receiver !== ast.receiver) {\n      return new SafePropertyRead(ast.span, ast.sourceSpan, receiver, ast.name);\n    }\n    return ast;\n  }\n\n  visitMethodCall(ast: MethodCall, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new MethodCall(ast.span, ast.sourceSpan, receiver, ast.name, args);\n    }\n    return ast;\n  }\n\n  visitSafeMethodCall(ast: SafeMethodCall, context: any): AST {\n    const receiver = ast.receiver.visit(this);\n    const args = this.visitAll(ast.args);\n    if (receiver !== ast.receiver || args !== ast.args) {\n      return new SafeMethodCall(ast.span, ast.sourceSpan, receiver, ast.name, args);\n    }\n    return ast;\n  }\n\n  visitFunctionCall(ast: FunctionCall, context: any): AST {\n    const target = ast.target && ast.target.visit(this);\n    const args = this.visitAll(ast.args);\n    if (target !== ast.target || args !== ast.args) {\n      return new FunctionCall(ast.span, ast.sourceSpan, target, args);\n    }\n    return ast;\n  }\n\n  visitLiteralArray(ast: LiteralArray, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n  visitLiteralMap(ast: LiteralMap, context: any): AST {\n    const values = this.visitAll(ast.values);\n    if (values !== ast.values) {\n      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n    }\n    return ast;\n  }\n\n  visitBinary(ast: Binary, context: any): AST {\n    const left = ast.left.visit(this);\n    const right = ast.right.visit(this);\n    if (left !== ast.left || right !== ast.right) {\n      return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n    }\n    return ast;\n  }\n\n  visitPrefixNot(ast: PrefixNot, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new PrefixNot(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitNonNullAssert(ast: NonNullAssert, context: any): AST {\n    const expression = ast.expression.visit(this);\n    if (expression !== ast.expression) {\n      return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n    }\n    return ast;\n  }\n\n  visitConditional(ast: Conditional, context: any): AST {\n    const condition = ast.condition.visit(this);\n    const trueExp = ast.trueExp.visit(this);\n    const falseExp = ast.falseExp.visit(this);\n    if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n      return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n    }\n    return ast;\n  }\n\n  visitPipe(ast: BindingPipe, context: any): AST {\n    const exp = ast.exp.visit(this);\n    const args = this.visitAll(ast.args);\n    if (exp !== ast.exp || args !== ast.args) {\n      return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n    }\n    return ast;\n  }\n\n  visitKeyedRead(ast: KeyedRead, context: any): AST {\n    const obj = ast.obj.visit(this);\n    const key = ast.key.visit(this);\n    if (obj !== ast.obj || key !== ast.key) {\n      return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n    }\n    return ast;\n  }\n\n  visitKeyedWrite(ast: KeyedWrite, context: any): AST {\n    const obj = ast.obj.visit(this);\n    const key = ast.key.visit(this);\n    const value = ast.value.visit(this);\n    if (obj !== ast.obj || key !== ast.key || value !== ast.value) {\n      return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n    }\n    return ast;\n  }\n\n  visitAll(asts: any[]): any[] {\n    const res = [];\n    let modified = false;\n    for (let i = 0; i < asts.length; ++i) {\n      const original = asts[i];\n      const value = original.visit(this);\n      res[i] = value;\n      modified = modified || value !== original;\n    }\n    return modified ? res : asts;\n  }\n\n  visitChain(ast: Chain, context: any): AST {\n    const expressions = this.visitAll(ast.expressions);\n    if (expressions !== ast.expressions) {\n      return new Chain(ast.span, ast.sourceSpan, expressions);\n    }\n    return ast;\n  }\n\n  visitQuote(ast: Quote, context: any): AST { return ast; }\n}\n\nexport function visitAstChildren(ast: AST, visitor: AstVisitor, context?: any) {\n  function visit(ast: AST) {\n    visitor.visit && visitor.visit(ast, context) || ast.visit(visitor, context);\n  }\n\n  function visitAll<T extends AST>(asts: T[]) { asts.forEach(visit); }\n\n  ast.visit({\n    visitBinary(ast) {\n      visit(ast.left);\n      visit(ast.right);\n    },\n    visitChain(ast) { visitAll(ast.expressions); },\n    visitConditional(ast) {\n      visit(ast.condition);\n      visit(ast.trueExp);\n      visit(ast.falseExp);\n    },\n    visitFunctionCall(ast) {\n      if (ast.target) {\n        visit(ast.target);\n      }\n      visitAll(ast.args);\n    },\n    visitImplicitReceiver(ast) {},\n    visitInterpolation(ast) { visitAll(ast.expressions); },\n    visitKeyedRead(ast) {\n      visit(ast.obj);\n      visit(ast.key);\n    },\n    visitKeyedWrite(ast) {\n      visit(ast.obj);\n      visit(ast.key);\n      visit(ast.obj);\n    },\n    visitLiteralArray(ast) { visitAll(ast.expressions); },\n    visitLiteralMap(ast) {},\n    visitLiteralPrimitive(ast) {},\n    visitMethodCall(ast) {\n      visit(ast.receiver);\n      visitAll(ast.args);\n    },\n    visitPipe(ast) {\n      visit(ast.exp);\n      visitAll(ast.args);\n    },\n    visitPrefixNot(ast) { visit(ast.expression); },\n    visitNonNullAssert(ast) { visit(ast.expression); },\n    visitPropertyRead(ast) { visit(ast.receiver); },\n    visitPropertyWrite(ast) {\n      visit(ast.receiver);\n      visit(ast.value);\n    },\n    visitQuote(ast) {},\n    visitSafeMethodCall(ast) {\n      visit(ast.receiver);\n      visitAll(ast.args);\n    },\n    visitSafePropertyRead(ast) { visit(ast.receiver); },\n  });\n}\n\n\n// Bindings\n\nexport class ParsedProperty {\n  public readonly isLiteral: boolean;\n  public readonly isAnimation: boolean;\n\n  constructor(\n      public name: string, public expression: ASTWithSource, public type: ParsedPropertyType,\n      public sourceSpan: ParseSourceSpan, public valueSpan?: ParseSourceSpan) {\n    this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n    this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n  }\n}\n\nexport enum ParsedPropertyType {\n  DEFAULT,\n  LITERAL_ATTR,\n  ANIMATION\n}\n\nexport const enum ParsedEventType {\n  // DOM or Directive event\n  Regular,\n  // Animation specific event\n  Animation,\n}\n\nexport class ParsedEvent {\n  // Regular events have a target\n  // Animation events have a phase\n  constructor(\n      public name: string, public targetOrPhase: string, public type: ParsedEventType,\n      public handler: AST, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan) {}\n}\n\nexport class ParsedVariable {\n  constructor(public name: string, public value: string, public sourceSpan: ParseSourceSpan) {}\n}\n\nexport const enum BindingType {\n  // A regular binding to a property (e.g. `[property]=\"expression\"`).\n  Property,\n  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n  Attribute,\n  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n  Class,\n  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n  Style,\n  // A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n  Animation,\n}\n\nexport class BoundElementProperty {\n  constructor(\n      public name: string, public type: BindingType, public securityContext: SecurityContext,\n      public value: AST, public unit: string|null, public sourceSpan: ParseSourceSpan,\n      public valueSpan?: ParseSourceSpan) {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as cdAst from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport class EventHandlerVars { static event = o.variable('$event'); }\n\nexport interface LocalResolver {\n  getLocal(name: string): o.Expression|null;\n  notifyImplicitReceiverUse(): void;\n}\n\nexport class ConvertActionBindingResult {\n  /**\n   * Store statements which are render3 compatible.\n   */\n  render3Stmts: o.Statement[];\n  constructor(\n      /**\n       * Render2 compatible statements,\n       */\n      public stmts: o.Statement[],\n      /**\n       * Variable name used with render2 compatible statements.\n       */\n      public allowDefault: o.ReadVarExpr) {\n    /**\n     * This is bit of a hack. It converts statements which render2 expects to statements which are\n     * expected by render3.\n     *\n     * Example: `<div click=\"doSomething($event)\">` will generate:\n     *\n     * Render3:\n     * ```\n     * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\n     * return pd_b;\n     * ```\n     *\n     * but render2 expects:\n     * ```\n     * return ctx.doSomething($event);\n     * ```\n     */\n    // TODO(misko): remove this hack once we no longer support ViewEngine.\n    this.render3Stmts = stmts.map((statement: o.Statement) => {\n      if (statement instanceof o.DeclareVarStmt && statement.name == allowDefault.name &&\n          statement.value instanceof o.BinaryOperatorExpr) {\n        const lhs = statement.value.lhs as o.CastExpr;\n        return new o.ReturnStatement(lhs.value);\n      }\n      return statement;\n    });\n  }\n}\n\nexport type InterpolationFunction = (args: o.Expression[]) => o.Expression;\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver | null, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string, interpolationFunction?: InterpolationFunction,\n    baseSourceSpan?: ParseSourceSpan): ConvertActionBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) => {\n          // Note: no caching for literal maps in actions.\n          return (values: o.Expression[]) => {\n            const entries = keys.map((k, i) => ({\n                                       key: k.key,\n                                       value: values[i],\n                                       quoted: k.quoted,\n                                     }));\n            return o.literalMap(entries);\n          };\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const visitor = new _AstToIrVisitor(\n      localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan);\n  const actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const lastIndex = actionStmts.length - 1;\n  let preventDefaultVar: o.ReadVarExpr = null !;\n  if (lastIndex >= 0) {\n    const lastStatement = actionStmts[lastIndex];\n    const returnExpr = convertStmtIntoExpression(lastStatement);\n    if (returnExpr) {\n      // Note: We need to cast the result of the method call to dynamic,\n      // as it might be a void method!\n      preventDefaultVar = createPreventDefaultVar(bindingId);\n      actionStmts[lastIndex] =\n          preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))\n              .toDeclStmt(null, [o.StmtModifier.Final]);\n    }\n  }\n  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n\nexport interface BuiltinConverter { (args: o.Expression[]): o.Expression; }\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: {key: string, quoted: boolean}[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\n\nexport class ConvertPropertyBindingResult {\n  constructor(public stmts: o.Statement[], public currValExpr: o.Expression) {}\n}\n\nexport enum BindingForm {\n  // The general form of binding expression, supports all expressions.\n  General,\n\n  // Try to generate a simple binding (no temporaries or statements)\n  // otherwise generate a general binding\n  TrySimple,\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver | null, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string, form: BindingForm,\n    interpolationFunction?: InterpolationFunction): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const currValExpr = createCurrValueExpr(bindingId);\n  const visitor =\n      new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n  const outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n  const stmts: o.Statement[] = getStatementsFromVisitor(visitor, bindingId);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {\n    return new ConvertPropertyBindingResult([], outputExpr);\n  }\n\n  stmts.push(currValExpr.set(outputExpr).toDeclStmt(o.DYNAMIC_TYPE, [o.StmtModifier.Final]));\n  return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\nexport function convertUpdateArguments(\n    localResolver: LocalResolver, contextVariableExpression: o.Expression,\n    expressionWithArgumentsToExtract: cdAst.AST, bindingId: string) {\n  const visitor =\n      new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);\n  const outputExpr: o.InvokeFunctionExpr =\n      expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  const stmts = getStatementsFromVisitor(visitor, bindingId);\n\n  // Removing the first argument, because it was a length for ViewEngine, not Ivy.\n  let args = outputExpr.args.slice(1);\n  if (expressionWithArgumentsToExtract instanceof cdAst.Interpolation) {\n    // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n    // args returned to just the value, because we're going to pass it to a special instruction.\n    const strings = expressionWithArgumentsToExtract.strings;\n    if (args.length === 3 && strings[0] === '' && strings[1] === '') {\n      // Single argument interpolate instructions.\n      args = [args[1]];\n    } else if (args.length >= 19) {\n      // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n      // an array of arguments\n      args = [o.literalArr(args)];\n    }\n  }\n  return {stmts, args};\n}\n\nfunction getStatementsFromVisitor(visitor: _AstToIrVisitor, bindingId: string) {\n  const stmts: o.Statement[] = [];\n  for (let i = 0; i < visitor.temporaryCount; i++) {\n    stmts.push(temporaryDeclaration(bindingId, i));\n  }\n  return stmts;\n}\n\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n\nexport function temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber), o.NULL_EXPR);\n}\n\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nenum _Mode {\n  Statement,\n  Expression\n}\n\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n  constructor(private _converterFactory: BuiltinConverterFactory) { super(); }\n  visitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n  visitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args,\n        this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n  visitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const args = ast.values.map(ast => ast.visit(this, context));\n\n    return new BuiltinFunctionCall(\n        ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\n  private _nodeMap = new Map<cdAst.AST, cdAst.AST>();\n  private _resultMap = new Map<cdAst.AST, o.Expression>();\n  private _currentTemporary: number = 0;\n  public temporaryCount: number = 0;\n  public usesImplicitReceiver: boolean = false;\n\n  constructor(\n      private _localResolver: LocalResolver, private _implicitReceiver: o.Expression,\n      private bindingId: string, private interpolationFunction: InterpolationFunction|undefined,\n      private baseSourceSpan?: ParseSourceSpan) {}\n\n  visitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression),\n            undefined, this.convertSourceSpan(ast.span)));\n  }\n\n  visitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n\n  visitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const value: o.Expression = this._visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode, value.conditional(\n                  this._visit(ast.trueExp, _Mode.Expression),\n                  this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));\n  }\n\n  visitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n\n  visitFunctionCall(ast: cdAst.FunctionCall, mode: _Mode): any {\n    const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n    let fnResult: o.Expression;\n    if (ast instanceof BuiltinFunctionCall) {\n      fnResult = ast.converter(convertedArgs);\n    } else {\n      fnResult = this._visit(ast.target !, _Mode.Expression)\n                     .callFn(convertedArgs, this.convertSourceSpan(ast.span));\n    }\n    return convertToStatementIfNeeded(mode, fnResult);\n  }\n\n  visitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    this.usesImplicitReceiver = true;\n    return this._implicitReceiver;\n  }\n\n  visitInterpolation(ast: cdAst.Interpolation, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    const args = [o.literal(ast.expressions.length)];\n    for (let i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this._visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    if (this.interpolationFunction) {\n      return this.interpolationFunction(args);\n    }\n    return ast.expressions.length <= 9 ?\n        o.importExpr(Identifiers.inlineInterpolate).callFn(args) :\n        o.importExpr(Identifiers.interpolate).callFn([\n          args[0], o.literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))\n        ]);\n  }\n\n  visitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n\n  visitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const obj: o.Expression = this._visit(ast.obj, _Mode.Expression);\n    const key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const value: o.Expression = this._visit(ast.value, _Mode.Expression);\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n\n  visitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n\n  visitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n\n  visitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    // For literal values of null, undefined, true, or false allow type interference\n    // to infer the type.\n    const type =\n        ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\n        o.INFERRED_TYPE :\n        undefined;\n    return convertToStatementIfNeeded(\n        mode, o.literal(ast.value, type, this.convertSourceSpan(ast.span)));\n  }\n\n  private _getLocal(name: string): o.Expression|null { return this._localResolver.getLocal(name); }\n\n  visitMethodCall(ast: cdAst.MethodCall, mode: _Mode): any {\n    if (ast.receiver instanceof cdAst.ImplicitReceiver && ast.name == '$any') {\n      const args = this.visitAll(ast.args, _Mode.Expression) as any[];\n      if (args.length != 1) {\n        throw new Error(\n            `Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);\n      }\n      return (args[0] as o.Expression).cast(o.DYNAMIC_TYPE, this.convertSourceSpan(ast.span));\n    }\n\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      const args = this.visitAll(ast.args, _Mode.Expression);\n      const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      let result: any = null;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        const varExpr = this._getLocal(ast.name);\n        if (varExpr) {\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          result = varExpr.callFn(args);\n        }\n      }\n      if (result == null) {\n        result = receiver.callMethod(ast.name, args, this.convertSourceSpan(ast.span));\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(\n        mode, o.assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n  }\n\n  visitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let result: any = null;\n      const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      const receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name);\n        if (result) {\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n        }\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n\n  visitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    const prevUsesImplicitReceiver = this.usesImplicitReceiver;\n\n    let varExpr: o.ReadPropExpr|null = null;\n    if (receiver === this._implicitReceiver) {\n      const localExpr = this._getLocal(ast.name);\n      if (localExpr) {\n        if (localExpr instanceof o.ReadPropExpr) {\n          // If the local variable is a property read expression, it's a reference\n          // to a 'context.property' value and will be used as the target of the\n          // write expression.\n          varExpr = localExpr;\n          // Restore the previous \"usesImplicitReceiver\" state since the implicit\n          // receiver has been replaced with a resolved local expression.\n          this.usesImplicitReceiver = prevUsesImplicitReceiver;\n        } else {\n          // Otherwise it's an error.\n          const receiver = ast.name;\n          const value = (ast.value instanceof cdAst.PropertyRead) ? ast.value.name : undefined;\n          throw new Error(\n              `Cannot assign value \"${value}\" to template variable \"${receiver}\". Template variables are read-only.`);\n        }\n      }\n    }\n    // If no local expression could be produced, use the original receiver's\n    // property as the target.\n    if (varExpr === null) {\n      varExpr = receiver.prop(ast.name);\n    }\n    return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n  }\n\n  visitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitSafeMethodCall(ast: cdAst.SafeMethodCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n\n  visitAll(asts: cdAst.AST[], mode: _Mode): any { return asts.map(ast => this._visit(ast, mode)); }\n\n  visitQuote(ast: cdAst.Quote, mode: _Mode): any {\n    throw new Error(`Quotes are not supported for evaluation!\n        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\n  }\n\n  private _visit(ast: cdAst.AST, mode: _Mode): any {\n    const result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n\n  private convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafeMethodCall|cdAst.SafePropertyRead, mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  .   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n    let temporary: o.ReadVarExpr = undefined !;\n    if (this.needsTemporary(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n      this._nodeMap.set(\n          leftMostSafe, new cdAst.MethodCall(\n                            leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver,\n                            leftMostSafe.name, leftMostSafe.args));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe, new cdAst.PropertyRead(\n                            leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver,\n                            leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const access = this._visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allocated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.literal(null), access));\n  }\n\n  // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n  // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n  // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n  // safe method call as this needs to be transformed initially to:\n  //   a == null ? null : a.c.b.c?.d.e\n  // then to:\n  //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n  private leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeMethodCall {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n      visitBinary(ast: cdAst.Binary) { return null; },\n      visitChain(ast: cdAst.Chain) { return null; },\n      visitConditional(ast: cdAst.Conditional) { return null; },\n      visitFunctionCall(ast: cdAst.FunctionCall) { return null; },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return null; },\n      visitInterpolation(ast: cdAst.Interpolation) { return null; },\n      visitKeyedRead(ast: cdAst.KeyedRead) { return visit(this, ast.obj); },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) { return null; },\n      visitLiteralArray(ast: cdAst.LiteralArray) { return null; },\n      visitLiteralMap(ast: cdAst.LiteralMap) { return null; },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return null; },\n      visitMethodCall(ast: cdAst.MethodCall) { return visit(this, ast.receiver); },\n      visitPipe(ast: cdAst.BindingPipe) { return null; },\n      visitPrefixNot(ast: cdAst.PrefixNot) { return null; },\n      visitNonNullAssert(ast: cdAst.NonNullAssert) { return null; },\n      visitPropertyRead(ast: cdAst.PropertyRead) { return visit(this, ast.receiver); },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) { return null; },\n      visitQuote(ast: cdAst.Quote) { return null; },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) { return visit(this, ast.receiver) || ast; },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n\n  // Returns true of the AST includes a method or a pipe indicating that, if the\n  // expression is used as the target of a safe property or method access then\n  // the expression should be stored into a temporary variable.\n  private needsTemporary(ast: cdAst.AST): boolean {\n    const visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n      visitBinary(ast: cdAst.Binary):\n          boolean{return visit(this, ast.left) || visit(this, ast.right);},\n      visitChain(ast: cdAst.Chain) { return false; },\n      visitConditional(ast: cdAst.Conditional):\n          boolean{return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                      visit(this, ast.falseExp);},\n      visitFunctionCall(ast: cdAst.FunctionCall) { return true; },\n      visitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return false; },\n      visitInterpolation(ast: cdAst.Interpolation) { return visitSome(this, ast.expressions); },\n      visitKeyedRead(ast: cdAst.KeyedRead) { return false; },\n      visitKeyedWrite(ast: cdAst.KeyedWrite) { return false; },\n      visitLiteralArray(ast: cdAst.LiteralArray) { return true; },\n      visitLiteralMap(ast: cdAst.LiteralMap) { return true; },\n      visitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return false; },\n      visitMethodCall(ast: cdAst.MethodCall) { return true; },\n      visitPipe(ast: cdAst.BindingPipe) { return true; },\n      visitPrefixNot(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n      visitNonNullAssert(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n      visitPropertyRead(ast: cdAst.PropertyRead) { return false; },\n      visitPropertyWrite(ast: cdAst.PropertyWrite) { return false; },\n      visitQuote(ast: cdAst.Quote) { return false; },\n      visitSafeMethodCall(ast: cdAst.SafeMethodCall) { return true; },\n      visitSafePropertyRead(ast: cdAst.SafePropertyRead) { return false; }\n    });\n  }\n\n  private allocateTemporary(): o.ReadVarExpr {\n    const tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n\n  private releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n\n  /**\n   * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n   *\n   * `ParseSpan` objects are relative to the start of the expression.\n   * This method converts these to full `ParseSourceSpan` objects that\n   * show where the span is within the overall source file.\n   *\n   * @param span the relative span to convert.\n   * @returns a `ParseSourceSpan` for the given span or null if no\n   * `baseSourceSpan` was provided to this class.\n   */\n  private convertSourceSpan(span: cdAst.ParseSpan) {\n    if (this.baseSourceSpan) {\n      const start = this.baseSourceSpan.start.moveBy(span.start);\n      const end = this.baseSourceSpan.start.moveBy(span.end);\n      return new ParseSourceSpan(start, end);\n    } else {\n      return null;\n    }\n  }\n}\n\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    (<any[]>arg).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\n\nclass DefaultLocalResolver implements LocalResolver {\n  notifyImplicitReceiverUse(): void {}\n  getLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n\nfunction createCurrValueExpr(bindingId: string): o.ReadVarExpr {\n  return o.variable(`currVal_${bindingId}`);  // fix syntax highlighting: `\n}\n\nfunction createPreventDefaultVar(bindingId: string): o.ReadVarExpr {\n  return o.variable(`pd_${bindingId}`);\n}\n\nfunction convertStmtIntoExpression(stmt: o.Statement): o.Expression|null {\n  if (stmt instanceof o.ExpressionStatement) {\n    return stmt.expr;\n  } else if (stmt instanceof o.ReturnStatement) {\n    return stmt.value;\n  }\n  return null;\n}\n\nexport class BuiltinFunctionCall extends cdAst.FunctionCall {\n  constructor(\n      span: cdAst.ParseSpan, sourceSpan: cdAst.AbsoluteSourceSpan, public args: cdAst.AST[],\n      public converter: BuiltinConverter) {\n    super(span, sourceSpan, null, args);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n *\n * Please make sure to keep to edits in sync with the source file.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\n  this feature.\n\n  By default, rules are prefixed with the host element tag name\n  as a descendant selector. This ensures styling does not leak out of the 'top'\n  of the element's ShadowDOM. For example,\n\n  div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n  x-foo div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\n  selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\n\nexport class ShadowCss {\n  strictStyling: boolean = true;\n\n  constructor() {}\n\n  /*\n  * Shim some cssText with the given selector. Returns cssText that can\n  * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\n  *\n  * When strictStyling is true:\n  * - selector is the attribute added to all elements inside the host,\n  * - hostSelector is the attribute added to the host itself.\n  */\n  shimCssText(cssText: string, selector: string, hostSelector: string = ''): string {\n    const commentsWithHash = extractCommentsWithHash(cssText);\n    cssText = stripComments(cssText);\n    cssText = this._insertDirectives(cssText);\n\n    const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n    return [scopedCssText, ...commentsWithHash].join('\\n');\n  }\n\n  private _insertDirectives(cssText: string): string {\n    cssText = this._insertPolyfillDirectivesInCssText(cssText);\n    return this._insertPolyfillRulesInCssText(cssText);\n  }\n\n  /*\n   * Process styles to convert native ShadowDOM rules that will trip\n   * up the css parser; we rely on decorating the stylesheet with inert rules.\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-next-selector { content: ':host menu-item'; }\n   * ::content menu-item {\n   *\n   * to this:\n   *\n   * scopeName menu-item {\n   *\n  **/\n  private _insertPolyfillDirectivesInCssText(cssText: string): string {\n    // Difference with webcomponents.js: does not handle comments\n    return cssText.replace(\n        _cssContentNextSelectorRe, function(...m: string[]) { return m[2] + '{'; });\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   *\n   * For example, we convert this rule:\n   *\n   * polyfill-rule {\n   *   content: ':host menu-item';\n   * ...\n   * }\n   *\n   * to this:\n   *\n   * scopeName menu-item {...}\n   *\n  **/\n  private _insertPolyfillRulesInCssText(cssText: string): string {\n    // Difference with webcomponents.js: does not handle comments\n    return cssText.replace(_cssContentRuleRe, (...m: string[]) => {\n      const rule = m[0].replace(m[1], '').replace(m[2], '');\n      return m[4] + rule;\n    });\n  }\n\n  /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n   *\n   *  .foo {... }\n   *\n   *  and converts this to\n   *\n   *  scopeName .foo { ... }\n  */\n  private _scopeCssText(cssText: string, scopeSelector: string, hostSelector: string): string {\n    const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\n    // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n    cssText = this._insertPolyfillHostInCssText(cssText);\n    cssText = this._convertColonHost(cssText);\n    cssText = this._convertColonHostContext(cssText);\n    cssText = this._convertShadowDOMSelectors(cssText);\n    if (scopeSelector) {\n      cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n    }\n    cssText = cssText + '\\n' + unscopedRules;\n    return cssText.trim();\n  }\n\n  /*\n   * Process styles to add rules which will only apply under the polyfill\n   * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n   * occasions, e.g. -webkit-calc on Safari.)\n   * For example, we convert this rule:\n   *\n   * @polyfill-unscoped-rule {\n   *   content: 'menu-item';\n   * ... }\n   *\n   * to this:\n   *\n   * menu-item {...}\n   *\n  **/\n  private _extractUnscopedRulesFromCssText(cssText: string): string {\n    // Difference with webcomponents.js: does not handle comments\n    let r = '';\n    let m: RegExpExecArray|null;\n    _cssContentUnscopedRuleRe.lastIndex = 0;\n    while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n      const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n      r += rule + '\\n\\n';\n    }\n    return r;\n  }\n\n  /*\n   * convert a rule like :host(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar\n  */\n  private _convertColonHost(cssText: string): string {\n    return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n  }\n\n  /*\n   * convert a rule like :host-context(.foo) > .bar { }\n   *\n   * to\n   *\n   * .foo<scopeName> > .bar, .foo scopeName > .bar { }\n   *\n   * and\n   *\n   * :host-context(.foo:host) .bar { ... }\n   *\n   * to\n   *\n   * .foo<scopeName> .bar { ... }\n  */\n  private _convertColonHostContext(cssText: string): string {\n    return this._convertColonRule(\n        cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n  }\n\n  private _convertColonRule(cssText: string, regExp: RegExp, partReplacer: Function): string {\n    // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n    return cssText.replace(regExp, function(...m: string[]) {\n      if (m[2]) {\n        const parts = m[2].split(',');\n        const r: string[] = [];\n        for (let i = 0; i < parts.length; i++) {\n          const p = parts[i].trim();\n          if (!p) break;\n          r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n        }\n        return r.join(',');\n      } else {\n        return _polyfillHostNoCombinator + m[3];\n      }\n    });\n  }\n\n  private _colonHostContextPartReplacer(host: string, part: string, suffix: string): string {\n    if (part.indexOf(_polyfillHost) > -1) {\n      return this._colonHostPartReplacer(host, part, suffix);\n    } else {\n      return host + part + suffix + ', ' + part + ' ' + host + suffix;\n    }\n  }\n\n  private _colonHostPartReplacer(host: string, part: string, suffix: string): string {\n    return host + part.replace(_polyfillHost, '') + suffix;\n  }\n\n  /*\n   * Convert combinators like ::shadow and pseudo-elements like ::content\n   * by replacing with space.\n  */\n  private _convertShadowDOMSelectors(cssText: string): string {\n    return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\n  }\n\n  // change a selector like 'div' to 'name div'\n  private _scopeSelectors(cssText: string, scopeSelector: string, hostSelector: string): string {\n    return processRules(cssText, (rule: CssRule) => {\n      let selector = rule.selector;\n      let content = rule.content;\n      if (rule.selector[0] != '@') {\n        selector =\n            this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);\n      } else if (\n          rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\n          rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n        content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\n      }\n      return new CssRule(selector, content);\n    });\n  }\n\n  private _scopeSelector(\n      selector: string, scopeSelector: string, hostSelector: string, strict: boolean): string {\n    return selector.split(',')\n        .map(part => part.trim().split(_shadowDeepSelectors))\n        .map((deepParts) => {\n          const [shallowPart, ...otherParts] = deepParts;\n          const applyScope = (shallowPart: string) => {\n            if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\n              return strict ?\n                  this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\n                  this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n            } else {\n              return shallowPart;\n            }\n          };\n          return [applyScope(shallowPart), ...otherParts].join(' ');\n        })\n        .join(', ');\n  }\n\n  private _selectorNeedsScoping(selector: string, scopeSelector: string): boolean {\n    const re = this._makeScopeMatcher(scopeSelector);\n    return !re.test(selector);\n  }\n\n  private _makeScopeMatcher(scopeSelector: string): RegExp {\n    const lre = /\\[/g;\n    const rre = /\\]/g;\n    scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n    return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n  }\n\n  private _applySelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    // Difference from webcomponents.js: scopeSelector could not be an array\n    return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n  }\n\n  // scope via name and [is=name]\n  private _applySimpleSelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n    _polyfillHostRe.lastIndex = 0;\n    if (_polyfillHostRe.test(selector)) {\n      const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;\n      return selector\n          .replace(\n              _polyfillHostNoCombinatorRe,\n              (hnc, selector) => {\n                return selector.replace(\n                    /([^:]*)(:*)(.*)/,\n                    (_: string, before: string, colon: string, after: string) => {\n                      return before + replaceBy + colon + after;\n                    });\n              })\n          .replace(_polyfillHostRe, replaceBy + ' ');\n    }\n\n    return scopeSelector + ' ' + selector;\n  }\n\n  // return a selector with [name] suffix on each simple selector\n  // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n  private _applyStrictSelectorScope(selector: string, scopeSelector: string, hostSelector: string):\n      string {\n    const isRe = /\\[is=([^\\]]*)\\]/g;\n    scopeSelector = scopeSelector.replace(isRe, (_: string, ...parts: string[]) => parts[0]);\n\n    const attrName = '[' + scopeSelector + ']';\n\n    const _scopeSelectorPart = (p: string) => {\n      let scopedP = p.trim();\n\n      if (!scopedP) {\n        return '';\n      }\n\n      if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n        scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n      } else {\n        // remove :host since it should be unnecessary\n        const t = p.replace(_polyfillHostRe, '');\n        if (t.length > 0) {\n          const matches = t.match(/([^:]*)(:*)(.*)/);\n          if (matches) {\n            scopedP = matches[1] + attrName + matches[2] + matches[3];\n          }\n        }\n      }\n\n      return scopedP;\n    };\n\n    const safeContent = new SafeSelector(selector);\n    selector = safeContent.content();\n\n    let scopedSelector = '';\n    let startIndex = 0;\n    let res: RegExpExecArray|null;\n    const sep = /( |>|\\+|~(?!=))\\s*/g;\n\n    // If a selector appears before :host it should not be shimmed as it\n    // matches on ancestor elements and not on elements in the host's shadow\n    // `:host-context(div)` is transformed to\n    // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n    // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n    // Historically `component-tag:host` was matching the component so we also want to preserve\n    // this behavior to avoid breaking legacy apps (it should not match).\n    // The behavior should be:\n    // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n    // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n    //   `:host-context(tag)`)\n    const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\n    // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n    let shouldScope = !hasHost;\n\n    while ((res = sep.exec(selector)) !== null) {\n      const separator = res[1];\n      const part = selector.slice(startIndex, res.index).trim();\n      shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n      const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\n      scopedSelector += `${scopedPart} ${separator} `;\n      startIndex = sep.lastIndex;\n    }\n\n    const part = selector.substring(startIndex);\n    shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n    scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\n\n    // replace the placeholders with their original values\n    return safeContent.restore(scopedSelector);\n  }\n\n  private _insertPolyfillHostInCssText(selector: string): string {\n    return selector.replace(_colonHostContextRe, _polyfillHostContext)\n        .replace(_colonHostRe, _polyfillHost);\n  }\n}\n\nclass SafeSelector {\n  private placeholders: string[] = [];\n  private index = 0;\n  private _content: string;\n\n  constructor(selector: string) {\n    // Replaces attribute selectors with placeholders.\n    // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n    selector = selector.replace(/(\\[[^\\]]*\\])/g, (_, keep) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(keep);\n      this.index++;\n      return replaceBy;\n    });\n\n    // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n    // WS and \"+\" would otherwise be interpreted as selector separators.\n    this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\n      const replaceBy = `__ph-${this.index}__`;\n      this.placeholders.push(exp);\n      this.index++;\n      return pseudo + replaceBy;\n    });\n  }\n\n  restore(content: string): string {\n    return content.replace(/__ph-(\\d+)__/g, (ph, index) => this.placeholders[+index]);\n  }\n\n  content(): string { return this._content; }\n}\n\nconst _cssContentNextSelectorRe =\n    /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _cssContentUnscopedRuleRe =\n    /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nconst _polyfillHost = '-shadowcsshost';\n// note: :host-context pre-processed to -shadowcsshostcontext.\nconst _polyfillHostContext = '-shadowcsscontext';\nconst _parenSuffix = ')(?:\\\\((' +\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\n    ')\\\\))?([^,{]*)';\nconst _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\nconst _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nconst _shadowDOMSelectorsRe = [\n  /::shadow/g,\n  /::content/g,\n  // Deprecated selectors\n  /\\/shadow-deep\\//g,\n  /\\/shadow\\//g,\n];\n\n// The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nconst _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nconst _polyfillHostRe = /-shadowcsshost/gim;\nconst _colonHostRe = /:host/gim;\nconst _colonHostContextRe = /:host-context/gim;\n\nconst _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\n\nfunction stripComments(input: string): string {\n  return input.replace(_commentRe, '');\n}\n\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\n\nfunction extractCommentsWithHash(input: string): string[] {\n  return input.match(_commentWithHashRe) || [];\n}\n\nconst _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nconst _curlyRe = /([{}])/g;\nconst OPEN_CURLY = '{';\nconst CLOSE_CURLY = '}';\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\n\nexport class CssRule {\n  constructor(public selector: string, public content: string) {}\n}\n\nexport function processRules(input: string, ruleCallback: (rule: CssRule) => CssRule): string {\n  const inputWithEscapedBlocks = escapeBlocks(input);\n  let nextBlockIndex = 0;\n  return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function(...m: string[]) {\n    const selector = m[2];\n    let content = '';\n    let suffix = m[4];\n    let contentPrefix = '';\n    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = '{';\n    }\n    const rule = ruleCallback(new CssRule(selector, content));\n    return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\n  });\n}\n\nclass StringWithEscapedBlocks {\n  constructor(public escapedString: string, public blocks: string[]) {}\n}\n\nfunction escapeBlocks(input: string): StringWithEscapedBlocks {\n  const inputParts = input.split(_curlyRe);\n  const resultParts: string[] = [];\n  const escapedBlocks: string[] = [];\n  let bracketCount = 0;\n  let currentBlockParts: string[] = [];\n  for (let partIndex = 0; partIndex < inputParts.length; partIndex++) {\n    const part = inputParts[partIndex];\n    if (part == CLOSE_CURLY) {\n      bracketCount--;\n    }\n    if (bracketCount > 0) {\n      currentBlockParts.push(part);\n    } else {\n      if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n        currentBlockParts = [];\n      }\n      resultParts.push(part);\n    }\n    if (part == OPEN_CURLY) {\n      bracketCount++;\n    }\n  }\n  if (currentBlockParts.length > 0) {\n    escapedBlocks.push(currentBlockParts.join(''));\n    resultParts.push(BLOCK_PLACEHOLDER);\n  }\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveMetadata, CompileIdentifierMetadata, CompileStylesheetMetadata, identifierModuleUrl, identifierName} from './compile_metadata';\nimport {ViewEncapsulation} from './core';\nimport * as o from './output/output_ast';\nimport {ShadowCss} from './shadow_css';\nimport {UrlResolver} from './url_resolver';\nimport {OutputContext} from './util';\n\nconst COMPONENT_VARIABLE = '%COMP%';\nexport const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nexport const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n\nexport class StylesCompileDependency {\n  constructor(\n      public name: string, public moduleUrl: string, public setValue: (value: any) => void) {}\n}\n\nexport class CompiledStylesheet {\n  constructor(\n      public outputCtx: OutputContext, public stylesVar: string,\n      public dependencies: StylesCompileDependency[], public isShimmed: boolean,\n      public meta: CompileStylesheetMetadata) {}\n}\n\nexport class StyleCompiler {\n  private _shadowCss: ShadowCss = new ShadowCss();\n\n  constructor(private _urlResolver: UrlResolver) {}\n\n  compileComponent(outputCtx: OutputContext, comp: CompileDirectiveMetadata): CompiledStylesheet {\n    const template = comp.template !;\n    return this._compileStyles(\n        outputCtx, comp, new CompileStylesheetMetadata({\n          styles: template.styles,\n          styleUrls: template.styleUrls,\n          moduleUrl: identifierModuleUrl(comp.type)\n        }),\n        this.needsStyleShim(comp), true);\n  }\n\n  compileStyles(\n      outputCtx: OutputContext, comp: CompileDirectiveMetadata,\n      stylesheet: CompileStylesheetMetadata,\n      shim: boolean = this.needsStyleShim(comp)): CompiledStylesheet {\n    return this._compileStyles(outputCtx, comp, stylesheet, shim, false);\n  }\n\n  needsStyleShim(comp: CompileDirectiveMetadata): boolean {\n    return comp.template !.encapsulation === ViewEncapsulation.Emulated;\n  }\n\n  private _compileStyles(\n      outputCtx: OutputContext, comp: CompileDirectiveMetadata,\n      stylesheet: CompileStylesheetMetadata, shim: boolean,\n      isComponentStylesheet: boolean): CompiledStylesheet {\n    const styleExpressions: o.Expression[] =\n        stylesheet.styles.map(plainStyle => o.literal(this._shimIfNeeded(plainStyle, shim)));\n    const dependencies: StylesCompileDependency[] = [];\n    stylesheet.styleUrls.forEach((styleUrl) => {\n      const exprIndex = styleExpressions.length;\n      // Note: This placeholder will be filled later.\n      styleExpressions.push(null !);\n      dependencies.push(new StylesCompileDependency(\n          getStylesVarName(null), styleUrl,\n          (value) => styleExpressions[exprIndex] = outputCtx.importExpr(value)));\n    });\n    // styles variable contains plain strings and arrays of other styles arrays (recursive),\n    // so we set its type to dynamic.\n    const stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n    const stmt = o.variable(stylesVar)\n                     .set(o.literalArr(\n                         styleExpressions, new o.ArrayType(o.DYNAMIC_TYPE, [o.TypeModifier.Const])))\n                     .toDeclStmt(null, isComponentStylesheet ? [o.StmtModifier.Final] : [\n                       o.StmtModifier.Final, o.StmtModifier.Exported\n                     ]);\n    outputCtx.statements.push(stmt);\n    return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);\n  }\n\n  private _shimIfNeeded(style: string, shim: boolean): string {\n    return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;\n  }\n}\n\nfunction getStylesVarName(component: CompileDirectiveMetadata | null): string {\n  let result = `styles`;\n  if (component) {\n    result += `_${identifierName(component.type)}`;\n  }\n  return result;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A path is an ordered set of elements. Typically a path is to  a\n * particular offset in a source file. The head of the list is the top\n * most node. The tail is the node that contains the offset directly.\n *\n * For example, the expression `a + b + c` might have an ast that looks\n * like:\n *     +\n *    / \\\n *   a   +\n *      / \\\n *     b   c\n *\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\n * 'c' at 9-10]` and the path the node at offset 1 would be\n * `['+' at 1-10, 'a' at 1-2]`.\n */\nexport class AstPath<T> {\n  constructor(private path: T[], public position: number = -1) {}\n\n  get empty(): boolean { return !this.path || !this.path.length; }\n  get head(): T|undefined { return this.path[0]; }\n  get tail(): T|undefined { return this.path[this.path.length - 1]; }\n\n  parentOf(node: T|undefined): T|undefined {\n    return node && this.path[this.path.indexOf(node) - 1];\n  }\n  childOf(node: T): T|undefined { return this.path[this.path.indexOf(node) + 1]; }\n\n  first<N extends T>(ctor: {new (...args: any[]): N}): N|undefined {\n    for (let i = this.path.length - 1; i >= 0; i--) {\n      let item = this.path[i];\n      if (item instanceof ctor) return <N>item;\n    }\n  }\n\n  push(node: T) { this.path.push(node); }\n\n  pop(): T { return this.path.pop() !; }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AstPath} from '../ast_path';\nimport {I18nMeta} from '../i18n/i18n_ast';\nimport {ParseSourceSpan} from '../parse_util';\n\nexport interface Node {\n  sourceSpan: ParseSourceSpan;\n  visit(visitor: Visitor, context: any): any;\n}\n\nexport abstract class NodeWithI18n implements Node {\n  constructor(public sourceSpan: ParseSourceSpan, public i18n?: I18nMeta) {}\n  abstract visit(visitor: Visitor, context: any): any;\n}\n\nexport class Text extends NodeWithI18n {\n  constructor(public value: string, sourceSpan: ParseSourceSpan, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  visit(visitor: Visitor, context: any): any { return visitor.visitText(this, context); }\n}\n\nexport class Expansion extends NodeWithI18n {\n  constructor(\n      public switchValue: string, public type: string, public cases: ExpansionCase[],\n      sourceSpan: ParseSourceSpan, public switchValueSourceSpan: ParseSourceSpan, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  visit(visitor: Visitor, context: any): any { return visitor.visitExpansion(this, context); }\n}\n\nexport class ExpansionCase implements Node {\n  constructor(\n      public value: string, public expression: Node[], public sourceSpan: ParseSourceSpan,\n      public valueSourceSpan: ParseSourceSpan, public expSourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: Visitor, context: any): any { return visitor.visitExpansionCase(this, context); }\n}\n\nexport class Attribute extends NodeWithI18n {\n  constructor(\n      public name: string, public value: string, sourceSpan: ParseSourceSpan,\n      public valueSpan?: ParseSourceSpan, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  visit(visitor: Visitor, context: any): any { return visitor.visitAttribute(this, context); }\n}\n\nexport class Element extends NodeWithI18n {\n  constructor(\n      public name: string, public attrs: Attribute[], public children: Node[],\n      sourceSpan: ParseSourceSpan, public startSourceSpan: ParseSourceSpan|null = null,\n      public endSourceSpan: ParseSourceSpan|null = null, i18n?: I18nMeta) {\n    super(sourceSpan, i18n);\n  }\n  visit(visitor: Visitor, context: any): any { return visitor.visitElement(this, context); }\n}\n\nexport class Comment implements Node {\n  constructor(public value: string|null, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: Visitor, context: any): any { return visitor.visitComment(this, context); }\n}\n\nexport interface Visitor {\n  // Returning a truthy value from `visit()` will prevent `visitAll()` from the call to the typed\n  // method and result returned will become the result included in `visitAll()`s result array.\n  visit?(node: Node, context: any): any;\n\n  visitElement(element: Element, context: any): any;\n  visitAttribute(attribute: Attribute, context: any): any;\n  visitText(text: Text, context: any): any;\n  visitComment(comment: Comment, context: any): any;\n  visitExpansion(expansion: Expansion, context: any): any;\n  visitExpansionCase(expansionCase: ExpansionCase, context: any): any;\n}\n\nexport function visitAll(visitor: Visitor, nodes: Node[], context: any = null): any[] {\n  const result: any[] = [];\n\n  const visit = visitor.visit ?\n      (ast: Node) => visitor.visit !(ast, context) || ast.visit(visitor, context) :\n      (ast: Node) => ast.visit(visitor, context);\n  nodes.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nexport class RecursiveVisitor implements Visitor {\n  constructor() {}\n\n  visitElement(ast: Element, context: any): any {\n    this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.children);\n    });\n  }\n\n  visitAttribute(ast: Attribute, context: any): any {}\n  visitText(ast: Text, context: any): any {}\n  visitComment(ast: Comment, context: any): any {}\n\n  visitExpansion(ast: Expansion, context: any): any {\n    return this.visitChildren(context, visit => { visit(ast.cases); });\n  }\n\n  visitExpansionCase(ast: ExpansionCase, context: any): any {}\n\n  private visitChildren<T extends Node>(\n      context: any, cb: (visit: (<V extends Node>(children: V[]|undefined) => void)) => void) {\n    let results: any[][] = [];\n    let t = this;\n    function visit<T extends Node>(children: T[] | undefined) {\n      if (children) results.push(visitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\n\nexport type HtmlAstPath = AstPath<Node>;\n\nfunction spanOf(ast: Node) {\n  const start = ast.sourceSpan.start.offset;\n  let end = ast.sourceSpan.end.offset;\n  if (ast instanceof Element) {\n    if (ast.endSourceSpan) {\n      end = ast.endSourceSpan.end.offset;\n    } else if (ast.children && ast.children.length) {\n      end = spanOf(ast.children[ast.children.length - 1]).end;\n    }\n  }\n  return {start, end};\n}\n\nexport function findNode(nodes: Node[], position: number): HtmlAstPath {\n  const path: Node[] = [];\n\n  const visitor = new class extends RecursiveVisitor {\n    visit(ast: Node, context: any): any {\n      const span = spanOf(ast);\n      if (span.start <= position && position < span.end) {\n        path.push(ast);\n      } else {\n        // Returning a value here will result in the children being skipped.\n        return true;\n      }\n    }\n  };\n\n  visitAll(visitor, nodes);\n\n  return new AstPath<Node>(path, position);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {ParseError, ParseLocation, ParseSourceFile, ParseSourceSpan} from '../parse_util';\n\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from './interpolation_config';\nimport {NAMED_ENTITIES, TagContentType, TagDefinition} from './tags';\n\nexport enum TokenType {\n  TAG_OPEN_START,\n  TAG_OPEN_END,\n  TAG_OPEN_END_VOID,\n  TAG_CLOSE,\n  TEXT,\n  ESCAPABLE_RAW_TEXT,\n  RAW_TEXT,\n  COMMENT_START,\n  COMMENT_END,\n  CDATA_START,\n  CDATA_END,\n  ATTR_NAME,\n  ATTR_QUOTE,\n  ATTR_VALUE,\n  DOC_TYPE,\n  EXPANSION_FORM_START,\n  EXPANSION_CASE_VALUE,\n  EXPANSION_CASE_EXP_START,\n  EXPANSION_CASE_EXP_END,\n  EXPANSION_FORM_END,\n  EOF\n}\n\nexport class Token {\n  constructor(\n      public type: TokenType|null, public parts: string[], public sourceSpan: ParseSourceSpan) {}\n}\n\nexport class TokenError extends ParseError {\n  constructor(errorMsg: string, public tokenType: TokenType|null, span: ParseSourceSpan) {\n    super(span, errorMsg);\n  }\n}\n\nexport class TokenizeResult {\n  constructor(public tokens: Token[], public errors: TokenError[]) {}\n}\n\nexport interface LexerRange {\n  startPos: number;\n  startLine: number;\n  startCol: number;\n  endPos: number;\n}\n\n/**\n * Options that modify how the text is tokenized.\n */\nexport interface TokenizeOptions {\n  /** Whether to tokenize ICU messages (considered as text nodes when false). */\n  tokenizeExpansionForms?: boolean;\n  /** How to tokenize interpolation markers. */\n  interpolationConfig?: InterpolationConfig;\n  /**\n   * The start and end point of the text to parse within the `source` string.\n   * The entire `source` string is parsed if this is not provided.\n   * */\n  range?: LexerRange;\n  /**\n   * If this text is stored in a JavaScript string, then we have to deal with escape sequences.\n   *\n   * **Example 1:**\n   *\n   * ```\n   * \"abc\\\"def\\nghi\"\n   * ```\n   *\n   * - The `\\\"` must be converted to `\"`.\n   * - The `\\n` must be converted to a new line character in a token,\n   *   but it should not increment the current line for source mapping.\n   *\n   * **Example 2:**\n   *\n   * ```\n   * \"abc\\\n   *  def\"\n   * ```\n   *\n   * The line continuation (`\\` followed by a newline) should be removed from a token\n   * but the new line should increment the current line for source mapping.\n   */\n  escapedString?: boolean;\n  /**\n   * An array of characters that should be considered as leading trivia.\n   * Leading trivia are characters that are not important to the developer, and so should not be\n   * included in source-map segments.  A common example is whitespace.\n   */\n  leadingTriviaChars?: string[];\n  /**\n   * If true, do not convert CRLF to LF.\n   */\n  preserveLineEndings?: boolean;\n}\n\nexport function tokenize(\n    source: string, url: string, getTagDefinition: (tagName: string) => TagDefinition,\n    options: TokenizeOptions = {}): TokenizeResult {\n  return new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options).tokenize();\n}\n\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode: number): string {\n  const char = charCode === chars.$EOF ? 'EOF' : String.fromCharCode(charCode);\n  return `Unexpected character \"${char}\"`;\n}\n\nfunction _unknownEntityErrorMsg(entitySrc: string): string {\n  return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\n}\n\nclass _ControlFlowError {\n  constructor(public error: TokenError) {}\n}\n\n// See http://www.w3.org/TR/html51/syntax.html#writing\nclass _Tokenizer {\n  private _cursor: CharacterCursor;\n  private _tokenizeIcu: boolean;\n  private _interpolationConfig: InterpolationConfig;\n  private _leadingTriviaCodePoints: number[]|undefined;\n  private _currentTokenStart: CharacterCursor|null = null;\n  private _currentTokenType: TokenType|null = null;\n  private _expansionCaseStack: TokenType[] = [];\n  private _inInterpolation: boolean = false;\n  private readonly _preserveLineEndings: boolean;\n  tokens: Token[] = [];\n  errors: TokenError[] = [];\n\n  /**\n   * @param _file The html source file being tokenized.\n   * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n   * @param options Configuration of the tokenization.\n   */\n  constructor(\n      _file: ParseSourceFile, private _getTagDefinition: (tagName: string) => TagDefinition,\n      options: TokenizeOptions) {\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n    this._leadingTriviaCodePoints =\n        options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\n    const range =\n        options.range || {endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0};\n    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :\n                                           new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n\n  private _processCarriageReturns(content: string): string {\n    if (this._preserveLineEndings) {\n      return content;\n    }\n    // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n    // In order to keep the original position in the source, we can not\n    // pre-process it.\n    // Instead CRs are processed right before instantiating the tokens.\n    return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n  }\n\n  tokenize(): TokenizeResult {\n    while (this._cursor.peek() !== chars.$EOF) {\n      const start = this._cursor.clone();\n      try {\n        if (this._attemptCharCode(chars.$LT)) {\n          if (this._attemptCharCode(chars.$BANG)) {\n            if (this._attemptCharCode(chars.$LBRACKET)) {\n              this._consumeCdata(start);\n            } else if (this._attemptCharCode(chars.$MINUS)) {\n              this._consumeComment(start);\n            } else {\n              this._consumeDocType(start);\n            }\n          } else if (this._attemptCharCode(chars.$SLASH)) {\n            this._consumeTagClose(start);\n          } else {\n            this._consumeTagOpen(start);\n          }\n        } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n          this._consumeText();\n        }\n      } catch (e) {\n        this.handleError(e);\n      }\n    }\n    this._beginToken(TokenType.EOF);\n    this._endToken([]);\n    return new TokenizeResult(mergeTextTokens(this.tokens), this.errors);\n  }\n\n  /**\n   * @returns whether an ICU token has been created\n   * @internal\n   */\n  private _tokenizeExpansionForm(): boolean {\n    if (this.isExpansionFormStart()) {\n      this._consumeExpansionFormStart();\n      return true;\n    }\n\n    if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n      this._consumeExpansionCaseStart();\n      return true;\n    }\n\n    if (this._cursor.peek() === chars.$RBRACE) {\n      if (this._isInExpansionCase()) {\n        this._consumeExpansionCaseEnd();\n        return true;\n      }\n\n      if (this._isInExpansionForm()) {\n        this._consumeExpansionFormEnd();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _beginToken(type: TokenType, start = this._cursor.clone()) {\n    this._currentTokenStart = start;\n    this._currentTokenType = type;\n  }\n\n  private _endToken(parts: string[], end?: CharacterCursor): Token {\n    if (this._currentTokenStart === null) {\n      throw new TokenError(\n          'Programming error - attempted to end a token when there was no start to the token',\n          this._currentTokenType, this._cursor.getSpan(end));\n    }\n    if (this._currentTokenType === null) {\n      throw new TokenError(\n          'Programming error - attempted to end a token which has no token type', null,\n          this._cursor.getSpan(this._currentTokenStart));\n    }\n    const token = new Token(\n        this._currentTokenType, parts,\n        this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));\n    this.tokens.push(token);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return token;\n  }\n\n  private _createError(msg: string, span: ParseSourceSpan): _ControlFlowError {\n    if (this._isInExpansionForm()) {\n      msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\n    }\n    const error = new TokenError(msg, this._currentTokenType, span);\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    return new _ControlFlowError(error);\n  }\n\n  private handleError(e: any) {\n    if (e instanceof CursorError) {\n      e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n    }\n    if (e instanceof _ControlFlowError) {\n      this.errors.push(e.error);\n    } else {\n      throw e;\n    }\n  }\n\n  private _attemptCharCode(charCode: number): boolean {\n    if (this._cursor.peek() === charCode) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _attemptCharCodeCaseInsensitive(charCode: number): boolean {\n    if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n      this._cursor.advance();\n      return true;\n    }\n    return false;\n  }\n\n  private _requireCharCode(charCode: number) {\n    const location = this._cursor.clone();\n    if (!this._attemptCharCode(charCode)) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n\n  private _attemptStr(chars: string): boolean {\n    const len = chars.length;\n    if (this._cursor.charsLeft() < len) {\n      return false;\n    }\n    const initialPosition = this._cursor.clone();\n    for (let i = 0; i < len; i++) {\n      if (!this._attemptCharCode(chars.charCodeAt(i))) {\n        // If attempting to parse the string fails, we want to reset the parser\n        // to where it was before the attempt\n        this._cursor = initialPosition;\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _attemptStrCaseInsensitive(chars: string): boolean {\n    for (let i = 0; i < chars.length; i++) {\n      if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private _requireStr(chars: string) {\n    const location = this._cursor.clone();\n    if (!this._attemptStr(chars)) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n    }\n  }\n\n  private _attemptCharCodeUntilFn(predicate: (code: number) => boolean) {\n    while (!predicate(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n  }\n\n  private _requireCharCodeUntilFn(predicate: (code: number) => boolean, len: number) {\n    const start = this._cursor.clone();\n    this._attemptCharCodeUntilFn(predicate);\n    if (this._cursor.diff(start) < len) {\n      throw this._createError(\n          _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n    }\n  }\n\n  private _attemptUntilChar(char: number) {\n    while (this._cursor.peek() !== char) {\n      this._cursor.advance();\n    }\n  }\n\n  private _readChar(decodeEntities: boolean): string {\n    if (decodeEntities && this._cursor.peek() === chars.$AMPERSAND) {\n      return this._decodeEntity();\n    } else {\n      // Don't rely upon reading directly from `_input` as the actual char value\n      // may have been generated from an escape sequence.\n      const char = String.fromCodePoint(this._cursor.peek());\n      this._cursor.advance();\n      return char;\n    }\n  }\n\n  private _decodeEntity(): string {\n    const start = this._cursor.clone();\n    this._cursor.advance();\n    if (this._attemptCharCode(chars.$HASH)) {\n      const isHex = this._attemptCharCode(chars.$x) || this._attemptCharCode(chars.$X);\n      const codeStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isDigitEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        throw this._createError(\n            _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan());\n      }\n      const strNum = this._cursor.getChars(codeStart);\n      this._cursor.advance();\n      try {\n        const charCode = parseInt(strNum, isHex ? 16 : 10);\n        return String.fromCharCode(charCode);\n      } catch {\n        throw this._createError(\n            _unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n      }\n    } else {\n      const nameStart = this._cursor.clone();\n      this._attemptCharCodeUntilFn(isNamedEntityEnd);\n      if (this._cursor.peek() != chars.$SEMICOLON) {\n        this._cursor = nameStart;\n        return '&';\n      }\n      const name = this._cursor.getChars(nameStart);\n      this._cursor.advance();\n      const char = NAMED_ENTITIES[name];\n      if (!char) {\n        throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n      }\n      return char;\n    }\n  }\n\n  private _consumeRawText(decodeEntities: boolean, endMarkerPredicate: () => boolean): Token {\n    this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n    const parts: string[] = [];\n    while (true) {\n      const tagCloseStart = this._cursor.clone();\n      const foundEndMarker = endMarkerPredicate();\n      this._cursor = tagCloseStart;\n      if (foundEndMarker) {\n        break;\n      }\n      parts.push(this._readChar(decodeEntities));\n    }\n    return this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  private _consumeComment(start: CharacterCursor) {\n    this._beginToken(TokenType.COMMENT_START, start);\n    this._requireCharCode(chars.$MINUS);\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr('-->'));\n    this._beginToken(TokenType.COMMENT_END);\n    this._requireStr('-->');\n    this._endToken([]);\n  }\n\n  private _consumeCdata(start: CharacterCursor) {\n    this._beginToken(TokenType.CDATA_START, start);\n    this._requireStr('CDATA[');\n    this._endToken([]);\n    this._consumeRawText(false, () => this._attemptStr(']]>'));\n    this._beginToken(TokenType.CDATA_END);\n    this._requireStr(']]>');\n    this._endToken([]);\n  }\n\n  private _consumeDocType(start: CharacterCursor) {\n    this._beginToken(TokenType.DOC_TYPE, start);\n    const contentStart = this._cursor.clone();\n    this._attemptUntilChar(chars.$GT);\n    const content = this._cursor.getChars(contentStart);\n    this._cursor.advance();\n    this._endToken([content]);\n  }\n\n  private _consumePrefixAndName(): string[] {\n    const nameOrPrefixStart = this._cursor.clone();\n    let prefix: string = '';\n    while (this._cursor.peek() !== chars.$COLON && !isPrefixEnd(this._cursor.peek())) {\n      this._cursor.advance();\n    }\n    let nameStart: CharacterCursor;\n    if (this._cursor.peek() === chars.$COLON) {\n      prefix = this._cursor.getChars(nameOrPrefixStart);\n      this._cursor.advance();\n      nameStart = this._cursor.clone();\n    } else {\n      nameStart = nameOrPrefixStart;\n    }\n    this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n    const name = this._cursor.getChars(nameStart);\n    return [prefix, name];\n  }\n\n  private _consumeTagOpen(start: CharacterCursor) {\n    let tagName: string;\n    let prefix: string;\n    let openTagToken: Token|undefined;\n    let tokensBeforeTagOpen = this.tokens.length;\n    const innerStart = this._cursor.clone();\n    try {\n      if (!chars.isAsciiLetter(this._cursor.peek())) {\n        throw this._createError(\n            _unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n      }\n\n      openTagToken = this._consumeTagOpenStart(start);\n      prefix = openTagToken.parts[0];\n      tagName = openTagToken.parts[1];\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      while (this._cursor.peek() !== chars.$SLASH && this._cursor.peek() !== chars.$GT) {\n        this._consumeAttributeName();\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n        if (this._attemptCharCode(chars.$EQ)) {\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n          this._consumeAttributeValue();\n        }\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n      }\n      this._consumeTagOpenEnd();\n    } catch (e) {\n      if (e instanceof _ControlFlowError) {\n        // When the start tag is invalid (including invalid \"attributes\"), assume we want a \"<\"\n        this._cursor = innerStart;\n        if (openTagToken) {\n          this.tokens.length = tokensBeforeTagOpen;\n        }\n        // Back to back text tokens are merged at the end\n        this._beginToken(TokenType.TEXT, start);\n        this._endToken(['<']);\n        return;\n      }\n\n      throw e;\n    }\n\n    const contentTokenType = this._getTagDefinition(tagName).contentType;\n\n    if (contentTokenType === TagContentType.RAW_TEXT) {\n      this._consumeRawTextWithTagClose(prefix, tagName, false);\n    } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n      this._consumeRawTextWithTagClose(prefix, tagName, true);\n    }\n  }\n\n  private _consumeRawTextWithTagClose(prefix: string, tagName: string, decodeEntities: boolean) {\n    const textToken = this._consumeRawText(decodeEntities, () => {\n      if (!this._attemptCharCode(chars.$LT)) return false;\n      if (!this._attemptCharCode(chars.$SLASH)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      if (!this._attemptStrCaseInsensitive(tagName)) return false;\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n      return this._attemptCharCode(chars.$GT);\n    });\n    this._beginToken(TokenType.TAG_CLOSE);\n    this._requireCharCodeUntilFn(code => code === chars.$GT, 3);\n    this._cursor.advance();  // Consume the `>`\n    this._endToken([prefix, tagName]);\n  }\n\n  private _consumeTagOpenStart(start: CharacterCursor) {\n    this._beginToken(TokenType.TAG_OPEN_START, start);\n    const parts = this._consumePrefixAndName();\n    return this._endToken(parts);\n  }\n\n  private _consumeAttributeName() {\n    const attrNameStart = this._cursor.peek();\n    if (attrNameStart === chars.$SQ || attrNameStart === chars.$DQ) {\n      throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n    }\n    this._beginToken(TokenType.ATTR_NAME);\n    const prefixAndName = this._consumePrefixAndName();\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeAttributeValue() {\n    let value: string;\n    if (this._cursor.peek() === chars.$SQ || this._cursor.peek() === chars.$DQ) {\n      this._beginToken(TokenType.ATTR_QUOTE);\n      const quoteChar = this._cursor.peek();\n      this._cursor.advance();\n      this._endToken([String.fromCodePoint(quoteChar)]);\n      this._beginToken(TokenType.ATTR_VALUE);\n      const parts: string[] = [];\n      while (this._cursor.peek() !== quoteChar) {\n        parts.push(this._readChar(true));\n      }\n      value = parts.join('');\n      this._endToken([this._processCarriageReturns(value)]);\n      this._beginToken(TokenType.ATTR_QUOTE);\n      this._cursor.advance();\n      this._endToken([String.fromCodePoint(quoteChar)]);\n    } else {\n      this._beginToken(TokenType.ATTR_VALUE);\n      const valueStart = this._cursor.clone();\n      this._requireCharCodeUntilFn(isNameEnd, 1);\n      value = this._cursor.getChars(valueStart);\n      this._endToken([this._processCarriageReturns(value)]);\n    }\n  }\n\n  private _consumeTagOpenEnd() {\n    const tokenType =\n        this._attemptCharCode(chars.$SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n    this._beginToken(tokenType);\n    this._requireCharCode(chars.$GT);\n    this._endToken([]);\n  }\n\n  private _consumeTagClose(start: CharacterCursor) {\n    this._beginToken(TokenType.TAG_CLOSE, start);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    const prefixAndName = this._consumePrefixAndName();\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n    this._requireCharCode(chars.$GT);\n    this._endToken(prefixAndName);\n  }\n\n  private _consumeExpansionFormStart() {\n    this._beginToken(TokenType.EXPANSION_FORM_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const condition = this._readUntil(chars.$COMMA);\n    this._endToken([condition]);\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.RAW_TEXT);\n    const type = this._readUntil(chars.$COMMA);\n    this._endToken([type]);\n    this._requireCharCode(chars.$COMMA);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n  }\n\n  private _consumeExpansionCaseStart() {\n    this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n    const value = this._readUntil(chars.$LBRACE).trim();\n    this._endToken([value]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n    this._requireCharCode(chars.$LBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n  }\n\n  private _consumeExpansionCaseEnd() {\n    this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n    this._attemptCharCodeUntilFn(isNotWhitespace);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeExpansionFormEnd() {\n    this._beginToken(TokenType.EXPANSION_FORM_END);\n    this._requireCharCode(chars.$RBRACE);\n    this._endToken([]);\n\n    this._expansionCaseStack.pop();\n  }\n\n  private _consumeText() {\n    const start = this._cursor.clone();\n    this._beginToken(TokenType.TEXT, start);\n    const parts: string[] = [];\n\n    do {\n      if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n        parts.push(this._interpolationConfig.start);\n        this._inInterpolation = true;\n      } else if (\n          this._interpolationConfig && this._inInterpolation &&\n          this._attemptStr(this._interpolationConfig.end)) {\n        parts.push(this._interpolationConfig.end);\n        this._inInterpolation = false;\n      } else {\n        parts.push(this._readChar(true));\n      }\n    } while (!this._isTextEnd());\n\n    this._endToken([this._processCarriageReturns(parts.join(''))]);\n  }\n\n  private _isTextEnd(): boolean {\n    if (this._cursor.peek() === chars.$LT || this._cursor.peek() === chars.$EOF) {\n      return true;\n    }\n\n    if (this._tokenizeIcu && !this._inInterpolation) {\n      if (this.isExpansionFormStart()) {\n        // start of an expansion form\n        return true;\n      }\n\n      if (this._cursor.peek() === chars.$RBRACE && this._isInExpansionCase()) {\n        // end of and expansion case\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _readUntil(char: number): string {\n    const start = this._cursor.clone();\n    this._attemptUntilChar(char);\n    return this._cursor.getChars(start);\n  }\n\n  private _isInExpansionCase(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_CASE_EXP_START;\n  }\n\n  private _isInExpansionForm(): boolean {\n    return this._expansionCaseStack.length > 0 &&\n        this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\n        TokenType.EXPANSION_FORM_START;\n  }\n\n  private isExpansionFormStart(): boolean {\n    if (this._cursor.peek() !== chars.$LBRACE) {\n      return false;\n    }\n    if (this._interpolationConfig) {\n      const start = this._cursor.clone();\n      const isInterpolation = this._attemptStr(this._interpolationConfig.start);\n      this._cursor = start;\n      return !isInterpolation;\n    }\n    return true;\n  }\n}\n\nfunction isNotWhitespace(code: number): boolean {\n  return !chars.isWhitespace(code) || code === chars.$EOF;\n}\n\nfunction isNameEnd(code: number): boolean {\n  return chars.isWhitespace(code) || code === chars.$GT || code === chars.$SLASH ||\n      code === chars.$SQ || code === chars.$DQ || code === chars.$EQ;\n}\n\nfunction isPrefixEnd(code: number): boolean {\n  return (code < chars.$a || chars.$z < code) && (code < chars.$A || chars.$Z < code) &&\n      (code < chars.$0 || code > chars.$9);\n}\n\nfunction isDigitEntityEnd(code: number): boolean {\n  return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code: number): boolean {\n  return code == chars.$SEMICOLON || code == chars.$EOF || !chars.isAsciiLetter(code);\n}\n\nfunction isExpansionCaseStart(peek: number): boolean {\n  return peek === chars.$EQ || chars.isAsciiLetter(peek) || chars.isDigit(peek);\n}\n\nfunction compareCharCodeCaseInsensitive(code1: number, code2: number): boolean {\n  return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code: number): number {\n  return code >= chars.$a && code <= chars.$z ? code - chars.$a + chars.$A : code;\n}\n\nfunction mergeTextTokens(srcTokens: Token[]): Token[] {\n  const dstTokens: Token[] = [];\n  let lastDstToken: Token|undefined = undefined;\n  for (let i = 0; i < srcTokens.length; i++) {\n    const token = srcTokens[i];\n    if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n      lastDstToken.parts[0] ! += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n\n\n/**\n * The _Tokenizer uses objects of this type to move through the input text,\n * extracting \"parsed characters\". These could be more than one actual character\n * if the text contains escape sequences.\n */\ninterface CharacterCursor {\n  /** Initialize the cursor. */\n  init(): void;\n  /** The parsed character at the current cursor position. */\n  peek(): number;\n  /** Advance the cursor by one parsed character. */\n  advance(): void;\n  /** Get a span from the marked start point to the current point. */\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan;\n  /** Get the parsed characters from the marked start point to the current point. */\n  getChars(start: this): string;\n  /** The number of characters left before the end of the cursor. */\n  charsLeft(): number;\n  /** The number of characters between `this` cursor and `other` cursor. */\n  diff(other: this): number;\n  /** Make a copy of this cursor */\n  clone(): CharacterCursor;\n}\n\ninterface CursorState {\n  peek: number;\n  offset: number;\n  line: number;\n  column: number;\n}\n\nclass PlainCharacterCursor implements CharacterCursor {\n  protected state: CursorState;\n  protected file: ParseSourceFile;\n  protected input: string;\n  protected end: number;\n\n  constructor(fileOrCursor: PlainCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile|PlainCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n\n      const state = fileOrCursor.state;\n      // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n      // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n      // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n      // called in tight loops, this difference matters.\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column,\n      };\n    } else {\n      if (!range) {\n        throw new Error(\n            'Programming error: the range argument must be provided with a file argument.');\n      }\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol,\n      };\n    }\n  }\n\n  clone(): PlainCharacterCursor { return new PlainCharacterCursor(this); }\n\n  peek() { return this.state.peek; }\n  charsLeft() { return this.end - this.state.offset; }\n  diff(other: this) { return this.state.offset - other.state.offset; }\n\n  advance(): void { this.advanceState(this.state); }\n\n  init(): void { this.updatePeek(this.state); }\n\n  getSpan(start?: this, leadingTriviaCodePoints?: number[]): ParseSourceSpan {\n    start = start || this;\n    let cloned = false;\n    if (leadingTriviaCodePoints) {\n      while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n        if (!cloned) {\n          start = start.clone() as this;\n          cloned = true;\n        }\n        start.advance();\n      }\n    }\n    return new ParseSourceSpan(\n        new ParseLocation(start.file, start.state.offset, start.state.line, start.state.column),\n        new ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));\n  }\n\n  getChars(start: this): string {\n    return this.input.substring(start.state.offset, this.state.offset);\n  }\n\n  charAt(pos: number): number { return this.input.charCodeAt(pos); }\n\n  protected advanceState(state: CursorState) {\n    if (state.offset >= this.end) {\n      this.state = state;\n      throw new CursorError('Unexpected character \"EOF\"', this);\n    }\n    const currentChar = this.charAt(state.offset);\n    if (currentChar === chars.$LF) {\n      state.line++;\n      state.column = 0;\n    } else if (!chars.isNewLine(currentChar)) {\n      state.column++;\n    }\n    state.offset++;\n    this.updatePeek(state);\n  }\n\n  protected updatePeek(state: CursorState): void {\n    state.peek = state.offset >= this.end ? chars.$EOF : this.charAt(state.offset);\n  }\n}\n\nclass EscapedCharacterCursor extends PlainCharacterCursor {\n  protected internalState: CursorState;\n\n  constructor(fileOrCursor: EscapedCharacterCursor);\n  constructor(fileOrCursor: ParseSourceFile, range: LexerRange);\n  constructor(fileOrCursor: ParseSourceFile|EscapedCharacterCursor, range?: LexerRange) {\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      super(fileOrCursor);\n      this.internalState = {...fileOrCursor.internalState};\n    } else {\n      super(fileOrCursor, range !);\n      this.internalState = this.state;\n    }\n  }\n\n  advance(): void {\n    this.state = this.internalState;\n    super.advance();\n    this.processEscapeSequence();\n  }\n\n  init(): void {\n    super.init();\n    this.processEscapeSequence();\n  }\n\n  clone(): EscapedCharacterCursor { return new EscapedCharacterCursor(this); }\n\n  getChars(start: this): string {\n    const cursor = start.clone();\n    let chars = '';\n    while (cursor.internalState.offset < this.internalState.offset) {\n      chars += String.fromCodePoint(cursor.peek());\n      cursor.advance();\n    }\n    return chars;\n  }\n\n  /**\n   * Process the escape sequence that starts at the current position in the text.\n   *\n   * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n   */\n  protected processEscapeSequence(): void {\n    const peek = () => this.internalState.peek;\n\n    if (peek() === chars.$BACKSLASH) {\n      // We have hit an escape sequence so we need the internal state to become independent\n      // of the external state.\n      this.internalState = {...this.state};\n\n      // Move past the backslash\n      this.advanceState(this.internalState);\n\n      // First check for standard control char sequences\n      if (peek() === chars.$n) {\n        this.state.peek = chars.$LF;\n      } else if (peek() === chars.$r) {\n        this.state.peek = chars.$CR;\n      } else if (peek() === chars.$v) {\n        this.state.peek = chars.$VTAB;\n      } else if (peek() === chars.$t) {\n        this.state.peek = chars.$TAB;\n      } else if (peek() === chars.$b) {\n        this.state.peek = chars.$BSPACE;\n      } else if (peek() === chars.$f) {\n        this.state.peek = chars.$FF;\n      }\n\n      // Now consider more complex sequences\n      else if (peek() === chars.$u) {\n        // Unicode code-point sequence\n        this.advanceState(this.internalState);  // advance past the `u` char\n        if (peek() === chars.$LBRACE) {\n          // Variable length Unicode, e.g. `\\x{123}`\n          this.advanceState(this.internalState);  // advance past the `{` char\n          // Advance past the variable number of hex digits until we hit a `}` char\n          const digitStart = this.clone();\n          let length = 0;\n          while (peek() !== chars.$RBRACE) {\n            this.advanceState(this.internalState);\n            length++;\n          }\n          this.state.peek = this.decodeHexDigits(digitStart, length);\n        } else {\n          // Fixed length Unicode, e.g. `\\u1234`\n          const digitStart = this.clone();\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.advanceState(this.internalState);\n          this.state.peek = this.decodeHexDigits(digitStart, 4);\n        }\n      }\n\n      else if (peek() === chars.$x) {\n        // Hex char code, e.g. `\\x2F`\n        this.advanceState(this.internalState);  // advance past the `x` char\n        const digitStart = this.clone();\n        this.advanceState(this.internalState);\n        this.state.peek = this.decodeHexDigits(digitStart, 2);\n      }\n\n      else if (chars.isOctalDigit(peek())) {\n        // Octal char code, e.g. `\\012`,\n        let octal = '';\n        let length = 0;\n        let previous = this.clone();\n        while (chars.isOctalDigit(peek()) && length < 3) {\n          previous = this.clone();\n          octal += String.fromCodePoint(peek());\n          this.advanceState(this.internalState);\n          length++;\n        }\n        this.state.peek = parseInt(octal, 8);\n        // Backup one char\n        this.internalState = previous.internalState;\n      }\n\n      else if (chars.isNewLine(this.internalState.peek)) {\n        // Line continuation `\\` followed by a new line\n        this.advanceState(this.internalState);  // advance over the newline\n        this.state = this.internalState;\n      }\n\n      else {\n        // If none of the `if` blocks were executed then we just have an escaped normal character.\n        // In that case we just, effectively, skip the backslash from the character.\n        this.state.peek = this.internalState.peek;\n      }\n    }\n  }\n\n  protected decodeHexDigits(start: EscapedCharacterCursor, length: number): number {\n    const hex = this.input.substr(start.internalState.offset, length);\n    const charCode = parseInt(hex, 16);\n    if (!isNaN(charCode)) {\n      return charCode;\n    } else {\n      start.state = start.internalState;\n      throw new CursorError('Invalid hexadecimal escape sequence', start);\n    }\n  }\n}\n\nexport class CursorError {\n  constructor(public msg: string, public cursor: CharacterCursor) {}\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseError, ParseSourceSpan} from '../parse_util';\n\nimport * as html from './ast';\nimport * as lex from './lexer';\nimport {TagDefinition, getNsPrefix, isNgContainer, mergeNsAndName} from './tags';\n\nexport class TreeError extends ParseError {\n  static create(elementName: string|null, span: ParseSourceSpan, msg: string): TreeError {\n    return new TreeError(elementName, span, msg);\n  }\n\n  constructor(public elementName: string|null, span: ParseSourceSpan, msg: string) {\n    super(span, msg);\n  }\n}\n\nexport class ParseTreeResult {\n  constructor(public rootNodes: html.Node[], public errors: ParseError[]) {}\n}\n\nexport class Parser {\n  constructor(public getTagDefinition: (tagName: string) => TagDefinition) {}\n\n  parse(source: string, url: string, options?: lex.TokenizeOptions): ParseTreeResult {\n    const tokensAndErrors = lex.tokenize(source, url, this.getTagDefinition, options);\n\n    const treeAndErrors = new _TreeBuilder(tokensAndErrors.tokens, this.getTagDefinition).build();\n\n    return new ParseTreeResult(\n        treeAndErrors.rootNodes,\n        (<ParseError[]>tokensAndErrors.errors).concat(treeAndErrors.errors));\n  }\n}\n\nclass _TreeBuilder {\n  private _index: number = -1;\n  // TODO(issue/24571): remove '!'.\n  private _peek !: lex.Token;\n\n  private _rootNodes: html.Node[] = [];\n  private _errors: TreeError[] = [];\n\n  private _elementStack: html.Element[] = [];\n\n  constructor(\n      private tokens: lex.Token[], private getTagDefinition: (tagName: string) => TagDefinition) {\n    this._advance();\n  }\n\n  build(): ParseTreeResult {\n    while (this._peek.type !== lex.TokenType.EOF) {\n      if (this._peek.type === lex.TokenType.TAG_OPEN_START) {\n        this._consumeStartTag(this._advance());\n      } else if (this._peek.type === lex.TokenType.TAG_CLOSE) {\n        this._consumeEndTag(this._advance());\n      } else if (this._peek.type === lex.TokenType.CDATA_START) {\n        this._closeVoidElement();\n        this._consumeCdata(this._advance());\n      } else if (this._peek.type === lex.TokenType.COMMENT_START) {\n        this._closeVoidElement();\n        this._consumeComment(this._advance());\n      } else if (\n          this._peek.type === lex.TokenType.TEXT || this._peek.type === lex.TokenType.RAW_TEXT ||\n          this._peek.type === lex.TokenType.ESCAPABLE_RAW_TEXT) {\n        this._closeVoidElement();\n        this._consumeText(this._advance());\n      } else if (this._peek.type === lex.TokenType.EXPANSION_FORM_START) {\n        this._consumeExpansion(this._advance());\n      } else {\n        // Skip all other tokens...\n        this._advance();\n      }\n    }\n    return new ParseTreeResult(this._rootNodes, this._errors);\n  }\n\n  private _advance(): lex.Token {\n    const prev = this._peek;\n    if (this._index < this.tokens.length - 1) {\n      // Note: there is always an EOF token at the end\n      this._index++;\n    }\n    this._peek = this.tokens[this._index];\n    return prev;\n  }\n\n  private _advanceIf(type: lex.TokenType): lex.Token|null {\n    if (this._peek.type === type) {\n      return this._advance();\n    }\n    return null;\n  }\n\n  private _consumeCdata(startToken: lex.Token) {\n    this._consumeText(this._advance());\n    this._advanceIf(lex.TokenType.CDATA_END);\n  }\n\n  private _consumeComment(token: lex.Token) {\n    const text = this._advanceIf(lex.TokenType.RAW_TEXT);\n    this._advanceIf(lex.TokenType.COMMENT_END);\n    const value = text != null ? text.parts[0].trim() : null;\n    this._addToParent(new html.Comment(value, token.sourceSpan));\n  }\n\n  private _consumeExpansion(token: lex.Token) {\n    const switchValue = this._advance();\n\n    const type = this._advance();\n    const cases: html.ExpansionCase[] = [];\n\n    // read =\n    while (this._peek.type === lex.TokenType.EXPANSION_CASE_VALUE) {\n      const expCase = this._parseExpansionCase();\n      if (!expCase) return;  // error\n      cases.push(expCase);\n    }\n\n    // read the final }\n    if (this._peek.type !== lex.TokenType.EXPANSION_FORM_END) {\n      this._errors.push(\n          TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\n      return;\n    }\n    const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n    this._addToParent(new html.Expansion(\n        switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n\n    this._advance();\n  }\n\n  private _parseExpansionCase(): html.ExpansionCase|null {\n    const value = this._advance();\n\n    // read {\n    if (this._peek.type !== lex.TokenType.EXPANSION_CASE_EXP_START) {\n      this._errors.push(\n          TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\n      return null;\n    }\n\n    // read until }\n    const start = this._advance();\n\n    const exp = this._collectExpansionExpTokens(start);\n    if (!exp) return null;\n\n    const end = this._advance();\n    exp.push(new lex.Token(lex.TokenType.EOF, [], end.sourceSpan));\n\n    // parse everything in between { and }\n    const parsedExp = new _TreeBuilder(exp, this.getTagDefinition).build();\n    if (parsedExp.errors.length > 0) {\n      this._errors = this._errors.concat(<TreeError[]>parsedExp.errors);\n      return null;\n    }\n\n    const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n    const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n    return new html.ExpansionCase(\n        value.parts[0], parsedExp.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n  }\n\n  private _collectExpansionExpTokens(start: lex.Token): lex.Token[]|null {\n    const exp: lex.Token[] = [];\n    const expansionFormStack = [lex.TokenType.EXPANSION_CASE_EXP_START];\n\n    while (true) {\n      if (this._peek.type === lex.TokenType.EXPANSION_FORM_START ||\n          this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_START) {\n        expansionFormStack.push(this._peek.type);\n      }\n\n      if (this._peek.type === lex.TokenType.EXPANSION_CASE_EXP_END) {\n        if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_CASE_EXP_START)) {\n          expansionFormStack.pop();\n          if (expansionFormStack.length == 0) return exp;\n\n        } else {\n          this._errors.push(\n              TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === lex.TokenType.EXPANSION_FORM_END) {\n        if (lastOnStack(expansionFormStack, lex.TokenType.EXPANSION_FORM_START)) {\n          expansionFormStack.pop();\n        } else {\n          this._errors.push(\n              TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n          return null;\n        }\n      }\n\n      if (this._peek.type === lex.TokenType.EOF) {\n        this._errors.push(\n            TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\n        return null;\n      }\n\n      exp.push(this._advance());\n    }\n  }\n\n  private _consumeText(token: lex.Token) {\n    let text = token.parts[0];\n    if (text.length > 0 && text[0] == '\\n') {\n      const parent = this._getParentElement();\n      if (parent != null && parent.children.length == 0 &&\n          this.getTagDefinition(parent.name).ignoreFirstLf) {\n        text = text.substring(1);\n      }\n    }\n\n    if (text.length > 0) {\n      this._addToParent(new html.Text(text, token.sourceSpan));\n    }\n  }\n\n  private _closeVoidElement(): void {\n    const el = this._getParentElement();\n    if (el && this.getTagDefinition(el.name).isVoid) {\n      this._elementStack.pop();\n    }\n  }\n\n  private _consumeStartTag(startTagToken: lex.Token) {\n    const prefix = startTagToken.parts[0];\n    const name = startTagToken.parts[1];\n    const attrs: html.Attribute[] = [];\n    while (this._peek.type === lex.TokenType.ATTR_NAME) {\n      attrs.push(this._consumeAttr(this._advance()));\n    }\n    const fullName = this._getElementFullName(prefix, name, this._getParentElement());\n    let selfClosing = false;\n    // Note: There could have been a tokenizer error\n    // so that we don't get a token for the end tag...\n    if (this._peek.type === lex.TokenType.TAG_OPEN_END_VOID) {\n      this._advance();\n      selfClosing = true;\n      const tagDef = this.getTagDefinition(fullName);\n      if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n        this._errors.push(TreeError.create(\n            fullName, startTagToken.sourceSpan,\n            `Only void and foreign elements can be self closed \"${startTagToken.parts[1]}\"`));\n      }\n    } else if (this._peek.type === lex.TokenType.TAG_OPEN_END) {\n      this._advance();\n      selfClosing = false;\n    }\n    const end = this._peek.sourceSpan.start;\n    const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n    const el = new html.Element(fullName, attrs, [], span, span, undefined);\n    this._pushElement(el);\n    if (selfClosing) {\n      this._popElement(fullName);\n      el.endSourceSpan = span;\n    }\n  }\n\n  private _pushElement(el: html.Element) {\n    const parentEl = this._getParentElement();\n\n    if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n      this._elementStack.pop();\n    }\n\n    this._addToParent(el);\n    this._elementStack.push(el);\n  }\n\n  private _consumeEndTag(endTagToken: lex.Token) {\n    const fullName = this._getElementFullName(\n        endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n\n    if (this._getParentElement()) {\n      this._getParentElement() !.endSourceSpan = endTagToken.sourceSpan;\n    }\n\n    if (this.getTagDefinition(fullName).isVoid) {\n      this._errors.push(TreeError.create(\n          fullName, endTagToken.sourceSpan,\n          `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\n    } else if (!this._popElement(fullName)) {\n      const errMsg =\n          `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\n      this._errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n    }\n  }\n\n  private _popElement(fullName: string): boolean {\n    for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n      const el = this._elementStack[stackIndex];\n      if (el.name == fullName) {\n        this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n        return true;\n      }\n\n      if (!this.getTagDefinition(el.name).closedByParent) {\n        return false;\n      }\n    }\n    return false;\n  }\n\n  private _consumeAttr(attrName: lex.Token): html.Attribute {\n    const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n    let end = attrName.sourceSpan.end;\n    let value = '';\n    let valueSpan: ParseSourceSpan = undefined !;\n    if (this._peek.type === lex.TokenType.ATTR_QUOTE) {\n      this._advance();\n    }\n    if (this._peek.type === lex.TokenType.ATTR_VALUE) {\n      const valueToken = this._advance();\n      value = valueToken.parts[0];\n      end = valueToken.sourceSpan.end;\n      valueSpan = valueToken.sourceSpan;\n    }\n    if (this._peek.type === lex.TokenType.ATTR_QUOTE) {\n      const quoteToken = this._advance();\n      end = quoteToken.sourceSpan.end;\n    }\n    return new html.Attribute(\n        fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n  }\n\n  private _getParentElement(): html.Element|null {\n    return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n  }\n\n  /**\n   * Returns the parent in the DOM and the container.\n   *\n   * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n   */\n  private _getParentElementSkippingContainers():\n      {parent: html.Element | null, container: html.Element|null} {\n    let container: html.Element|null = null;\n\n    for (let i = this._elementStack.length - 1; i >= 0; i--) {\n      if (!isNgContainer(this._elementStack[i].name)) {\n        return {parent: this._elementStack[i], container};\n      }\n      container = this._elementStack[i];\n    }\n\n    return {parent: null, container};\n  }\n\n  private _addToParent(node: html.Node) {\n    const parent = this._getParentElement();\n    if (parent != null) {\n      parent.children.push(node);\n    } else {\n      this._rootNodes.push(node);\n    }\n  }\n\n  /**\n   * Insert a node between the parent and the container.\n   * When no container is given, the node is appended as a child of the parent.\n   * Also updates the element stack accordingly.\n   *\n   * @internal\n   */\n  private _insertBeforeContainer(\n      parent: html.Element, container: html.Element|null, node: html.Element) {\n    if (!container) {\n      this._addToParent(node);\n      this._elementStack.push(node);\n    } else {\n      if (parent) {\n        // replace the container with the new node in the children\n        const index = parent.children.indexOf(container);\n        parent.children[index] = node;\n      } else {\n        this._rootNodes.push(node);\n      }\n      node.children.push(container);\n      this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n    }\n  }\n\n  private _getElementFullName(prefix: string, localName: string, parentElement: html.Element|null):\n      string {\n    if (prefix === '') {\n      prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\n      if (prefix === '' && parentElement != null) {\n        prefix = getNsPrefix(parentElement.name);\n      }\n    }\n\n    return mergeNsAndName(prefix, localName);\n  }\n}\n\nfunction lastOnStack(stack: any[], element: any): boolean {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getHtmlTagDefinition} from './html_tags';\nimport {TokenizeOptions} from './lexer';\nimport {ParseTreeResult, Parser} from './parser';\n\nexport {ParseTreeResult, TreeError} from './parser';\n\nexport class HtmlParser extends Parser {\n  constructor() { super(getHtmlTagDefinition); }\n\n  parse(source: string, url: string, options?: TokenizeOptions): ParseTreeResult {\n    return super.parse(source, url, options);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from './ast';\nimport {ParseTreeResult} from './parser';\nimport {NGSP_UNICODE} from './tags';\n\nexport const PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\n\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\n\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\n\nfunction hasPreserveWhitespacesAttr(attrs: html.Attribute[]): boolean {\n  return attrs.some((attr: html.Attribute) => attr.name === PRESERVE_WS_ATTR_NAME);\n}\n\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here.\n */\nexport function replaceNgsp(value: string): string {\n  // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n  return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n */\nexport class WhitespaceVisitor implements html.Visitor {\n  visitElement(element: html.Element, context: any): any {\n    if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n      // don't descent into elements where we need to preserve whitespaces\n      // but still visit all attributes to eliminate one used as a market to preserve WS\n      return new html.Element(\n          element.name, html.visitAll(this, element.attrs), element.children, element.sourceSpan,\n          element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n\n    return new html.Element(\n        element.name, element.attrs, visitAllWithSiblings(this, element.children),\n        element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any {\n    return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n  }\n\n  visitText(text: html.Text, context: SiblingVisitorContext|null): any {\n    const isNotBlank = text.value.match(NO_WS_REGEXP);\n    const hasExpansionSibling = context &&\n        (context.prev instanceof html.Expansion || context.next instanceof html.Expansion);\n\n    if (isNotBlank || hasExpansionSibling) {\n      return new html.Text(\n          replaceNgsp(text.value).replace(WS_REPLACE_REGEXP, ' '), text.sourceSpan, text.i18n);\n    }\n\n    return null;\n  }\n\n  visitComment(comment: html.Comment, context: any): any { return comment; }\n\n  visitExpansion(expansion: html.Expansion, context: any): any { return expansion; }\n\n  visitExpansionCase(expansionCase: html.ExpansionCase, context: any): any { return expansionCase; }\n}\n\nexport function removeWhitespaces(htmlAstWithErrors: ParseTreeResult): ParseTreeResult {\n  return new ParseTreeResult(\n      html.visitAll(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes),\n      htmlAstWithErrors.errors);\n}\n\ninterface SiblingVisitorContext {\n  prev: html.Node|undefined;\n  next: html.Node|undefined;\n}\n\nfunction visitAllWithSiblings(visitor: WhitespaceVisitor, nodes: html.Node[]): any[] {\n  const result: any[] = [];\n\n  nodes.forEach((ast, i) => {\n    const context: SiblingVisitorContext = {prev: nodes[i - 1], next: nodes[i + 1]};\n    const astResult = ast.visit(visitor, context);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ParseError, ParseSourceSpan} from '../parse_util';\n\nimport * as html from './ast';\n\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\nconst PLURAL_CASES: string[] = ['zero', 'one', 'two', 'few', 'many', 'other'];\n\n/**\n * Expands special forms into elements.\n *\n * For example,\n *\n * ```\n * { messages.length, plural,\n *   =0 {zero}\n *   =1 {one}\n *   other {more than one}\n * }\n * ```\n *\n * will be expanded into\n *\n * ```\n * <ng-container [ngPlural]=\"messages.length\">\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\n * </ng-container>\n * ```\n */\nexport function expandNodes(nodes: html.Node[]): ExpansionResult {\n  const expander = new _Expander();\n  return new ExpansionResult(html.visitAll(expander, nodes), expander.isExpanded, expander.errors);\n}\n\nexport class ExpansionResult {\n  constructor(public nodes: html.Node[], public expanded: boolean, public errors: ParseError[]) {}\n}\n\nexport class ExpansionError extends ParseError {\n  constructor(span: ParseSourceSpan, errorMsg: string) { super(span, errorMsg); }\n}\n\n/**\n * Expand expansion forms (plural, select) to directives\n *\n * @internal\n */\nclass _Expander implements html.Visitor {\n  isExpanded: boolean = false;\n  errors: ParseError[] = [];\n\n  visitElement(element: html.Element, context: any): any {\n    return new html.Element(\n        element.name, element.attrs, html.visitAll(this, element.children), element.sourceSpan,\n        element.startSourceSpan, element.endSourceSpan);\n  }\n\n  visitAttribute(attribute: html.Attribute, context: any): any { return attribute; }\n\n  visitText(text: html.Text, context: any): any { return text; }\n\n  visitComment(comment: html.Comment, context: any): any { return comment; }\n\n  visitExpansion(icu: html.Expansion, context: any): any {\n    this.isExpanded = true;\n    return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :\n                                  _expandDefaultForm(icu, this.errors);\n  }\n\n  visitExpansionCase(icuCase: html.ExpansionCase, context: any): any {\n    throw new Error('Should not be reached');\n  }\n}\n\n// Plural forms are expanded to `NgPlural` and `NgPluralCase`s\nfunction _expandPluralForm(ast: html.Expansion, errors: ParseError[]): html.Element {\n  const children = ast.cases.map(c => {\n    if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n      errors.push(new ExpansionError(\n          c.valueSourceSpan,\n          `Plural cases should be \"=<number>\" or one of ${PLURAL_CASES.join(\", \")}`));\n    }\n\n    const expansionResult = expandNodes(c.expression);\n    errors.push(...expansionResult.errors);\n\n    return new html.Element(\n        `ng-template`, [new html.Attribute('ngPluralCase', `${c.value}`, c.valueSourceSpan)],\n        expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n  });\n  const switchAttr = new html.Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);\n  return new html.Element(\n      'ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n\n// ICU messages (excluding plural form) are expanded to `NgSwitch`  and `NgSwitchCase`s\nfunction _expandDefaultForm(ast: html.Expansion, errors: ParseError[]): html.Element {\n  const children = ast.cases.map(c => {\n    const expansionResult = expandNodes(c.expression);\n    errors.push(...expansionResult.errors);\n\n    if (c.value === 'other') {\n      // other is the default case when no values match\n      return new html.Element(\n          `ng-template`, [new html.Attribute('ngSwitchDefault', '', c.valueSourceSpan)],\n          expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    }\n\n    return new html.Element(\n        `ng-template`, [new html.Attribute('ngSwitchCase', `${c.value}`, c.valueSourceSpan)],\n        expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n  });\n  const switchAttr = new html.Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);\n  return new html.Element(\n      'ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AstPath} from '../ast_path';\nimport {CompileDirectiveSummary, CompileProviderMetadata, CompileTokenMetadata} from '../compile_metadata';\nimport {SecurityContext} from '../core';\nimport {AST, BindingType, BoundElementProperty, ParsedEvent, ParsedEventType, ParsedVariable} from '../expression_parser/ast';\nimport {LifecycleHooks} from '../lifecycle_reflector';\nimport {ParseSourceSpan} from '../parse_util';\n\n\n\n/**\n * An Abstract Syntax Tree node representing part of a parsed Angular template.\n */\nexport interface TemplateAst {\n  /**\n   * The source span from which this node was parsed.\n   */\n  sourceSpan: ParseSourceSpan;\n\n  /**\n   * Visit this node and possibly transform it.\n   */\n  visit(visitor: TemplateAstVisitor, context: any): any;\n}\n\n/**\n * A segment of text within the template.\n */\nexport class TextAst implements TemplateAst {\n  constructor(\n      public value: string, public ngContentIndex: number, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any { return visitor.visitText(this, context); }\n}\n\n/**\n * A bound expression within the text of a template.\n */\nexport class BoundTextAst implements TemplateAst {\n  constructor(\n      public value: AST, public ngContentIndex: number, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitBoundText(this, context);\n  }\n}\n\n/**\n * A plain attribute on an element.\n */\nexport class AttrAst implements TemplateAst {\n  constructor(public name: string, public value: string, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any { return visitor.visitAttr(this, context); }\n}\n\nexport const enum PropertyBindingType {\n  // A normal binding to a property (e.g. `[property]=\"expression\"`).\n  Property,\n  // A binding to an element attribute (e.g. `[attr.name]=\"expression\"`).\n  Attribute,\n  // A binding to a CSS class (e.g. `[class.name]=\"condition\"`).\n  Class,\n  // A binding to a style rule (e.g. `[style.rule]=\"expression\"`).\n  Style,\n  // A binding to an animation reference (e.g. `[animate.key]=\"expression\"`).\n  Animation,\n}\n\nconst BoundPropertyMapping = {\n  [BindingType.Animation]: PropertyBindingType.Animation,\n  [BindingType.Attribute]: PropertyBindingType.Attribute,\n  [BindingType.Class]: PropertyBindingType.Class,\n  [BindingType.Property]: PropertyBindingType.Property,\n  [BindingType.Style]: PropertyBindingType.Style,\n};\n\n/**\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n * `[@trigger]=\"stateExp\"`)\n */\nexport class BoundElementPropertyAst implements TemplateAst {\n  readonly isAnimation: boolean;\n\n  constructor(\n      public name: string, public type: PropertyBindingType,\n      public securityContext: SecurityContext, public value: AST, public unit: string|null,\n      public sourceSpan: ParseSourceSpan) {\n    this.isAnimation = this.type === PropertyBindingType.Animation;\n  }\n\n  static fromBoundProperty(prop: BoundElementProperty) {\n    const type = BoundPropertyMapping[prop.type];\n    return new BoundElementPropertyAst(\n        prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);\n  }\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitElementProperty(this, context);\n  }\n}\n\n/**\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n * `(@trigger.phase)=\"callback($event)\"`).\n */\nexport class BoundEventAst implements TemplateAst {\n  readonly fullName: string;\n  readonly isAnimation: boolean;\n\n  constructor(\n      public name: string, public target: string|null, public phase: string|null,\n      public handler: AST, public sourceSpan: ParseSourceSpan,\n      public handlerSpan: ParseSourceSpan) {\n    this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);\n    this.isAnimation = !!this.phase;\n  }\n\n  static calcFullName(name: string, target: string|null, phase: string|null): string {\n    if (target) {\n      return `${target}:${name}`;\n    }\n    if (phase) {\n      return `@${name}.${phase}`;\n    }\n\n    return name;\n  }\n\n  static fromParsedEvent(event: ParsedEvent) {\n    const target: string|null = event.type === ParsedEventType.Regular ? event.targetOrPhase : null;\n    const phase: string|null =\n        event.type === ParsedEventType.Animation ? event.targetOrPhase : null;\n    return new BoundEventAst(\n        event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);\n  }\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitEvent(this, context);\n  }\n}\n\n/**\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n */\nexport class ReferenceAst implements TemplateAst {\n  constructor(\n      public name: string, public value: CompileTokenMetadata, public originalValue: string,\n      public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitReference(this, context);\n  }\n}\n\n/**\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n */\nexport class VariableAst implements TemplateAst {\n  constructor(public name: string, public value: string, public sourceSpan: ParseSourceSpan) {}\n\n  static fromParsedVariable(v: ParsedVariable) {\n    return new VariableAst(v.name, v.value, v.sourceSpan);\n  }\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitVariable(this, context);\n  }\n}\n\n/**\n * An element declaration in a template.\n */\nexport class ElementAst implements TemplateAst {\n  constructor(\n      public name: string, public attrs: AttrAst[], public inputs: BoundElementPropertyAst[],\n      public outputs: BoundEventAst[], public references: ReferenceAst[],\n      public directives: DirectiveAst[], public providers: ProviderAst[],\n      public hasViewContainer: boolean, public queryMatches: QueryMatch[],\n      public children: TemplateAst[], public ngContentIndex: number|null,\n      public sourceSpan: ParseSourceSpan, public endSourceSpan: ParseSourceSpan|null) {}\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitElement(this, context);\n  }\n}\n\n/**\n * A `<ng-template>` element included in an Angular template.\n */\nexport class EmbeddedTemplateAst implements TemplateAst {\n  constructor(\n      public attrs: AttrAst[], public outputs: BoundEventAst[], public references: ReferenceAst[],\n      public variables: VariableAst[], public directives: DirectiveAst[],\n      public providers: ProviderAst[], public hasViewContainer: boolean,\n      public queryMatches: QueryMatch[], public children: TemplateAst[],\n      public ngContentIndex: number, public sourceSpan: ParseSourceSpan) {}\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitEmbeddedTemplate(this, context);\n  }\n}\n\n/**\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n */\nexport class BoundDirectivePropertyAst implements TemplateAst {\n  constructor(\n      public directiveName: string, public templateName: string, public value: AST,\n      public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitDirectiveProperty(this, context);\n  }\n}\n\n/**\n * A directive declared on an element.\n */\nexport class DirectiveAst implements TemplateAst {\n  constructor(\n      public directive: CompileDirectiveSummary, public inputs: BoundDirectivePropertyAst[],\n      public hostProperties: BoundElementPropertyAst[], public hostEvents: BoundEventAst[],\n      public contentQueryStartId: number, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitDirective(this, context);\n  }\n}\n\n/**\n * A provider declared on an element\n */\nexport class ProviderAst implements TemplateAst {\n  constructor(\n      public token: CompileTokenMetadata, public multiProvider: boolean, public eager: boolean,\n      public providers: CompileProviderMetadata[], public providerType: ProviderAstType,\n      public lifecycleHooks: LifecycleHooks[], public sourceSpan: ParseSourceSpan,\n      readonly isModule: boolean) {}\n\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    // No visit method in the visitor for now...\n    return null;\n  }\n}\n\nexport enum ProviderAstType {\n  PublicService,\n  PrivateService,\n  Component,\n  Directive,\n  Builtin\n}\n\n/**\n * Position where content is to be projected (instance of `<ng-content>` in a template).\n */\nexport class NgContentAst implements TemplateAst {\n  constructor(\n      public index: number, public ngContentIndex: number, public sourceSpan: ParseSourceSpan) {}\n  visit(visitor: TemplateAstVisitor, context: any): any {\n    return visitor.visitNgContent(this, context);\n  }\n}\n\nexport interface QueryMatch {\n  queryId: number;\n  value: CompileTokenMetadata;\n}\n\n/**\n * A visitor for {@link TemplateAst} trees that will process each node.\n */\nexport interface TemplateAstVisitor {\n  // Returning a truthy value from `visit()` will prevent `templateVisitAll()` from the call to\n  // the typed method and result returned will become the result included in `visitAll()`s\n  // result array.\n  visit?(ast: TemplateAst, context: any): any;\n\n  visitNgContent(ast: NgContentAst, context: any): any;\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any;\n  visitElement(ast: ElementAst, context: any): any;\n  visitReference(ast: ReferenceAst, context: any): any;\n  visitVariable(ast: VariableAst, context: any): any;\n  visitEvent(ast: BoundEventAst, context: any): any;\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): any;\n  visitAttr(ast: AttrAst, context: any): any;\n  visitBoundText(ast: BoundTextAst, context: any): any;\n  visitText(ast: TextAst, context: any): any;\n  visitDirective(ast: DirectiveAst, context: any): any;\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): any;\n}\n\n/**\n * A visitor that accepts each node but doesn't do anything. It is intended to be used\n * as the base class for a visitor that is only interested in a subset of the node types.\n */\nexport class NullTemplateVisitor implements TemplateAstVisitor {\n  visitNgContent(ast: NgContentAst, context: any): void {}\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): void {}\n  visitElement(ast: ElementAst, context: any): void {}\n  visitReference(ast: ReferenceAst, context: any): void {}\n  visitVariable(ast: VariableAst, context: any): void {}\n  visitEvent(ast: BoundEventAst, context: any): void {}\n  visitElementProperty(ast: BoundElementPropertyAst, context: any): void {}\n  visitAttr(ast: AttrAst, context: any): void {}\n  visitBoundText(ast: BoundTextAst, context: any): void {}\n  visitText(ast: TextAst, context: any): void {}\n  visitDirective(ast: DirectiveAst, context: any): void {}\n  visitDirectiveProperty(ast: BoundDirectivePropertyAst, context: any): void {}\n}\n\n/**\n * Base class that can be used to build a visitor that visits each node\n * in an template ast recursively.\n */\nexport class RecursiveTemplateAstVisitor extends NullTemplateVisitor implements TemplateAstVisitor {\n  constructor() { super(); }\n\n  // Nodes with children\n  visitEmbeddedTemplate(ast: EmbeddedTemplateAst, context: any): any {\n    return this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.references);\n      visit(ast.variables);\n      visit(ast.directives);\n      visit(ast.providers);\n      visit(ast.children);\n    });\n  }\n\n  visitElement(ast: ElementAst, context: any): any {\n    return this.visitChildren(context, visit => {\n      visit(ast.attrs);\n      visit(ast.inputs);\n      visit(ast.outputs);\n      visit(ast.references);\n      visit(ast.directives);\n      visit(ast.providers);\n      visit(ast.children);\n    });\n  }\n\n  visitDirective(ast: DirectiveAst, context: any): any {\n    return this.visitChildren(context, visit => {\n      visit(ast.inputs);\n      visit(ast.hostProperties);\n      visit(ast.hostEvents);\n    });\n  }\n\n  protected visitChildren<T extends TemplateAst>(\n      context: any,\n      cb: (visit: (<V extends TemplateAst>(children: V[]|undefined) => void)) => void) {\n    let results: any[][] = [];\n    let t = this;\n    function visit<T extends TemplateAst>(children: T[] | undefined) {\n      if (children && children.length) results.push(templateVisitAll(t, children, context));\n    }\n    cb(visit);\n    return Array.prototype.concat.apply([], results);\n  }\n}\n\n/**\n * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\n */\nexport function templateVisitAll(\n    visitor: TemplateAstVisitor, asts: TemplateAst[], context: any = null): any[] {\n  const result: any[] = [];\n  const visit = visitor.visit ?\n      (ast: TemplateAst) => visitor.visit !(ast, context) || ast.visit(visitor, context) :\n      (ast: TemplateAst) => ast.visit(visitor, context);\n  asts.forEach(ast => {\n    const astResult = visit(ast);\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nexport type TemplateAstPath = AstPath<TemplateAst>;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {CompileDiDependencyMetadata, CompileDirectiveMetadata, CompileDirectiveSummary, CompileNgModuleMetadata, CompileProviderMetadata, CompileQueryMetadata, CompileTokenMetadata, CompileTypeMetadata, tokenName, tokenReference} from './compile_metadata';\nimport {CompileReflector} from './compile_reflector';\nimport {Identifiers, createTokenForExternalReference} from './identifiers';\nimport {ParseError, ParseSourceSpan} from './parse_util';\nimport {AttrAst, DirectiveAst, ProviderAst, ProviderAstType, QueryMatch, ReferenceAst} from './template_parser/template_ast';\n\nexport class ProviderError extends ParseError {\n  constructor(message: string, span: ParseSourceSpan) { super(span, message); }\n}\n\nexport interface QueryWithId {\n  meta: CompileQueryMetadata;\n  queryId: number;\n}\n\nexport class ProviderViewContext {\n  /**\n   * @internal\n   */\n  viewQueries: Map<any, QueryWithId[]>;\n  /**\n   * @internal\n   */\n  viewProviders: Map<any, boolean>;\n  errors: ProviderError[] = [];\n\n  constructor(public reflector: CompileReflector, public component: CompileDirectiveMetadata) {\n    this.viewQueries = _getViewQueries(component);\n    this.viewProviders = new Map<any, boolean>();\n    component.viewProviders.forEach((provider) => {\n      if (this.viewProviders.get(tokenReference(provider.token)) == null) {\n        this.viewProviders.set(tokenReference(provider.token), true);\n      }\n    });\n  }\n}\n\nexport class ProviderElementContext {\n  private _contentQueries: Map<any, QueryWithId[]>;\n\n  private _transformedProviders = new Map<any, ProviderAst>();\n  private _seenProviders = new Map<any, boolean>();\n  private _allProviders: Map<any, ProviderAst>;\n  private _attrs: {[key: string]: string};\n  private _queriedTokens = new Map<any, QueryMatch[]>();\n\n  public readonly transformedHasViewContainer: boolean = false;\n\n  constructor(\n      public viewContext: ProviderViewContext, private _parent: ProviderElementContext,\n      private _isViewRoot: boolean, private _directiveAsts: DirectiveAst[], attrs: AttrAst[],\n      refs: ReferenceAst[], isTemplate: boolean, contentQueryStartId: number,\n      private _sourceSpan: ParseSourceSpan) {\n    this._attrs = {};\n    attrs.forEach((attrAst) => this._attrs[attrAst.name] = attrAst.value);\n    const directivesMeta = _directiveAsts.map(directiveAst => directiveAst.directive);\n    this._allProviders =\n        _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n    this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n    Array.from(this._allProviders.values()).forEach((provider) => {\n      this._addQueryReadsTo(provider.token, provider.token, this._queriedTokens);\n    });\n    if (isTemplate) {\n      const templateRefId =\n          createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);\n      this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n    }\n    refs.forEach((refAst) => {\n      let defaultQueryValue = refAst.value ||\n          createTokenForExternalReference(this.viewContext.reflector, Identifiers.ElementRef);\n      this._addQueryReadsTo({value: refAst.name}, defaultQueryValue, this._queriedTokens);\n    });\n    if (this._queriedTokens.get(\n            this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {\n      this.transformedHasViewContainer = true;\n    }\n\n    // create the providers that we know are eager first\n    Array.from(this._allProviders.values()).forEach((provider) => {\n      const eager = provider.eager || this._queriedTokens.get(tokenReference(provider.token));\n      if (eager) {\n        this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n      }\n    });\n  }\n\n  afterElement() {\n    // collect lazy providers\n    Array.from(this._allProviders.values()).forEach((provider) => {\n      this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n    });\n  }\n\n  get transformProviders(): ProviderAst[] {\n    // Note: Maps keep their insertion order.\n    const lazyProviders: ProviderAst[] = [];\n    const eagerProviders: ProviderAst[] = [];\n    this._transformedProviders.forEach(provider => {\n      if (provider.eager) {\n        eagerProviders.push(provider);\n      } else {\n        lazyProviders.push(provider);\n      }\n    });\n    return lazyProviders.concat(eagerProviders);\n  }\n\n  get transformedDirectiveAsts(): DirectiveAst[] {\n    const sortedProviderTypes = this.transformProviders.map(provider => provider.token.identifier);\n    const sortedDirectives = this._directiveAsts.slice();\n    sortedDirectives.sort(\n        (dir1, dir2) => sortedProviderTypes.indexOf(dir1.directive.type) -\n            sortedProviderTypes.indexOf(dir2.directive.type));\n    return sortedDirectives;\n  }\n\n  get queryMatches(): QueryMatch[] {\n    const allMatches: QueryMatch[] = [];\n    this._queriedTokens.forEach((matches: QueryMatch[]) => { allMatches.push(...matches); });\n    return allMatches;\n  }\n\n  private _addQueryReadsTo(\n      token: CompileTokenMetadata, defaultValue: CompileTokenMetadata,\n      queryReadTokens: Map<any, QueryMatch[]>) {\n    this._getQueriesFor(token).forEach((query) => {\n      const queryValue = query.meta.read || defaultValue;\n      const tokenRef = tokenReference(queryValue);\n      let queryMatches = queryReadTokens.get(tokenRef);\n      if (!queryMatches) {\n        queryMatches = [];\n        queryReadTokens.set(tokenRef, queryMatches);\n      }\n      queryMatches.push({queryId: query.queryId, value: queryValue});\n    });\n  }\n\n  private _getQueriesFor(token: CompileTokenMetadata): QueryWithId[] {\n    const result: QueryWithId[] = [];\n    let currentEl: ProviderElementContext = this;\n    let distance = 0;\n    let queries: QueryWithId[]|undefined;\n    while (currentEl !== null) {\n      queries = currentEl._contentQueries.get(tokenReference(token));\n      if (queries) {\n        result.push(...queries.filter((query) => query.meta.descendants || distance <= 1));\n      }\n      if (currentEl._directiveAsts.length > 0) {\n        distance++;\n      }\n      currentEl = currentEl._parent;\n    }\n    queries = this.viewContext.viewQueries.get(tokenReference(token));\n    if (queries) {\n      result.push(...queries);\n    }\n    return result;\n  }\n\n\n  private _getOrCreateLocalProvider(\n      requestingProviderType: ProviderAstType, token: CompileTokenMetadata,\n      eager: boolean): ProviderAst|null {\n    const resolvedProvider = this._allProviders.get(tokenReference(token));\n    if (!resolvedProvider || ((requestingProviderType === ProviderAstType.Directive ||\n                               requestingProviderType === ProviderAstType.PublicService) &&\n                              resolvedProvider.providerType === ProviderAstType.PrivateService) ||\n        ((requestingProviderType === ProviderAstType.PrivateService ||\n          requestingProviderType === ProviderAstType.PublicService) &&\n         resolvedProvider.providerType === ProviderAstType.Builtin)) {\n      return null;\n    }\n    let transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n    if (transformedProviderAst) {\n      return transformedProviderAst;\n    }\n    if (this._seenProviders.get(tokenReference(token)) != null) {\n      this.viewContext.errors.push(new ProviderError(\n          `Cannot instantiate cyclic dependency! ${tokenName(token)}`, this._sourceSpan));\n      return null;\n    }\n    this._seenProviders.set(tokenReference(token), true);\n    const transformedProviders = resolvedProvider.providers.map((provider) => {\n      let transformedUseValue = provider.useValue;\n      let transformedUseExisting = provider.useExisting !;\n      let transformedDeps: CompileDiDependencyMetadata[] = undefined !;\n      if (provider.useExisting != null) {\n        const existingDiDep = this._getDependency(\n            resolvedProvider.providerType, {token: provider.useExisting}, eager) !;\n        if (existingDiDep.token != null) {\n          transformedUseExisting = existingDiDep.token;\n        } else {\n          transformedUseExisting = null !;\n          transformedUseValue = existingDiDep.value;\n        }\n      } else if (provider.useFactory) {\n        const deps = provider.deps || provider.useFactory.diDeps;\n        transformedDeps =\n            deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager) !);\n      } else if (provider.useClass) {\n        const deps = provider.deps || provider.useClass.diDeps;\n        transformedDeps =\n            deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager) !);\n      }\n      return _transformProvider(provider, {\n        useExisting: transformedUseExisting,\n        useValue: transformedUseValue,\n        deps: transformedDeps\n      });\n    });\n    transformedProviderAst =\n        _transformProviderAst(resolvedProvider, {eager: eager, providers: transformedProviders});\n    this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n    return transformedProviderAst;\n  }\n\n  private _getLocalDependency(\n      requestingProviderType: ProviderAstType, dep: CompileDiDependencyMetadata,\n      eager: boolean = false): CompileDiDependencyMetadata|null {\n    if (dep.isAttribute) {\n      const attrValue = this._attrs[dep.token !.value];\n      return {isValue: true, value: attrValue == null ? null : attrValue};\n    }\n\n    if (dep.token != null) {\n      // access builtints\n      if ((requestingProviderType === ProviderAstType.Directive ||\n           requestingProviderType === ProviderAstType.Component)) {\n        if (tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) ||\n            tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) ||\n            tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(\n                    Identifiers.ChangeDetectorRef) ||\n            tokenReference(dep.token) ===\n                this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n          return dep;\n        }\n        if (tokenReference(dep.token) ===\n            this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n          (this as{transformedHasViewContainer: boolean}).transformedHasViewContainer = true;\n        }\n      }\n      // access the injector\n      if (tokenReference(dep.token) ===\n          this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {\n        return dep;\n      }\n      // access providers\n      if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n        return dep;\n      }\n    }\n    return null;\n  }\n\n  private _getDependency(\n      requestingProviderType: ProviderAstType, dep: CompileDiDependencyMetadata,\n      eager: boolean = false): CompileDiDependencyMetadata|null {\n    let currElement: ProviderElementContext = this;\n    let currEager: boolean = eager;\n    let result: CompileDiDependencyMetadata|null = null;\n    if (!dep.isSkipSelf) {\n      result = this._getLocalDependency(requestingProviderType, dep, eager);\n    }\n    if (dep.isSelf) {\n      if (!result && dep.isOptional) {\n        result = {isValue: true, value: null};\n      }\n    } else {\n      // check parent elements\n      while (!result && currElement._parent) {\n        const prevElement = currElement;\n        currElement = currElement._parent;\n        if (prevElement._isViewRoot) {\n          currEager = false;\n        }\n        result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n      }\n      // check @Host restriction\n      if (!result) {\n        if (!dep.isHost || this.viewContext.component.isHost ||\n            this.viewContext.component.type.reference === tokenReference(dep.token !) ||\n            this.viewContext.viewProviders.get(tokenReference(dep.token !)) != null) {\n          result = dep;\n        } else {\n          result = dep.isOptional ? {isValue: true, value: null} : null;\n        }\n      }\n    }\n    if (!result) {\n      this.viewContext.errors.push(\n          new ProviderError(`No provider for ${tokenName(dep.token!)}`, this._sourceSpan));\n    }\n    return result;\n  }\n}\n\n\nexport class NgModuleProviderAnalyzer {\n  private _transformedProviders = new Map<any, ProviderAst>();\n  private _seenProviders = new Map<any, boolean>();\n  private _allProviders: Map<any, ProviderAst>;\n  private _errors: ProviderError[] = [];\n\n  constructor(\n      private reflector: CompileReflector, ngModule: CompileNgModuleMetadata,\n      extraProviders: CompileProviderMetadata[], sourceSpan: ParseSourceSpan) {\n    this._allProviders = new Map<any, ProviderAst>();\n    ngModule.transitiveModule.modules.forEach((ngModuleType: CompileTypeMetadata) => {\n      const ngModuleProvider = {token: {identifier: ngModuleType}, useClass: ngModuleType};\n      _resolveProviders(\n          [ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, this._errors,\n          this._allProviders, /* isModule */ true);\n    });\n    _resolveProviders(\n        ngModule.transitiveModule.providers.map(entry => entry.provider).concat(extraProviders),\n        ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders,\n        /* isModule */ false);\n  }\n\n  parse(): ProviderAst[] {\n    Array.from(this._allProviders.values()).forEach((provider) => {\n      this._getOrCreateLocalProvider(provider.token, provider.eager);\n    });\n    if (this._errors.length > 0) {\n      const errorString = this._errors.join('\\n');\n      throw new Error(`Provider parse errors:\\n${errorString}`);\n    }\n    // Note: Maps keep their insertion order.\n    const lazyProviders: ProviderAst[] = [];\n    const eagerProviders: ProviderAst[] = [];\n    this._transformedProviders.forEach(provider => {\n      if (provider.eager) {\n        eagerProviders.push(provider);\n      } else {\n        lazyProviders.push(provider);\n      }\n    });\n    return lazyProviders.concat(eagerProviders);\n  }\n\n  private _getOrCreateLocalProvider(token: CompileTokenMetadata, eager: boolean): ProviderAst|null {\n    const resolvedProvider = this._allProviders.get(tokenReference(token));\n    if (!resolvedProvider) {\n      return null;\n    }\n    let transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n    if (transformedProviderAst) {\n      return transformedProviderAst;\n    }\n    if (this._seenProviders.get(tokenReference(token)) != null) {\n      this._errors.push(new ProviderError(\n          `Cannot instantiate cyclic dependency! ${tokenName(token)}`,\n          resolvedProvider.sourceSpan));\n      return null;\n    }\n    this._seenProviders.set(tokenReference(token), true);\n    const transformedProviders = resolvedProvider.providers.map((provider) => {\n      let transformedUseValue = provider.useValue;\n      let transformedUseExisting = provider.useExisting !;\n      let transformedDeps: CompileDiDependencyMetadata[] = undefined !;\n      if (provider.useExisting != null) {\n        const existingDiDep =\n            this._getDependency({token: provider.useExisting}, eager, resolvedProvider.sourceSpan);\n        if (existingDiDep.token != null) {\n          transformedUseExisting = existingDiDep.token;\n        } else {\n          transformedUseExisting = null !;\n          transformedUseValue = existingDiDep.value;\n        }\n      } else if (provider.useFactory) {\n        const deps = provider.deps || provider.useFactory.diDeps;\n        transformedDeps =\n            deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));\n      } else if (provider.useClass) {\n        const deps = provider.deps || provider.useClass.diDeps;\n        transformedDeps =\n            deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));\n      }\n      return _transformProvider(provider, {\n        useExisting: transformedUseExisting,\n        useValue: transformedUseValue,\n        deps: transformedDeps\n      });\n    });\n    transformedProviderAst =\n        _transformProviderAst(resolvedProvider, {eager: eager, providers: transformedProviders});\n    this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n    return transformedProviderAst;\n  }\n\n  private _getDependency(\n      dep: CompileDiDependencyMetadata, eager: boolean = false,\n      requestorSourceSpan: ParseSourceSpan): CompileDiDependencyMetadata {\n    let foundLocal = false;\n    if (!dep.isSkipSelf && dep.token != null) {\n      // access the injector\n      if (tokenReference(dep.token) ===\n              this.reflector.resolveExternalReference(Identifiers.Injector) ||\n          tokenReference(dep.token) ===\n              this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) {\n        foundLocal = true;\n        // access providers\n      } else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n        foundLocal = true;\n      }\n    }\n    return dep;\n  }\n}\n\nfunction _transformProvider(\n    provider: CompileProviderMetadata,\n    {useExisting, useValue, deps}:\n        {useExisting: CompileTokenMetadata, useValue: any, deps: CompileDiDependencyMetadata[]}) {\n  return {\n    token: provider.token,\n    useClass: provider.useClass,\n    useExisting: useExisting,\n    useFactory: provider.useFactory,\n    useValue: useValue,\n    deps: deps,\n    multi: provider.multi\n  };\n}\n\nfunction _transformProviderAst(\n    provider: ProviderAst,\n    {eager, providers}: {eager: boolean, providers: CompileProviderMetadata[]}): ProviderAst {\n  return new ProviderAst(\n      provider.token, provider.multiProvider, provider.eager || eager, providers,\n      provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);\n}\n\nfunction _resolveProvidersFromDirectives(\n    directives: CompileDirectiveSummary[], sourceSpan: ParseSourceSpan,\n    targetErrors: ParseError[]): Map<any, ProviderAst> {\n  const providersByToken = new Map<any, ProviderAst>();\n  directives.forEach((directive) => {\n    const dirProvider:\n        CompileProviderMetadata = {token: {identifier: directive.type}, useClass: directive.type};\n    _resolveProviders(\n        [dirProvider],\n        directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true,\n        sourceSpan, targetErrors, providersByToken, /* isModule */ false);\n  });\n\n  // Note: directives need to be able to overwrite providers of a component!\n  const directivesWithComponentFirst =\n      directives.filter(dir => dir.isComponent).concat(directives.filter(dir => !dir.isComponent));\n  directivesWithComponentFirst.forEach((directive) => {\n    _resolveProviders(\n        directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors,\n        providersByToken, /* isModule */ false);\n    _resolveProviders(\n        directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors,\n        providersByToken, /* isModule */ false);\n  });\n  return providersByToken;\n}\n\nfunction _resolveProviders(\n    providers: CompileProviderMetadata[], providerType: ProviderAstType, eager: boolean,\n    sourceSpan: ParseSourceSpan, targetErrors: ParseError[],\n    targetProvidersByToken: Map<any, ProviderAst>, isModule: boolean) {\n  providers.forEach((provider) => {\n    let resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n    if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n      targetErrors.push(new ProviderError(\n          `Mixing multi and non multi provider is not possible for token ${tokenName(resolvedProvider.token)}`,\n          sourceSpan));\n    }\n    if (!resolvedProvider) {\n      const lifecycleHooks = provider.token.identifier &&\n              (<CompileTypeMetadata>provider.token.identifier).lifecycleHooks ?\n          (<CompileTypeMetadata>provider.token.identifier).lifecycleHooks :\n          [];\n      const isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n      resolvedProvider = new ProviderAst(\n          provider.token, !!provider.multi, eager || isUseValue, [provider], providerType,\n          lifecycleHooks, sourceSpan, isModule);\n      targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n    } else {\n      if (!provider.multi) {\n        resolvedProvider.providers.length = 0;\n      }\n      resolvedProvider.providers.push(provider);\n    }\n  });\n}\n\n\nfunction _getViewQueries(component: CompileDirectiveMetadata): Map<any, QueryWithId[]> {\n  // Note: queries start with id 1 so we can use the number in a Bloom filter!\n  let viewQueryId = 1;\n  const viewQueries = new Map<any, QueryWithId[]>();\n  if (component.viewQueries) {\n    component.viewQueries.forEach(\n        (query) => _addQueryToTokenMap(viewQueries, {meta: query, queryId: viewQueryId++}));\n  }\n  return viewQueries;\n}\n\nfunction _getContentQueries(\n    contentQueryStartId: number, directives: CompileDirectiveSummary[]): Map<any, QueryWithId[]> {\n  let contentQueryId = contentQueryStartId;\n  const contentQueries = new Map<any, QueryWithId[]>();\n  directives.forEach((directive, directiveIndex) => {\n    if (directive.queries) {\n      directive.queries.forEach(\n          (query) => _addQueryToTokenMap(contentQueries, {meta: query, queryId: contentQueryId++}));\n    }\n  });\n  return contentQueries;\n}\n\nfunction _addQueryToTokenMap(map: Map<any, QueryWithId[]>, query: QueryWithId) {\n  query.meta.selectors.forEach((token: CompileTokenMetadata) => {\n    let entry = map.get(tokenReference(token));\n    if (!entry) {\n      entry = [];\n      map.set(tokenReference(token), entry);\n    }\n    entry.push(query);\n  });\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Some of the code comes from WebComponents.JS\n// https://github.com/webcomponents/webcomponentsjs/blob/master/src/HTMLImports/path.js\n\nimport {UrlResolver} from './url_resolver';\n\nexport class StyleWithImports {\n  constructor(public style: string, public styleUrls: string[]) {}\n}\n\nexport function isStyleUrlResolvable(url: string): boolean {\n  if (url == null || url.length === 0 || url[0] == '/') return false;\n  const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n  return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n\n/**\n * Rewrites stylesheets by resolving and removing the @import urls that\n * are either relative or don't have a `package:` scheme\n */\nexport function extractStyleUrls(\n    resolver: UrlResolver, baseUrl: string, cssText: string): StyleWithImports {\n  const foundUrls: string[] = [];\n\n  const modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '')\n                              .replace(CSS_IMPORT_REGEXP, (...m: string[]) => {\n                                const url = m[1] || m[2];\n                                if (!isStyleUrlResolvable(url)) {\n                                  // Do not attempt to resolve non-package absolute URLs with URI\n                                  // scheme\n                                  return m[0];\n                                }\n                                foundUrls.push(resolver.resolve(baseUrl, url));\n                                return '';\n                              });\n  return new StyleWithImports(modifiedCssText, foundUrls);\n}\n\nconst CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\nconst CSS_STRIPPABLE_COMMENT_REGEXP = /\\/\\*(?!#\\s*(?:sourceURL|sourceMappingURL)=)[\\s\\S]+?\\*\\//g;\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {CompileDirectiveSummary, CompilePipeSummary} from '../compile_metadata';\nimport {SecurityContext} from '../core';\nimport {ASTWithSource, BindingPipe, BindingType, BoundElementProperty, EmptyExpr, ParsedEvent, ParsedEventType, ParsedProperty, ParsedPropertyType, ParsedVariable, ParserError, RecursiveAstVisitor, TemplateBinding} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../selector';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nconst PROPERTY_PARTS_SEPARATOR = '.';\nconst ATTRIBUTE_PREFIX = 'attr';\nconst CLASS_PREFIX = 'class';\nconst STYLE_PREFIX = 'style';\n\nconst ANIMATE_PROP_PREFIX = 'animate-';\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  pipesByName: Map<string, CompilePipeSummary>|null = null;\n\n  private _usedPipes: Map<string, CompilePipeSummary> = new Map();\n\n  constructor(\n      private _exprParser: Parser, private _interpolationConfig: InterpolationConfig,\n      private _schemaRegistry: ElementSchemaRegistry, pipes: CompilePipeSummary[]|null,\n      public errors: ParseError[]) {\n    // When the `pipes` parameter is `null`, do not check for used pipes\n    // This is used in IVY when we might not know the available pipes at compile time\n    if (pipes) {\n      const pipesByName: Map<string, CompilePipeSummary> = new Map();\n      pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));\n      this.pipesByName = pipesByName;\n    }\n  }\n\n  get interpolationConfig(): InterpolationConfig { return this._interpolationConfig; }\n\n  getUsedPipes(): CompilePipeSummary[] { return Array.from(this._usedPipes.values()); }\n\n  createBoundHostProperties(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedProperty[]|null {\n    if (dirMeta.hostProperties) {\n      const boundProps: ParsedProperty[] = [];\n      Object.keys(dirMeta.hostProperties).forEach(propName => {\n        const expression = dirMeta.hostProperties[propName];\n        if (typeof expression === 'string') {\n          this.parsePropertyBinding(\n              propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [],\n              boundProps);\n        } else {\n          this._reportError(\n              `Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return boundProps;\n    }\n    return null;\n  }\n\n  createDirectiveHostPropertyAsts(\n      dirMeta: CompileDirectiveSummary, elementSelector: string,\n      sourceSpan: ParseSourceSpan): BoundElementProperty[]|null {\n    const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n    return boundProps &&\n        boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));\n  }\n\n  createDirectiveHostEventAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      ParsedEvent[]|null {\n    if (dirMeta.hostListeners) {\n      const targetEvents: ParsedEvent[] = [];\n      Object.keys(dirMeta.hostListeners).forEach(propName => {\n        const expression = dirMeta.hostListeners[propName];\n        if (typeof expression === 'string') {\n          // TODO: pass a more accurate handlerSpan for this event.\n          this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents);\n        } else {\n          this._reportError(\n              `Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return targetEvents;\n    }\n    return null;\n  }\n\n  parseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const ast = this._exprParser.parseInterpolation(\n          value, sourceInfo, sourceSpan.start.offset, this._interpolationConfig) !;\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, sourceSpan.start.offset);\n    }\n  }\n\n  /**\n   * Parses an inline template binding, e.g.\n   *    <tag *tplKey=\"<tplValue>\">\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteValueOffset start of the tplValue relative to the entire template\n   * @param targetMatchableAttrs potential attributes to match in the template\n   * @param targetProps target property bindings in the template\n   * @param targetVars target variables in the template\n   */\n  parseInlineTemplateBinding(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan, absoluteValueOffset: number,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[],\n      targetVars: ParsedVariable[]) {\n    const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteValueOffset);\n\n    for (let i = 0; i < bindings.length; i++) {\n      const binding = bindings[i];\n      if (binding.keyIsVar) {\n        targetVars.push(new ParsedVariable(binding.key, binding.name, sourceSpan));\n      } else if (binding.expression) {\n        this._parsePropertyAst(\n            binding.key, binding.expression, sourceSpan, undefined, targetMatchableAttrs,\n            targetProps);\n      } else {\n        targetMatchableAttrs.push([binding.key, '']);\n        this.parseLiteralAttr(\n            binding.key, null, sourceSpan, absoluteValueOffset, undefined, targetMatchableAttrs,\n            targetProps);\n      }\n    }\n  }\n\n  /**\n   * Parses the bindings in an inline template binding, e.g.\n   *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n   * @param tplKey template binding name\n   * @param tplValue template binding value\n   * @param sourceSpan span of template binding relative to entire the template\n   * @param absoluteValueOffset start of the tplValue relative to the entire template\n   */\n  private _parseTemplateBindings(\n      tplKey: string, tplValue: string, sourceSpan: ParseSourceSpan,\n      absoluteValueOffset: number): TemplateBinding[] {\n    const sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const bindingsResult =\n          this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteValueOffset);\n      this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n      bindingsResult.templateBindings.forEach((binding) => {\n        if (binding.expression) {\n          this._checkPipes(binding.expression, sourceSpan);\n        }\n      });\n      bindingsResult.warnings.forEach(\n          (warning) => { this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n      return bindingsResult.templateBindings;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n\n  parseLiteralAttr(\n      name: string, value: string|null, sourceSpan: ParseSourceSpan, absoluteOffset: number,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[]) {\n    if (isAnimationLabel(name)) {\n      name = name.substring(1);\n      if (value) {\n        this._reportError(\n            `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n            sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseAnimation(\n          name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);\n    } else {\n      targetProps.push(new ParsedProperty(\n          name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset),\n          ParsedPropertyType.LITERAL_ATTR, sourceSpan, valueSpan));\n    }\n  }\n\n  parsePropertyBinding(\n      name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n      absoluteOffset: number, valueSpan: ParseSourceSpan|undefined,\n      targetMatchableAttrs: string[][], targetProps: ParsedProperty[]) {\n    let isAnimationProp = false;\n    if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n      isAnimationProp = true;\n      name = name.substring(ANIMATE_PROP_PREFIX.length);\n    } else if (isAnimationLabel(name)) {\n      isAnimationProp = true;\n      name = name.substring(1);\n    }\n\n    if (isAnimationProp) {\n      this._parseAnimation(\n          name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs,\n          targetProps);\n    } else {\n      this._parsePropertyAst(\n          name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset),\n          sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n    }\n  }\n\n  parsePropertyInterpolation(\n      name: string, value: string, sourceSpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[]): boolean {\n    const expr = this.parseInterpolation(value, valueSpan || sourceSpan);\n    if (expr) {\n      this._parsePropertyAst(name, expr, sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n\n  private _parsePropertyAst(\n      name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[]) {\n    targetMatchableAttrs.push([name, ast.source !]);\n    targetProps.push(\n        new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, valueSpan));\n  }\n\n  private _parseAnimation(\n      name: string, expression: string|null, sourceSpan: ParseSourceSpan, absoluteOffset: number,\n      valueSpan: ParseSourceSpan|undefined, targetMatchableAttrs: string[][],\n      targetProps: ParsedProperty[]) {\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const ast = this._parseBinding(\n        expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n    targetMatchableAttrs.push([name, ast.source !]);\n    targetProps.push(\n        new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, valueSpan));\n  }\n\n  private _parseBinding(\n      value: string, isHostBinding: boolean, sourceSpan: ParseSourceSpan,\n      absoluteOffset: number): ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n    try {\n      const ast = isHostBinding ?\n          this._exprParser.parseSimpleBinding(\n              value, sourceInfo, absoluteOffset, this._interpolationConfig) :\n          this._exprParser.parseBinding(\n              value, sourceInfo, absoluteOffset, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  createBoundElementProperty(\n      elementSelector: string, boundProp: ParsedProperty, skipValidation: boolean = false,\n      mapPropertyName: boolean = true): BoundElementProperty {\n    if (boundProp.isAnimation) {\n      return new BoundElementProperty(\n          boundProp.name, BindingType.Animation, SecurityContext.NONE, boundProp.expression, null,\n          boundProp.sourceSpan, boundProp.valueSpan);\n    }\n\n    let unit: string|null = null;\n    let bindingType: BindingType = undefined !;\n    let boundPropertyName: string|null = null;\n    const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let securityContexts: SecurityContext[] = undefined !;\n\n    // Check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        }\n        securityContexts = calcPossibleSecurityContexts(\n            this._schemaRegistry, elementSelector, boundPropertyName, true);\n\n        const nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = BindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = BindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n      securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry, elementSelector, mappedPropName, false);\n      bindingType = BindingType.Property;\n      if (!skipValidation) {\n        this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n      }\n    }\n\n    return new BoundElementProperty(\n        boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit,\n        boundProp.sourceSpan, boundProp.valueSpan);\n  }\n\n  parseEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, handlerSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    if (isAnimationLabel(name)) {\n      name = name.substr(1);\n      this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents);\n    } else {\n      this._parseRegularEvent(\n          name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents);\n    }\n  }\n\n  calcPossibleSecurityContexts(selector: string, propName: string, isAttribute: boolean):\n      SecurityContext[] {\n    const prop = this._schemaRegistry.getMappedPropName(propName);\n    return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n  }\n\n  private _parseAnimationEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, handlerSpan: ParseSourceSpan,\n      targetEvents: ParsedEvent[]) {\n    const matches = splitAtPeriod(name, [name, '']);\n    const eventName = matches[0];\n    const phase = matches[1].toLowerCase();\n    if (phase) {\n      switch (phase) {\n        case 'start':\n        case 'done':\n          const ast = this._parseAction(expression, handlerSpan);\n          targetEvents.push(new ParsedEvent(\n              eventName, phase, ParsedEventType.Animation, ast, sourceSpan, handlerSpan));\n          break;\n\n        default:\n          this._reportError(\n              `The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`,\n              sourceSpan);\n          break;\n      }\n    } else {\n      this._reportError(\n          `The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`,\n          sourceSpan);\n    }\n  }\n\n  private _parseRegularEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan, handlerSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: ParsedEvent[]) {\n    // long format: 'target: eventName'\n    const [target, eventName] = splitAtColon(name, [null !, name]);\n    const ast = this._parseAction(expression, handlerSpan);\n    targetMatchableAttrs.push([name !, ast.source !]);\n    targetEvents.push(\n        new ParsedEvent(eventName, target, ParsedEventType.Regular, ast, sourceSpan, handlerSpan));\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n\n  private _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n    const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;\n\n    try {\n      const ast = this._exprParser.parseAction(\n          value, sourceInfo, absoluteOffset, this._interpolationConfig);\n      if (ast) {\n        this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch (e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n    }\n  }\n\n  private _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this.errors.push(new ParseError(sourceSpan, message, level));\n  }\n\n  private _reportExpressionParserErrors(errors: ParserError[], sourceSpan: ParseSourceSpan) {\n    for (const error of errors) {\n      this._reportError(error.message, sourceSpan);\n    }\n  }\n\n  // Make sure all the used pipes are known in `this.pipesByName`\n  private _checkPipes(ast: ASTWithSource, sourceSpan: ParseSourceSpan): void {\n    if (ast && this.pipesByName) {\n      const collector = new PipeCollector();\n      ast.visit(collector);\n      collector.pipes.forEach((ast, pipeName) => {\n        const pipeMeta = this.pipesByName !.get(pipeName);\n        if (!pipeMeta) {\n          this._reportError(\n              `The pipe '${pipeName}' could not be found`,\n              new ParseSourceSpan(\n                  sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n        } else {\n          this._usedPipes.set(pipeName, pipeMeta);\n        }\n      });\n    }\n  }\n\n  /**\n   * @param propName the name of the property / attribute\n   * @param sourceSpan\n   * @param isAttr true when binding to an attribute\n   */\n  private _validatePropertyOrAttributeName(\n      propName: string, sourceSpan: ParseSourceSpan, isAttr: boolean): void {\n    const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n                            this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError(report.msg !, sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n}\n\nexport class PipeCollector extends RecursiveAstVisitor {\n  pipes = new Map<string, BindingPipe>();\n  visitPipe(ast: BindingPipe, context: any): any {\n    this.pipes.set(ast.name, ast);\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n}\n\nfunction isAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n\nexport function calcPossibleSecurityContexts(\n    registry: ElementSchemaRegistry, selector: string, propName: string,\n    isAttribute: boolean): SecurityContext[] {\n  const ctxs: SecurityContext[] = [];\n  CssSelector.parse(selector).forEach((selector) => {\n    const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    const notElementNames =\n        new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n                    .map((selector) => selector.element));\n    const possibleElementNames =\n        elementNames.filter(elementName => !notElementNames.has(elementName));\n\n    ctxs.push(...possibleElementNames.map(\n        elementName => registry.securityContext(elementName, propName, isAttribute)));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as html from '../ml_parser/ast';\nimport {isNgContent} from '../ml_parser/tags';\n\nconst NG_CONTENT_SELECT_ATTR = 'select';\nconst LINK_ELEMENT = 'link';\nconst LINK_STYLE_REL_ATTR = 'rel';\nconst LINK_STYLE_HREF_ATTR = 'href';\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\nconst STYLE_ELEMENT = 'style';\nconst SCRIPT_ELEMENT = 'script';\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nconst NG_PROJECT_AS = 'ngProjectAs';\n\nexport function preparseElement(ast: html.Element): PreparsedElement {\n  let selectAttr: string = null !;\n  let hrefAttr: string = null !;\n  let relAttr: string = null !;\n  let nonBindable = false;\n  let projectAs = '';\n  ast.attrs.forEach(attr => {\n    const lcAttrName = attr.name.toLowerCase();\n    if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n      selectAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n      hrefAttr = attr.value;\n